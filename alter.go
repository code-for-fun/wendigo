/* This file contains C code routines that used to generate VDBE code
** that implements the ALTER TABLE command.
*/

/*
** The code in this file only exists if we are not omitting the
** ALTER TABLE logic from the build.
*/
#ifndef SQLITE_OMIT_ALTERTABLE


/*
** This function is used by SQL generated to implement the 
** ALTER TABLE command. The first argument is the text of a CREATE TABLE or
** CREATE INDEX command. The second is a table name. The table name in 
** the CREATE TABLE or CREATE INDEX statement is replaced with the third
** argument and the result returned. Examples:
**
** sqlite_rename_table('CREATE TABLE abc(a, b, c)', 'def')
**     . 'CREATE TABLE def(a, b, c)'
**
** sqlite_rename_table('CREATE INDEX i ON abc(a)', 'def')
**     . 'CREATE INDEX i ON def(a, b, c)'
*/
static void renameTableFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  unsigned char const *zSql = sqlite3_value_text(argv[0]);
  unsigned char const *zTableName = sqlite3_value_text(argv[1]);

  int token;
  Token tname;
  unsigned char const *zCsr = zSql;
  int len = 0;
  char *zRet;

  sqlite3 *db = sqlite3_context_db_handle(context);

  /* The principle used to locate the table name in the CREATE TABLE 
  ** statement is that the table name is the first non-space token that
  ** is immediately followed by a TK_LP or TK_USING token.
  */
  if( zSql ){
    do {
      if( !*zCsr ){
        /* Ran out of input before finding an opening bracket. Return NULL. */
        return;
      }

      /* Store the token that zCsr points to in tname. */
      tname.z = (char*)zCsr;
      tname.n = len;

      /* Advance zCsr to the next token. Store that token type in 'token',
      ** and its length in 'len' (to be used next iteration of this loop).
      */
      do {
        zCsr += len;
        len = sqlite3GetToken(zCsr, &token);
      } while( token==TK_SPACE );
      assert( len>0 );
    } while( token!=TK_LP && token!=TK_USING );

    zRet = fmt.Sprintf("%v*%v\"%v\"%v", ((byte*)tname.z) - zSql, zSql, zTableName, tname.z+tname.n);
    sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC);
  }
}

/*
** This C function implements an SQL user function that is used by SQL code
** generated by the ALTER TABLE ... RENAME command to modify the definition
** of any foreign key constraints that use the table being renamed as the 
** parent table. It is passed three arguments:
**
**   1) The complete text of the CREATE TABLE statement being modified,
**   2) The old name of the table being renamed, and
**   3) The new name of the table being renamed.
**
** It returns the new CREATE TABLE statement. For example:
**
**   sqlite_rename_parent('CREATE TABLE t1(a REFERENCES t2)', 't2', 't3')
**       . 'CREATE TABLE t1(a REFERENCES t3)'
*/
static void renameParentFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  char *zOutput = 0;
  char *zResult;
  unsigned char const *zInput = sqlite3_value_text(argv[0]);
  unsigned char const *zOld = sqlite3_value_text(argv[1]);
  unsigned char const *zNew = sqlite3_value_text(argv[2]);

  unsigned const char *z;         /* Pointer to token */
  int n;                          /* Length of token z */
  int token;                      /* Type of token */

  for(z=zInput; *z; z=z+n){
    n = sqlite3GetToken(z, &token);
    if( token==TK_REFERENCES ){
      char *zParent;
      do {
        z += n;
        n = sqlite3GetToken(z, &token);
      }while( token==TK_SPACE );

      zParent = sqlite3DbStrNDup(db, (const char *)z, n);
      if( zParent==0 ) break;
      zParent = Dequote(zParent)
      if CaseInsensitiveMatch(zOld, zParent) {
        char *zOut = fmt.Sprintf("%v%v*%v\"%v\"", ( zOutput ? zOutput : ""), z-zInput, zInput, (const char *)zNew);
        zOutput = zOut;
        zInput = &z[n];
      }
      zParent = nil
    }
  }

  zResult = fmt.Sprintf("%v%v", (zOutput ? zOutput : ""), zInput), sqlite3_result_text(context, zResult, -1, SQLITE_DYNAMIC);
  zOutput = nil
}

/* This function is used by SQL generated to implement the
** ALTER TABLE command. The first argument is the text of a CREATE TRIGGER 
** statement. The second is a table name. The table name in the CREATE 
** TRIGGER statement is replaced with the third argument and the result 
** returned. This is analagous to renameTableFunc() above, except for CREATE
** TRIGGER, not CREATE INDEX and CREATE TABLE.
*/
static void renameTriggerFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  unsigned char const *zSql = sqlite3_value_text(argv[0]);
  unsigned char const *zTableName = sqlite3_value_text(argv[1]);

  int token;
  Token tname;
  int dist = 3;
  unsigned char const *zCsr = zSql;
  int len = 0;
  char *zRet;
  sqlite3 *db = sqlite3_context_db_handle(context);

  /* The principle used to locate the table name in the CREATE TRIGGER 
  ** statement is that the table name is the first token that is immediatedly
  ** preceded by either TK_ON or TK_DOT and immediatedly followed by one
  ** of TK_WHEN, TK_BEGIN or TK_FOR.
  */
  if( zSql ){
    do {

      if( !*zCsr ){
        /* Ran out of input before finding the table name. Return NULL. */
        return;
      }

      /* Store the token that zCsr points to in tname. */
      tname.z = (char*)zCsr;
      tname.n = len;

      /* Advance zCsr to the next token. Store that token type in 'token',
      ** and its length in 'len' (to be used next iteration of this loop).
      */
      do {
        zCsr += len;
        len = sqlite3GetToken(zCsr, &token);
      }while( token==TK_SPACE );
      assert( len>0 );

      /* Variable 'dist' stores the number of tokens read since the most
      ** recent TK_DOT or TK_ON. This means that when a WHEN, FOR or BEGIN 
      ** token is read and 'dist' equals 2, the condition stated above
      ** to be met.
      **
      ** Note that ON cannot be a database, table or column name, so
      ** there is no need to worry about syntax like 
      ** "CREATE TRIGGER ... ON ON.ON BEGIN ..." etc.
      */
      dist++;
      if( token==TK_DOT || token==TK_ON ){
        dist = 0;
      }
    } while( dist!=2 || (token!=TK_WHEN && token!=TK_FOR && token!=TK_BEGIN) );

    /* Variable tname now contains the token that is the old table-name
    ** in the CREATE TRIGGER statement.
    */
    zRet = fmt.Sprintf("%v*%v\"%v\"%v", ((byte*)tname.z) - zSql, zSql, zTableName, tname.z+tname.n);
    sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC);
  }
}

/*
** Register built-in functions used to help implement ALTER TABLE
*/
 void sqlite3AlterFunctions(void){
  static FuncDef aAlterTableFuncs[] = {
    FUNCTION(sqlite_rename_table,   2, 0, 0, renameTableFunc),
    FUNCTION(sqlite_rename_trigger, 2, 0, 0, renameTriggerFunc),
    FUNCTION(sqlite_rename_parent,  3, 0, 0, renameParentFunc),
  };
  int i;
  FuncDefHash *pHash = &sqlite3GlobalFunctions
  FuncDef *aFunc = (FuncDef*)&aAlterTableFuncs

  for(i=0; i<ArraySize(aAlterTableFuncs); i++){
    pHash.Insert(aFunc[i])
  }
}

/*
** This function is used to create the text of expressions of the form:
**
**   name=<constant1> OR name=<constant2> OR ...
**
** If argument zWhere is NULL, then a pointer string containing the text 
** "name=<constant>" is returned, where <constant> is the quoted version
** of the string passed as argument zConstant. The returned buffer is
** allocated using sqlite3DbMalloc(). It is the responsibility of the
** caller to ensure that it is eventually freed.
**
** If argument zWhere is not NULL, then the string returned is 
** "<where> OR name=<constant>", where <where> is the contents of zWhere.
** 
*/
static char *whereOrName(sqlite3 *db, char *zWhere, char *zConstant){
  char *zNew;
  if( !zWhere ){
    zNew = fmt.Sprintf("name=%v", zConstant);
  }else{
    zNew = fmt.Sprintf("%v OR name=%v", zWhere, zConstant);
    zWhere = nil
  }
  return zNew;
}

/*
** Generate the text of a WHERE expression which can be used to select all
** tables that have foreign key constraints that refer to table pTab (i.e.
** constraints for which pTab is the parent table) from the sqlite_master
** table.
*/
static char *whereForeignKeys(Parse *pParse, Table *pTab){
  char *zWhere = 0;
  for p := pTab.FkReferences(); p; p = p.NextTo {
    zWhere = whereOrName(pParse.db, zWhere, p.pFrom.Name);
  }
  return zWhere;
}

/*
** Generate the text of a WHERE expression which can be used to select all
** temporary triggers on table pTab from the sqlite_temp_master table. If
** table pTab has no temporary triggers, or is itself stored in the 
** temporary database, NULL is returned.
*/
static char *whereTempTriggers(Parse *pParse, Table *pTab){
  Trigger *pTrig;
  char *zWhere = 0;
  const Schema *pTempSchema = pParse.db.Databases[1].Schema; /* Temp db schema */

  /* If the table is not located in the temp-db (in which case NULL is 
  ** returned, loop through the tables list of triggers. For each trigger
  ** that is not part of the temp-db schema, add a clause to the WHERE 
  ** expression being built up in zWhere.
  */
  if( pTab.Schema!=pTempSchema ){
    sqlite3 *db = pParse.db;
    for(pTrig=pParse.TriggerList(pTab); pTrig; pTrig=pTrig.Next){
      if( pTrig.Schema==pTempSchema ){
        zWhere = whereOrName(db, zWhere, pTrig.Name);
      }
    }
  }
  if( zWhere ){
    char *zNew = fmt.Sprintf("type='trigger' AND (%v)", zWhere);
    zWhere = zNew;
  }
  return zWhere;
}

/*
** Generate code to drop and reload the internal representation of table
** pTab from the database, including triggers and temporary triggers.
** Argument Name is the name of the table in the database schema at
** the time the generated code is executed. This can be different from
** pTab.Name if this function is being called to code part of an 
** "ALTER TABLE RENAME TO" statement.
*/
static void reloadTableSchema(Parse *pParse, Table *pTab, const char *Name){
  Vdbe *v;
  char *zWhere;
  int iDb;                   /* Index of database containing pTab */
  Trigger *pTrig;

  v = pParse.GetVdbe()
  if( v==0 ) return;
  iDb = pParse.db.SchemaToIndex(pTab.Schema)
  assert( iDb>=0 );

  /* Drop any table triggers from the internal schema. */
  for(pTrig= pParse.TriggerList(pTab); pTrig; pTrig=pTrig.Next){
    int iTrigDb = pParse.db.SchemaToIndex(pTrig.Schema)
    assert( iTrigDb==iDb || iTrigDb==1 );
    sqlite3VdbeAddOp4(v, OP_DropTrigger, iTrigDb, 0, 0, pTrig.Name, 0);
  }

  /* Drop the table and index from the internal schema.  */
  sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab.Name, 0);

  /* Reload the table, index and permanent trigger schemas. */
  zWhere = fmt.Sprintf("tbl_name=%v", Name);
  if( !zWhere ) return;
  v.AddParseSchemaOp(iDb, zWhere)

  //	Now, if the table is not stored in the temp database, reload any temp triggers.
  if( (zWhere=whereTempTriggers(pParse, pTab))!=0 ){
    v.AddParseSchemaOp(1, zWhere)
  }
}

//	Parameter Name is the name of a table that is about to be altered (either with ALTER TABLE ... RENAME TO or ALTER TABLE ... ADD COLUMN). If the table is a system table, this function leaves an error message in pParse.zErr (system tables may not be altered) and returns non-zero.
//	Or, if Name is not a system table, zero is returned.
func (pParse *Parse) isSystemTable(Name string) (ok bool)
	 if len(Name) > 6 && CaseInsensitiveMatchN(Name, "sqlite_", 7) {
		pParse.SetErrorMsg("table %v may not be altered", Name);
		ok = true
	}
	return
}

/*
** Generate code to implement the "ALTER TABLE xxx RENAME TO yyy" 
** command. 
*/
 void sqlite3AlterRenameTable(
  Parse *pParse,            /* Parser context. */
  SrcList *pSrc,            /* The table to rename. */
  Token *pName              /* The new table name. */
){
  int iDb;                  /* Database that contains the table */
  char *zDb;                /* Name of database iDb */
  Table *pTab;              /* Table being renamed */
  char *Name = 0;          /* NULL-terminated version of pName */ 
  sqlite3 *db = pParse.db; /* Database connection */
  int nTabName;             /* Number of UTF-8 characters in zTabName */
  const char *zTabName;     /* Original name of the table */
  Vdbe *v;
  char *zWhere = 0;         /* Where clause to locate temp triggers */
  VTable *pVTab = 0;        /* Non-zero if this is a v-tab with an xRename() */
  int savedDbFlags;         /* Saved value of db.flags */

  savedDbFlags = db.flags;  
  if( db.mallocFailed ) goto exit_rename_table;
  assert( pSrc.nSrc==1 );

  pTab = pParse.LocateTable(pSrc.a[0].Name, pSrc.a[0].zDatabase, false);
  if( !pTab ) goto exit_rename_table;
  iDb = pParse.db.SchemaToIndex(pTab.Schema)
  zDb = db.Databases[iDb].Name;
  db.flags |= SQLITE_PreferBuiltin;

  /* Get a NULL terminated version of the new table name. */
  Name = Dequote(pName);
  if( !Name ) goto exit_rename_table;

  /* Check that a table or index named 'Name' does not already exist
  ** in database iDb. If so, this is an error.
  */
  if db.FindTable(Name, zDb) || db.FindIndex(Name, zDb) {
    pParse.SetErrorMsg("there is already another table or index with this name: %v", Name);
    goto exit_rename_table;
  }

  /* Make sure it is not a system table being altered, or a reserved name
  ** that the table is being renamed to.
  */
  if pParse.isSystemTable(pTab.Name) != SQLITE_OK {
    goto exit_rename_table;
  }
  if( SQLITE_OK!=sqlite3CheckObjectName(pParse, Name) ){ goto
    exit_rename_table;
  }

  if( pTab.Select ){
    pParse.SetErrorMsg("view %v may not be altered", pTab.Name);
    goto exit_rename_table;
  }

  /* Invoke the authorization callback. */
  if pParse.AuthCheck(SQLITE_ALTER_TABLE, zDb, pTab.Name, 0) != SQLITE_OK {
    goto exit_rename_table;
  }

  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto exit_rename_table;
  }
  if( pTab.IsVirtual() ){
    pVTab = sqlite3GetVTable(db, pTab);
    if( pVTab.pVtab.Callbacks.xRename==0 ){
      pVTab = 0;
    }
  }

  /* Begin a transaction and code the VerifyCookie for database iDb. 
  ** Then modify the schema cookie (since the ALTER TABLE modifies the
  ** schema). Open a statement transaction if the table is a virtual
  ** table.
  */
  v = pParse.GetVdbe()
  if( v==0 ){
    goto exit_rename_table;
  }
  pParse.BeginWriteOperation(pVTab != 0, iDb)
  sqlite3ChangeCookie(pParse, iDb);

  /* If this is a virtual table, invoke the xRename() function if
  ** one is defined. The xRename() callback will modify the names
  ** of any resources used by the v-table implementation (including other
  ** SQLite tables) that are identified by the name of the virtual table.
  */
  if( pVTab ){
    int i = ++pParse.nMem;
    sqlite3VdbeAddOp4(v, OP_String8, 0, i, 0, Name, 0);
    sqlite3VdbeAddOp4(v, OP_VRename, i, 0, 0,(const char*)pVTab, P4_VTAB);
    sqlite3MayAbort(pParse);
  }

  /* figure out how many UTF-8 characters are in Name */
  zTabName = pTab.Name;
  nTabName = len(zTabName)

  if( db.flags&SQLITE_ForeignKeys ){
    /* If foreign-key support is enabled, rewrite the CREATE TABLE 
    ** statements corresponding to all child tables of foreign key constraints
    ** for which the renamed table is the parent table.  */
    if( (zWhere=whereForeignKeys(pParse, pTab))!=0 ){
      sqlite3NestedParse(pParse, 
          "UPDATE \"%w\".%s SET "
              "sql = sqlite_rename_parent(sql, %Q, %Q) "
              "WHERE %s;", zDb, SCHEMA_TABLE(iDb), zTabName, Name, zWhere);
      zWhere = nil
    }
  }

  /* Modify the sqlite_master table to use the new table name. */
  sqlite3NestedParse(pParse,
      "UPDATE %Q.%s SET "
          "sql = CASE "
            "WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)"
            "ELSE sqlite_rename_table(sql, %Q) END, "
          "tbl_name = %Q, "
          "name = CASE "
            "WHEN type='table' THEN %Q "
            "WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN "
             "'sqlite_autoindex_' || %Q || substr(name,%d+18) "
            "ELSE name END "
      "WHERE tbl_name=%Q COLLATE nocase AND "
          "(type='table' OR type='index' OR type='trigger');", 
      zDb, SCHEMA_TABLE(iDb), Name, Name, Name, 
      Name,
      Name, nTabName, zTabName
  );

#ifndef SQLITE_OMIT_AUTOINCREMENT
  /* If the sqlite_sequence table exists in this database, then update 
  ** it with the new table name.
  */
  if db.FindTable("sqlite_sequence", zDb) {
    sqlite3NestedParse(pParse,
        "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q",
        zDb, Name, pTab.Name);
  }
#endif

  /* If there are TEMP triggers on this table, modify the sqlite_temp_master
  ** table. Don't do this if the table being ALTERed is itself located in
  ** the temp database.
  */
  if( (zWhere=whereTempTriggers(pParse, pTab))!=0 ){
    sqlite3NestedParse(pParse, 
        "UPDATE sqlite_temp_master SET "
            "sql = sqlite_rename_trigger(sql, %Q), "
            "tbl_name = %Q "
            "WHERE %s;", Name, Name, zWhere);
    zWhere = nil
  }

  if( db.flags&SQLITE_ForeignKeys ){
    for p := pTab.FkReferences(); p; p = p.NextTo {
      if pFrom := p.pFrom; pFrom != pTab {
        reloadTableSchema(pParse, p.pFrom, pFrom.Name)
      }
    }
  }

  /* Drop and reload the internal table schema. */
  reloadTableSchema(pParse, pTab, Name);

exit_rename_table:
  sqlite3SrcListDelete(db, pSrc);
  Name = nil
  db.flags = savedDbFlags;
}


/*
** Generate code to make sure the file format number is at least minFormat.
** The generated code will increase the file format number if necessary.
*/
 void sqlite3MinimumFileFormat(Parse *pParse, int iDb, int minFormat){
  Vdbe *v;
  v = pParse.GetVdbe()
  /* The VDBE should have been allocated before this routine is called.
  ** If that allocation failed, we would have quit before reaching this
  ** point */
  if( v ){
    int r1 = pParse.GetTempReg()
    int r2 = pParse.GetTempReg()
    int j1;
    v.AddOp3(OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT);
    sqlite3VdbeUsesBtree(v, iDb);
    v.AddOp2(OP_Integer, minFormat, r2);
    j1 = v.AddOp3(OP_Ge, r2, 0, r1);
    v.AddOp3(OP_SetCookie, iDb, BTREE_FILE_FORMAT, r2);
    v.JumpHere(j1)
    pParse.ReleaseTempReg(r1)
    pParse.ReleaseTempReg(r2)
  }
}

/*
** This function is called after an "ALTER TABLE ... ADD" statement
** has been parsed. Argument pColDef contains the text of the new
** column definition.
**
** The Table structure pParse.pNewTable was extended to include
** the new column during parsing.
*/
 void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){
  Table *pNew;              /* Copy of pParse.pNewTable */
  Table *pTab;              /* Table being altered */
  int iDb;                  /* Database number */
  const char *zDb;          /* Database name */
  const char *zTab;         /* Table name */
  char *zCol;               /* Null-terminated column definition */
  Column *pCol;             /* The new column */
  Expr *pDflt;              /* Default value for the new column */
  sqlite3 *db;              /* The database connection; */

  db = pParse.db;
  if( pParse.nErr || db.mallocFailed ) return;
  pNew = pParse.pNewTable;
  assert( pNew );

  iDb = db.SchemaToIndex(pNew.Schema)
  zDb = db.Databases[iDb].Name;
  zTab = &pNew.Name[16];  /* Skip the "sqlite_altertab_" prefix on the name */
  pCol = &pNew.Columns[pNew.nCol-1];
  pDflt = pCol.pDflt;
  pTab = db.FindTable(zTab, zDb)
  assert( pTab );

  /* Invoke the authorization callback. */
  if pParse.AuthCheck(SQLITE_ALTER_TABLE, zDb, pTab.Name, 0) != SQLITE_OK {
    return;
  }

  /* If the default value for the new column was specified with a 
  ** literal NULL, then set pDflt to 0. This simplifies checking
  ** for an SQL NULL default below.
  */
  if( pDflt && pDflt.op==TK_NULL ){
    pDflt = 0;
  }

  /* Check that the new column is not specified as PRIMARY KEY or UNIQUE.
  ** If there is a NOT NULL constraint, then the default value for the
  ** column must not be NULL.
  */
  if pCol.isPrimKey {
    pParse.SetErrorMsg("Cannot add a PRIMARY KEY column")
    return
  }
  if len(pNew.Indices) > 0 {
    pParse.SetErrorMsg("Cannot add a UNIQUE column")
    return
  }
  if (db.flags & SQLITE_ForeignKeys) && pNew.ForeignKey && pDflt {
    pParse.SetErrorMsg("Cannot add a REFERENCES column with non-NULL default value")
    return
  }
  if( pCol.notNull && !pDflt ){
    pParse.SetErrorMsg("Cannot add a NOT NULL column with default value NULL");
    return;
  }

	//	Ensure the default expression is something that sqlite3::ValueFromExpr() can handle (i.e. not CURRENT_TIME etc.)
	if pDflt != nil {
		switch rc, pVal := db.ValueFromExpr(pDflt, SQLITE_UTF8, SQLITE_AFF_NONE); {
		case rc = SQLITE_OK:
			db.mallocFailed = true
			return
    	case pVal == nil:
			pParse.SetErrorMsg("Cannot add a column with non-constant default")
			return
    	}
  	}

  /* Modify the CREATE TABLE statement. */
  zCol = sqlite3DbStrNDup(db, (char*)pColDef.z, pColDef.n);
  if( zCol ){
    char *zEnd = &zCol[pColDef.n-1];
    int savedDbFlags = db.flags;
    while( zEnd>zCol && (*zEnd==';' || sqlite3Isspace(*zEnd)) ){
      *zEnd-- = '\0';
    }
    db.flags |= SQLITE_PreferBuiltin;
    sqlite3NestedParse(pParse, 
        "UPDATE \"%w\".%s SET "
          "sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) "
        "WHERE type = 'table' AND name = %Q", 
      zDb, SCHEMA_TABLE(iDb), pNew.addColOffset, zCol, pNew.addColOffset+1,
      zTab
    );
    zCol = nil
    db.flags = savedDbFlags;
  }

  /* If the default value of the new column is NULL, then set the file
  ** format to 2. If the default value of the new column is not NULL,
  ** the file format becomes 3.
  */
  sqlite3MinimumFileFormat(pParse, iDb, pDflt ? 3 : 2);

  /* Reload the schema of the modified table. */
  reloadTableSchema(pParse, pTab, pTab.Name);
}

//	This function is called by the parser after the table-name in an "ALTER TABLE <table-name> ADD" statement is parsed. Argument pSrc is the full-name of the table being altered.
//	This routine makes a (partial) copy of the Table structure for the table being altered and sets Parse.pNewTable to point to it. Routines called by the parser as the column definition is parsed (i.e. sqlite3AddColumn()) add the new Column data to the copy. The copy of the Table structure is deleted by tokenize.c after parsing is finished.
//	Routine sqlite3AlterFinishAddColumn() will be called to complete coding the "ALTER TABLE ... ADD" statement.
void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){
  db := pParse.db
  defer func() {
	  sqlite3SrcListDelete(db, pSrc)
  }()
  //	Look up the table being altered.
  assert( pParse.pNewTable == nil )
  if !db.mallocFailed {
	  if pTab := pParse.LocateTable(pSrc.a[0].Name, pSrc.a[0].zDatabase, false); pTab != nil {
		  if( pTab.IsVirtual() ){
			  pParse.SetErrorMsg("virtual tables may not be altered");
			  return
		  }

		  //	Make sure this is not an attempt to ALTER a view.
		  if( pTab.Select ){
			  pParse.SetErrorMsg("Cannot add a column to a view");
			  return
		  }
		  if pParse.isSystemTable(pTab.Name) == SQLITE_OK {
			  assert( pTab.addColOffset>0 );
			  iDb := db.SchemaToIndex(pTab.Schema)

			  /* Put a copy of the Table struct in Parse.pNewTable for the
			  ** sqlite3AddColumn() function and friends to modify.  But modify
			  ** the name by adding an "sqlite_altertab_" prefix.  By adding this
			  ** prefix, we insure that the name will not collide with an existing
			  ** table because user table are not allowed to have the "sqlite_"
			  ** prefix on their name.
			  */
			  pNew := &Table{
				  nRef:				1,
				  Columns:			make([]*Column),
				  Name:				fmt.Sprintf("sqlite_altertab_%v", pTab.Name),
				  Schema:			db.Databases[iDb].Schema,
				  addColOffset:		pTab.addColOffset,
			  }
			  pParse.pNewTable = pNew;

			  memcpy(pNew.Columns, pTab.Columns, sizeof(Column)*pNew.nCol);
			  for _, pCol := range pNew.Columns {
			    pCol.Name = sqlite3DbStrDup(db, pCol.Name)
			  }

			  //	Begin a transaction and increment the schema cookie
			  pParse.BeginWriteOperation(0, iDb)
			  if v := pParse.GetVdbe(); v != nil {
				  sqlite3ChangeCookie(pParse, iDb)
				}
		  }
	  }
  }
}
#endif  /* SQLITE_ALTER_TABLE */
