package btree

//	This file implements a external (disk-based) database using BTrees.
//	See the header comment on "btreeInt.h" for additional information.
//	Including a description of file format and an overview of operation.

//	This is a magic string that appears at the beginning of every SQLite database in order to identify the file as a real database.
//	The header must be exactly 16 bytes including the zero-terminator so the string itself should be 15 characters long. If you change
//	the header, then your custom library will not be able to read databases generated by the standard tools and the standard tools
//	will not be able to read databases created by your custom library.
const zMagicHeader string = "SQLite format 3"

//	A list of BtShared objects that are eligible for participation in shared cache. This variable has file scope during normal builds,
//	but the test harness needs to access it so we make it global for test builds.
//	Access to this variable is protected by SQLITE_MUTEX_STATIC_MASTER.
static BtShared *sqlite3SharedCacheList = 0;

//	Enable or disable the shared pager and schema features.
//	This routine has no effect on existing database connections.
//	The shared cache setting effects only future calls to sqlite3_open() or sqlite3_open_v2().
func EnableSharedCache() {
  sqlite3GlobalConfig.sharedCacheEnabled = true
}

func DisableSharedCache() {
  sqlite3GlobalConfig.sharedCacheEnabled = false
}

func SetSharedCache(enable bool) {
  sqlite3GlobalConfig.sharedCacheEnabled = enable
}


//	Query to see if Btree handle p may obtain a lock of type eLock (READ_LOCK or WRITE_LOCK) on the table with root-page iTab.
//	Return SQLITE_OK if the lock may be obtained (by calling setSharedCacheTableLock()), or SQLITE_LOCKED if not.
func (p *Btree) querySharedCacheTableLock(iTab PageNumber, eLock byte) int {
	btree := p.Btree
	if p.sharable {
		//	If some other connection is holding an exclusive lock, the requested lock may not be obtained.
		if btree.Writer != p && (btree.Flags & BTS_EXCLUSIVE) != 0 {
			p.db.ConnectionBlocked(btree.Writer.db)
			return SQLITE_LOCKED_SHAREDCACHE
		}

		for lock := btree.Lock; lock != nil; lock = lock.Next {
			//	The condition (pIter.eLock != eLock) in the following if(...) statement is a simplification of:
			//		(eLock == WRITE_LOCK || pIter.eLock == WRITE_LOCK)
			//	since we know that if eLock == WRITE_LOCK, then no other connection may hold a WRITE_LOCK on any table in this file (since there can only be a single writer).
			if lock.Btree != p && lock.Table == iTab && lock.Lock != eLock {
				p.db.ConnectionBlocked(lock.Btree.db)
				if eLock == WRITE_LOCK {
					btree.Flags |= BTS_PENDING
				}
				return SQLITE_LOCKED_SHAREDCACHE
			}
		}
	}
	return SQLITE_OK
}

//	Add a lock on the table with root-page iTable to the shared-btree used by Btree handle p. Parameter eLock must be either READ_LOCK or WRITE_LOCK.
//	This function assumes the following:
//		(a) The specified Btree object p is connected to a sharable database (one with the BtShared.sharable flag set), and
//		(b) No other Btree objects hold a lock that conflicts with the requested lock (i.e. querySharedCacheTableLock() has already been called and returned SQLITE_OK).
//	SQLITE_OK is returned if the lock is added successfully. SQLITE_NOMEM is returned if a malloc attempt fails.
func (p *Btree) setSharedCacheTableLock(iTable PageNumber, eLock byte) int {
	lock	*Lock

	btree := p.pBt
	//	First search the list for an existing lock on this table. */
	for iter := btree.Lock; iter != nil; iter = iter.Next {
		if iter.Table == iTable && iter.Btree == p {
			lock = iter
			break
		}
	}

	//	If the above search did not find a Lock struct associating Btree p with table iTable, allocate one and link it into the list.
	if lock == nil {
		lock = &Lock { Table: iTable, Btree: p, Next: btree.Lock }
		btree.Lock = lock
	}

	//	Set the Lock.Lock variable to the maximum of the current lock and the requested lock. This means if a write-lock was already held
	//	and a read-lock requested, we don't incorrectly downgrade the lock.
	if eLock > lock.Lock {
		lock.Lock = eLock
	}
	return SQLITE_OK
}

//	Release all the table locks (locks obtained via calls to the setSharedCacheTableLock() procedure) held by Btree object p.
//	This function assumes that Btree p has an open read or write transaction. If it does not, then the BTS_PENDING flag may be incorrectly cleared.
func (p *Btree) clearAllSharedCacheTableLocks() {
	btree := p.Btree
	iter := &btree.Lock

	for *iter != nil {
		if lock := *iter; lock.Btree == nil {
			*iter = lock.Next
			if lock.Table != 1 {
				lock = nil
			}
		} else {
			iter = &lock.Next
		}
	}

	switch {
	case btree.pWriter == p:
		btree.pWriter = 0
		btree.Flags &= ~(BTS_EXCLUSIVE | BTS_PENDING)
	case btree.nTransaction == 2:
		//	This function is called when Btree p is concluding its transaction. If there currently exists a writer, and p is not
		//	that writer, then the number of locks held by connections other than the writer must be about to drop to zero. In this case
		//	set the BTS_PENDING flag to 0.
		//	If there is not currently a writer, then BTS_PENDING must be zero already. So this next line is harmless in that case.
		btree.Flags &= ~BTS_PENDING
	}
}

//	This function changes all write-locks held by Btree p into read-locks.
func (p *Btree) downgradeAllSharedCacheTableLocks() {
	btree	*BtShared = p.pBt
	if btree.pWriter == p {
		btree.pWriter = 0
		btree.Flags &= ~(BTS_EXCLUSIVE|BTS_PENDING)
		for pLock := btree.pLock; pLock; pLock = pLock.Next {
			pLock.eLock = READ_LOCK
		}
	}
}

//	This function is called before modifying the contents of a table to invalidate any incrblob cursors that are open on the row or one of the rows being modified.
//	If argument isClearTable is true, then the entire contents of the table is about to be deleted. In this case invalidate all incrblob cursors open on any row within the table with root-page RootPage.
//	Otherwise, if argument isClearTable is false, then the row with rowid iRow is being replaced or deleted. In this case invalidate only those incrblob cursors open on that specific row.
func (p *Btree) InvalidateIncrblobCursors(row int64, clearTable bool) {
	for c := p.pBt.pCursor; c != nil; c = c.Next {
		if c.isIncrblobHandle && (clearTable || c.CellInfo.nKey == row) {
			c.eState = CURSOR_INVALID
		}
	}
}

//	Invalidate the overflow page-list cache for all cursors opened on the shared btree structure pBt.
static void invalidateAllOverflowCache(BtShared *pBt){
	for p := pBt.pCursor; p != nil; p = p.Next{
		p.OverflowCache = nil
	}
}

/*
** Set bit pgno of the BtShared.pHasContent BitVector. This is called
** when a page that previously contained data becomes a free-list leaf
** page.
**
** The BtShared.pHasContent BitVector exists to work around an obscure
** bug caused by the interaction of two useful IO optimizations surrounding
** free-list leaf pages:
**
**   1) When all data is deleted from a page and the page becomes
**      a free-list leaf page, the page is not written to the database
**      (as free-list leaf pages contain no meaningful data). Sometimes
**      such a page is not even journalled (as it will not be modified,
**      why bother journalling it?).
**
**   2) When a free-list leaf page is reused, its content is not read
**      from the database or written to the journal file (why should it
**      be, if it is not at all meaningful?).
**
** By themselves, these optimizations work fine and provide a handy
** performance boost to bulk delete or insert operations. However, if
** a page is moved to the free-list and then reused within the same
** transaction, a problem comes up. If the page is not journalled when
** it is moved to the free-list and it is also not journalled when it
** is extracted from the free-list and reused, then the original data
** may be lost. In the event of a rollback, it may not be possible
** to restore the database to its original configuration.
**
** The solution is the BtShared.pHasContent BitVector. Whenever a page is
** moved to become a free-list leaf page, the corresponding bit is
** set in the BitVector. Whenever a leaf page is extracted from the free-list,
** optimization 2 above is omitted if the corresponding bit is already
** set in BtShared.pHasContent. The contents of the BitVector are cleared
** at the end of every transaction.
*/
static int btreeSetHasContent(BtShared *pBt, PageNumber pgno){
  int rc = SQLITE_OK;
  if( !pBt.pHasContent ){
    assert( pgno<=pBt.nPage );
    pBt.pHasContent = bitvec.New(pBt.nPage)
    if( !pBt.pHasContent ){
      rc = SQLITE_NOMEM;
    }
  }
  if( rc==SQLITE_OK && pgno <= pBt.pHasContent.Len() ){
    rc = pBt.pHasContent.Set(pgno)
  }
  return rc;
}

/*
** Query the BtShared.pHasContent vector.
**
** This function is called when a free-list leaf page is removed from the
** free-list for reuse. It returns false if it is safe to retrieve the
** page from the pager layer with the 'no-content' flag set. True otherwise.
*/
static int btreeGetHasContent(BtShared *pBt, PageNumber pgno){
  Bitvec *p = pBt.pHasContent;
  return (p && (pgno > p.Len() || p.Test(pgno)))
}

//	Clear (destroy) the BtShared.pHasContent BitVector. This should be invoked at the conclusion of each write-transaction.
static void btreeClearHasContent(BtShared *pBt){
  pBt.pHasContent = nil
}

/*
** Save the current cursor position in the variables Cursor.nKey
** and Cursor.pKey. The cursor's state is set to CURSOR_REQUIRESEEK.
**
** The caller must ensure that the cursor is valid (has eState==CURSOR_VALID)
** prior to calling this routine.
*/
static int saveCursorPosition(Cursor *pCur){
  int rc;

  assert( CURSOR_VALID==pCur.eState );
  assert( 0==pCur.pKey );

  rc = sqlite3BtreeKeySize(pCur, &pCur.nKey);
  assert( rc==SQLITE_OK );  /* KeySize() cannot fail */

  /* If this is an intKey table, then the above call to BtreeKeySize()
  ** stores the integer key in pCur.nKey. In this case this value is
  ** all that is required. Otherwise, if pCur is not open on an intKey
  ** table, then malloc space for and store the pCur.nKey bytes of key
  ** data.
  */
  if( 0==pCur.Pages[0].intKey ){
    void *pKey = sqlite3Malloc( (int)pCur.nKey );
    if( pKey ){
      rc = sqlite3BtreeKey(pCur, 0, (int)pCur.nKey, pKey);
      if( rc==SQLITE_OK ){
        pCur.pKey = pKey;
      }else{
        pKey = nil
      }
    }else{
      rc = SQLITE_NOMEM;
    }
  }
  assert( !pCur.Pages[0].intKey || !pCur.pKey );

  if( rc==SQLITE_OK ){
    int i;
    for(i=0; i<=pCur.iPage; i++){
      pCur.Pages[i].Release()
      pCur.Pages[i] = nil
    }
    pCur.iPage = -1;
    pCur.eState = CURSOR_REQUIRESEEK;
  }

  pCur.OverflowCache = nil
  return rc;
}

/*
** Save the positions of all cursors (except pExcept) that are open on
** the table  with root-page iRoot. Usually, this is called just before cursor
** pExcept is used to modify the table (BtreeDelete() or BtreeInsert()).
*/
static int saveAllCursors(BtShared *pBt, PageNumber iRoot, Cursor *pExcept){
  Cursor *p;
  assert( pExcept==0 || pExcept.pBt==pBt );
  for(p=pBt.pCursor; p; p=p.Next){
    if( p!=pExcept && (0==iRoot || p.RootPage==iRoot) &&
        p.eState==CURSOR_VALID ){
      int rc = saveCursorPosition(p);
      if( SQLITE_OK!=rc ){
        return rc;
      }
    }
  }
  return SQLITE_OK;
}

/*
** Clear the current cursor position.
*/
 void sqlite3BtreeClearCursor(Cursor *pCur){
  pCur.pKey = nil
  pCur.eState = CURSOR_INVALID;
}

/*
** In this version of BtreeMoveto, pKey is a packed index record
** such as is generated by the OP_MakeRecord opcode.  Unpack the
** record and then call BtreeMovetoUnpacked() to do the work.
*/
static int btreeMoveto(
  Cursor *pCur,     /* Cursor open on the btree to be searched */
  const void *pKey,   /* Packed key if the btree is an index */
  int64 nKey,           /* Integer key for tables.  Size of pKey for indices */
  int bias,           /* Bias search to the high end */
  int *pRes           /* Write search results here */
){
  int rc;                    /* Status code */
  UnpackedRecord *pIdxKey;   /* Unpacked index key */
  char aSpace[150];          /* Temp space for pIdxKey - to avoid a malloc */
  char *pFree = 0;

  if( pKey ){
    assert( nKey==(int64)(int)nKey );
    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pCur.pKeyInfo, aSpace, sizeof(aSpace), &pFree);
    if( pIdxKey==0 ) return SQLITE_NOMEM;
    sqlite3VdbeRecordUnpack(pCur.pKeyInfo, (int)nKey, pKey, pIdxKey);
  }else{
    pIdxKey = 0;
  }
  pRes, rc = pCur.BtreeMovetoUnpacked(pIdxKey, nKey, bias)
  if( pFree ){
    pFree = nil
  }
  return rc;
}

/*
** Restore the cursor to the position it was in (or as close to as possible)
** when saveCursorPosition() was called. Note that this call deletes the
** saved position info stored by saveCursorPosition(), so there can be
** at most one effective restoreCursorPosition() call after each
** saveCursorPosition().
*/
static int btreeRestoreCursorPosition(Cursor *pCur){
  int rc;
  assert( pCur.eState>=CURSOR_REQUIRESEEK );
  if( pCur.eState==CURSOR_FAULT ){
    return pCur.skiNext;
  }
  pCur.eState = CURSOR_INVALID;
  rc = btreeMoveto(pCur, pCur.pKey, pCur.nKey, 0, &pCur.skiNext);
  if( rc==SQLITE_OK ){
    pCur.pKey = nil
    assert( pCur.eState==CURSOR_VALID || pCur.eState==CURSOR_INVALID );
  }
  return rc;
}

#define restoreCursorPosition(p) \
  (p.eState>=CURSOR_REQUIRESEEK ? \
         btreeRestoreCursorPosition(p) : \
         SQLITE_OK)

/*
** Determine whether or not a cursor has moved from the position it
** was last placed at.  Cursors can move when the row they are pointing
** at is deleted out from under them.
**
** This routine returns an error code if something goes wrong.  The
** integer *pHasMoved is set to one if the cursor has moved and 0 if not.
*/
 int sqlite3BtreeCursorHasMoved(Cursor *pCur, int *pHasMoved){
  int rc;

  rc = restoreCursorPosition(pCur);
  if( rc ){
    *pHasMoved = 1;
    return rc;
  }
  if( pCur.eState!=CURSOR_VALID || pCur.skiNext!=0 ){
    *pHasMoved = 1;
  }else{
    *pHasMoved = 0;
  }
  return SQLITE_OK;
}

//	Given a page number of a regular database page, return the page number for the pointer-map page that contains the entry for the input page number.
//	Return 0 (not a valid page) for pgno == 1 since there is no pointer map associated with page 1. The integrity_check logic requires that Pageno(1) != 1.
func (pBt *BtShared) Pageno(pgno PageNumber) (n PageNumber) {
	if pgno < 2 {
		return 0
	}
	PagesPerMapPage := (pBt.usableSize / 5) + 1
	PtrMap := (pgno - 2) / PagesPerMapPage
	if n = (PtrMap * PagesPerMapPage) + 2; n == PAGER_MJ_PGNO(pBt) {
		n++
	}
	return
}

//	Write an entry into the pointer map.
//	This routine updates the pointer map entry for page number 'key' so that it maps to type 'eType' and parent page number 'pgno'.
//	If *pRC is initially non-zero (non-SQLITE_OK) then this routine is a no-op. If an error occurs, the appropriate error code is written into *pRC.
func (pBt *BtShared) Put(key PageNumber, eType byte, parent PageNumber) (rc int) {
	byte *pPtrmap;      /* The pointer map data */
	int offset;       /* Offset in pointer map page */

	//	The master-journal page number must never be used as a pointer map page
	assert( !pBt.IsMapPage(PAGER_MJ_PGNO(pBt)) )

	assert( pBt.autoVacuum )
	if key == 0 {
		return SQLITE_CORRUPT_BKPT
	}
	pageno := pBt.Pageno(key)

	var page	*DbPage
	if page, rc = pBt.pPager.Acquire(pageno, false); rc == SQLITE_OK {
		offset := ptrmap_ptroffset(pageno, key)
		if offset < 0 {
			return SQLITE_CORRUPT_BKPT
		}
		assert( offset <= int(pBt.usableSize) - 5 )
		map := page.GetData()

		if eType != map[offset] || Buffer(map[offset + 1:]).ReadUint32() != parent {
			if rc = sqlite3PagerWrite(page); rc == SQLITE_OK {
				map[offset] = eType
				Buffer(map[offset + 1:]).WriteUint32(parent)
			}
		}
	}
	sqlite3PagerUnref(page)
}

//	Read an entry from the pointer map.
//	This routine retrieves the pointer map entry for page 'key', writing the type and parent page number to *pEType and *pPageNumber respectively. An error code is returned if something goes wrong, otherwise SQLITE_OK.
func (pBt *BtShared) Get(key PageNumber) (eType byte, pgno PageNumber, rc int) {
	var page	*DbPage
	index := pBt.Pageno(key)
	if page, rc = pBt.pPager.Acquire(index, false); rc == SQLITE_OK {
		data = page.GetData()

		offset := ptrmap_ptroffset(index, key)
		if offset < 0 {
			sqlite3PagerUnref(page)
			return SQLITE_CORRUPT_BKPT
		}
		assert( offset <= int(pBt.usableSize - 5) )
		eType = data[offset]
		pgno = Buffer(data[offset + 1:]).ReadUint32()

		sqlite3PagerUnref(page)
		if eType < 1 || eType > 5 {
			rc = SQLITE_CORRUPT_BKPT
		}
	}
	return
}


//	Compute the total number of bytes that a Cell needs in the cell data area of the btree-page. The return number includes the cell
//	data header and the local payload, but not any overflow page or the space used by the cell pointer.
func (pPage *MemoryPage) cellSize(pCell Buffer) uint16 {
	var nSize	uint32

	buffer := Buffer(pCell[pPage.childPtrSize:])
	if pPage.intKey {
		if pPage.hasData {
			nSize, buffer = buffer.ReadVarint32()
		} else {
			nSize = 0
		}

		//	pIter now points at the 64-bit integer key value, a variable length integer. The following block moves pIter to point at the first byte past the end of the key value.
		for i, v := range buffer {
			if !(v & 0x80 != 0 && i < 9) {
				break
			}
		}

	} else {
		nSize, buffer = buffer.ReadVarint32()
	}

	if nSize > pPage.maxLocal {
		minLocal := pPage.minLocal
		if nSize = minLocal + (nSize - minLocal) % (pPage.pBt.usableSize - 4); nSize > pPage.maxLocal {
			nSize = minLocal
		}
		nSize += 4
	}
	if nSize += len(pCell) - len(buffer); nSize < 4 {
		//	The minimum size of any cell is 4 bytes.
		nSize = 4
	}
	assert( nSize == debuginfo.nSize )
	return uint16(nSize)
}

//	If the cell pCell, part of page pPage contains a pointer to an overflow page, insert an entry into the pointer-map for the overflow page.
func (p *MemoryPage) PutOvflPtr(cell []byte) (rc int) {
	assert( cell != nil )

	var info	CellInfo
	info.ParsePtr(p, cell)
	if p.intKey {
		assert( info.nData == info.nPayload )
	} else {
		assert( info.nData + info.nKey == info.nPayload )
	}
	if info.iOverflow != 0 {
		ovfl = PageNumber(Buffer(cell[info.iOverflow:]).ReadUint32())
		rc = p.pBt.Put(ovfl, FIRST_OVERFLOW_PAGE, p.pgno)
	}
	return
}

//	Allocate nByte bytes of space from within the B-Tree page passed as the first argument. Write into *pIdx the index into pPage.aData[] of the first byte of allocated space. Return either SQLITE_OK or an error code (usually SQLITE_CORRUPT).
//	The caller guarantees that there is sufficient space to make the allocation. This routine might need to defragment in order to bring all the space together, however. This routine will avoid using the first two bytes past the cell pointer area since presumably this allocation is being made in order to insert a new cell, so we will also end up needing a new cell pointer.
func (pPage *MemoryPage) AllocateSpace(nByte int) (index, rc int) {
	hdr := pPage.hdrOffset					//	Local cache of pPage.hdrOffset
	data := Buffer(pPage.aData)

	assert( pPage.pBt )
	assert( nByte >= 0 )					//	Minimum cell size is 4
	assert( pPage.nFree >= nByte )
	assert( pPage.nOverflow == 0 )
	usableSize := pPage.pBt.usableSize
	assert( nByte < usableSize - 8 )

	fragmented_bytes := data[hdr + 7]
	assert( pPage.cellOffset == hdr + 12 - 4 * pPage.leaf )
	gap := pPage.cellOffset + 2 * pPage.nCell						//	First byte of gap between cell pointers and cell content
	if index = data[hdr + 5].ReadCompressedIntNotZero(); gap > index {
		return SQLITE_CORRUPT_BKPT
	}
	if fragmented_bytes >= 60 {
		//	Always defragment highly fragmented pages
		if rc = pPage.Defragment(); rc != SQLITE_OK {
			return
		}
		index = data[hdr + 5].ReadCompressedIntNotZero()
	} else if gap + 2 <= index {
		//	Search the freelist looking for a free slot big enough to satisfy the request. The allocation is made from the first free slot in the list that is large enough to accomadate it.
		addr := hdr + 1
		for pc = data[addr].ReadUint16(); pc > 0; pc = data[addr].ReadUint16() {
			if pc > usableSize - 4 || pc < addr + 4 {
				return SQLITE_CORRUPT_BKPT
			}
			if slot_size := data[pc + 2].ReadUint16(); slot_size >= nByte {
				x := size - nByte
				switch {
				case x < 4:
					//	Remove the slot from the free-list. Update the number of fragmented bytes within the page.
					copy(&data[addr:], &data[pc:], 2)
					data[hdr + 7] = byte(fragmented_bytes + x)
				case slot_size + pc > usableSize:
					return SQLITE_CORRUPT_BKPT
				default:
					//	The slot remains on the free-list. Reduce its size to account for the portion used by the new allocation.
					data[pc + 2:].WriteUint16(x)
				}
				index = pc + x
				return
			}
			addr = pc
		}
	}

	//	Check to make sure there is enough space in the gap to satisfy the allocation. If not, defragment.
	if gap + 2 + nByte > index {
		if rc = pPage.Defragment(); rc != SQLITE_OK {
			return rc
		}
		index = data[hdr + 5].ReadCompressedIntNotZero()
		assert( gap + nByte <= index )
	}


	// Allocate memory from the gap in between the cell pointer array and the cell content area. The Initialize() call has already validated the freelist. Given that the freelist is valid, there is no way that the allocation can extend off the end of the page. The assert() below verifies the previous sentence.
	index -= nByte
	data[hdr + 5:].WriteUint16(top)
	assert( index + nByte <= int(pPage.pBt.usableSize) )
	return
}

//	Return a section of the pPage.aData to the freelist. The first byte of the new free block is pPage.aDisk[start] and the size of the block is "size" bytes.
//	Most of the effort here is involved in coalesing adjacent free blocks into a single big free block.
static int freeSpace(MemoryPage *pPage, int start, int size){
	int addr, pbegin, hdr;
	int iLast;                        /* Largest possible freeblock offset */
	data := Buffer(pPage.aData)

	assert( pPage.pBt!=0 );
	assert( start>=pPage.hdrOffset+6+pPage.childPtrSize );
	assert( (start + size) <= (int)pPage.pBt.usableSize );
	assert( size>=0 );   /* Minimum cell size is 4 */

	if( pPage.pBt.Flags & BTS_SECURE_DELETE ){
		//	Overwrite deleted information with zeros when the secure_delete option is enabled
		memset(&data[start], 0, size);
	}

	//	Add the space back into the linked list of freeblocks. Note that even though the freeblock list was checked by Initialize(), Initialize() did not detect overlapping cells or freeblocks that overlapped cells. Nor does it detect when the cell content area exceeds the value in the page header. If these situations arise, then subsequent insert operations might corrupt the freelist. So we do need to check for corruption while scanning the freelist.
	hdr = pPage.hdrOffset;
	addr = hdr + 1;
	iLast = pPage.pBt.usableSize - 4;
	assert( start<=iLast );
	while( (pbegin = data[addr].ReadUint16())<start && pbegin>0 ){
		if( pbegin<addr+4 ){
			return SQLITE_CORRUPT_BKPT;
		}
		addr = pbegin;
	}
	if( pbegin>iLast ){
		return SQLITE_CORRUPT_BKPT;
	}
	assert( pbegin>addr || pbegin==0 );
	data[addr:].WriteUint16(start)
	data[start:].WriteUint16(pbegin)
	data[start + 2:].WriteUint16(size)
	pPage.nFree = pPage.nFree + (uint16)size;

	//	Coalesce adjacent free blocks
	addr = hdr + 1
	while( (pbegin = data[addr].ReadUint16())>0 ){
		int pnext, psize, x;
		assert( pbegin>addr );
		assert( pbegin <= (int)pPage.pBt.usableSize-4 );
		pnext = data[pbegin].ReadUint16()
		psize = data[pbegin + 2].ReadUint16()
		if( pbegin + psize + 3 >= pnext && pnext>0 ){
			int frag = pnext - (pbegin+psize);
			if( (frag<0) || (frag>(int)data[hdr+7]) ){
				return SQLITE_CORRUPT_BKPT;
			}
			data[hdr + 7] -= byte(frag)
			data[pbegin:].WriteUint16(data[pnext].ReadUint16())
			data[pbegin + 2:].WriteUint16(pnext + data[pnext + 2].ReadUint16() - pbegin)
		}else{
			addr = pbegin;
		}
	}

	//	If the cell content area begins with a freeblock, remove it.
	if( data[hdr+1]==data[hdr+5] && data[hdr+2]==data[hdr+6] ){
		pbegin = data[hdr + 1].ReadUint16()
		memcpy(data[hdr + 1:], data[pbegin:], 2)
		data[hdr + 5:].IncrementUint16(data[pbegin + 2].ReadUint16())
	}
	return SQLITE_OK
}

/*
** Decode the flags byte (the first byte of the header) for a page
** and initialize fields of the MemoryPage structure accordingly.
**
** Only the following combinations are supported.  Anything different
** indicates a corrupt database files:
**
**         PTF_ZERODATA
**         PTF_ZERODATA | PTF_LEAF
**         PTF_LEAFDATA | PTF_INTKEY
**         PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF
*/
static int decodeFlags(MemoryPage *pPage, int flagByte){
  BtShared *pBt;     /* A copy of pPage.pBt */

  assert( pPage.hdrOffset==(pPage.pgno==1 ? 100 : 0) );
  pPage.leaf = (byte)(flagByte>>3);  assert( PTF_LEAF == 1<<3 );
  flagByte &= ~PTF_LEAF;
  pPage.childPtrSize = 4-4*pPage.leaf;
  pBt = pPage.pBt;
  if( flagByte==(PTF_LEAFDATA | PTF_INTKEY) ){
    pPage.intKey = 1;
    pPage.hasData = pPage.leaf;
    pPage.maxLocal = pBt.maxLeaf;
    pPage.minLocal = pBt.minLeaf;
  }else if( flagByte==PTF_ZERODATA ){
    pPage.intKey = 0;
    pPage.hasData = 0;
    pPage.maxLocal = pBt.maxLocal;
    pPage.minLocal = pBt.minLocal;
  }else{
    return SQLITE_CORRUPT_BKPT;
  }
  pPage.max1bytePayload = pBt.max1bytePayload;
  return SQLITE_OK;
}

//	Set up a raw page so that it looks like a database page holding no entries.
static void zeroPage(MemoryPage *pPage, int flags){
	data := Buffer(pPage.aData)
	pBt := pPage.pBt
	hdr := pPage.hdrOffset

	var first	uint16

	assert( pPage.pDbPage.GetExtra() == ([]byte)(pPage) )
	assert( pPage.pDbPage.GetData() == data )
	if pBt.Flags & BTS_SECURE_DELETE {
		memset(&data[hdr], 0, pBt.usableSize - hdr)
	}
	data[hdr] = byte(flags)
	first = hdr + 8 + 4*((flags&PTF_LEAF)==0 ?1:0)
	memset(&data[hdr+1], 0, 4)
	data[hdr+7] = 0
	data[hdr + 5:].WriteUint16(pBt.usableSize)
	pPage.nFree = (uint16)(pBt.usableSize - first)
	decodeFlags(pPage, flags)
	pPage.hdrOffset = hdr
	pPage.cellOffset = first
	pPage.aDataEnd = &data[pBt.usableSize]
	pPage.CellIndices = &data[first]
	pPage.nOverflow = 0
	assert( pBt.pageSize >= 512 && pBt.pageSize <= 65536 )
	pPage.maskPage = uint16(pBt.pageSize - 1)
	pPage.nCell = 0
	pPage.isInit = true
}


//	Convert a DbPage obtained from the pager into a MemoryPage used by the btree layer.
func (pDbPage *DbPage) BtreePage(pgno PageNumber, pBt *BtShared) (pPage *MemoryPage) {
	pPage = (MemoryPage*)(pDbPage.GetExtra())
	pPage.aData = pDbPage.GetData()
	pPage.pDbPage = pDbPage
	pPage.pBt = pBt
	pPage.pgno = pgno
	if pPage.pgno == 1 {
		pPage.hdrOffset = 100
	} else {
		pPage.hdrOffset = 0
	}
	return
}

/*
** Retrieve a page from the pager cache. If the requested page is not
** already in the pager cache return NULL. Initialize the MemoryPage.pBt and
** MemoryPage.aData elements if needed.
*/
static MemoryPage *btreePageLookup(BtShared *pBt, PageNumber pgno){
  DbPage *pDbPage;
  pDbPage = sqlite3PagerLookup(pBt.pPager, pgno);
  if( pDbPage ){
    return pDbPage.BtreePage(pgno, pBt)
  }
  return 0;
}

/*
** Return the size of the database file in pages. If there is any kind of
** error, return ((uint)-1).
*/
static PageNumber btreePagecount(BtShared *pBt){
  return pBt.nPage;
}
 uint32 sqlite3BtreeLastPage(Btree *p){
  assert( ((p.pBt.nPage)&0x8000000)==0 );
  return (int)btreePagecount(p.pBt);
}

//	During a rollback, when the pager reloads information into the cache so that the cache is restored to its original state at the start of the transaction, for each page restored this routine is called.
//	This routine needs to reset the extra data section at the end of the page to agree with the restored data.
static void pageReinit(DbPage *pData){
	var pPage	*MemoryPage
	pPage = (MemoryPage *)(pData.GetExtra())
	assert( sqlite3PagerPageRefcount(pData) > 0 )
	if pPage.isInit {
		pPage.isInit = false
		if sqlite3PagerPageRefcount(pData) > 1 {
			//	pPage might not be a btree page; it might be an overflow page or ptrmap page or a free page. In those cases, the following call to Initialize() will likely return SQLITE_CORRUPT. But no harm is done by this. And it is very important that Initialize be called on every btree page so we make the call for every page that comes in for re-initing.
			pPage.Initialize()
		}
	}
}

/*
** Invoke the busy handler for a btree.
*/
static int btreeInvokeBusyHandler(void *pArg){
  BtShared *pBt = (BtShared*)pArg;
  assert( pBt.db );
  return sqlite3InvokeBusyHandler(&pBt.db.busyHandler);
}

/*
** Open a database file.
**
** zFilename is the name of the database file.  If zFilename is NULL
** then an ephemeral database is created.  The ephemeral database might
** be exclusively in memory, or it might use a disk-based memory cache.
** Either way, the ephemeral database will be automatically deleted
** when sqlite3BtreeClose() is called.
**
** If zFilename is ":memory:" then an in-memory database is created
** that is automatically destroyed when it is closed.
**
** The "flags" parameter is a bitmask that might contain bits like
** BTREE_OMIT_JOURNAL and/or BTREE_MEMORY.
**
** If the database is already opened in the same database connection
** and we are in shared cache mode, then the open will fail with an
** SQLITE_CONSTRAINT error.  We cannot allow two or more BtShared
** objects in the same database connection since doing so will lead
** to problems with locking.
*/
 int sqlite3BtreeOpen(
  sqlite3_vfs *pVfs,      /* VFS to use for this b-tree */
  const char *zFilename,  /* Name of the file containing the BTree database */
  sqlite3 *db,            /* Associated database handle */
  Btree **ppBtree,        /* Pointer to new Btree object written here */
  int flags,              /* Options */
  int vfsFlags            /* Flags passed through to sqlite3_vfs.xOpen() */
){
  BtShared *pBt = 0;             /* Shared part of btree structure */
  Btree *p;                      /* Handle to return */
  sqlite3_mutex *mutexOpen = 0;  /* Prevents a race condition. Ticket #3537 */
  int rc = SQLITE_OK;            /* Result code from this function */
  byte nReserve;                   /* Byte of unused space on each page */
  unsigned char zDbHeader[100];  /* Database header content */

  /* True if opening an ephemeral, temporary database */
  const int isTempDb = zFilename==0 || zFilename[0]==0;

  /* Set the variable isMemdb to true for an in-memory database, or
  ** false for a file-based database.
  */
#ifdef SQLITE_OMIT_MEMORYDB
  const int isMemdb = 0;
#else
  const int isMemdb = (zFilename && strcmp(zFilename, ":memory:")==0)
                       || (isTempDb && sqlite3TempInMemory(db));
#endif

  assert( db!=0 );
  assert( pVfs!=0 );
  assert( (flags&0xff)==flags );   /* flags fit in 8 bits */

  /* Only a BTREE_SINGLE database can be BTREE_UNORDERED */
  assert( (flags & BTREE_UNORDERED)==0 || (flags & BTREE_SINGLE)!=0 );

  /* A BTREE_SINGLE database is always a temporary and/or ephemeral */
  assert( (flags & BTREE_SINGLE)==0 || isTempDb );

  if( isMemdb ){
    flags |= BTREE_MEMORY;
  }
  if( (vfsFlags & SQLITE_OPEN_MAIN_DB)!=0 && (isMemdb || isTempDb) ){
    vfsFlags = (vfsFlags & ~SQLITE_OPEN_MAIN_DB) | SQLITE_OPEN_TEMP_DB;
  }
  p = sqlite3MallocZero(sizeof(Btree));
  if( !p ){
    return SQLITE_NOMEM;
  }
  p.inTrans = TRANS_NONE;
  p.db = db;
  p.lock.pBtree = p;
  p.lock.iTable = 1;

  /*
  ** If this Btree is a candidate for shared cache, try to find an
  ** existing BtShared object that we can share with
  */
  if( isMemdb==0 && isTempDb==0 ){
    if( vfsFlags & SQLITE_OPEN_SHAREDCACHE ){
      int nFullPathname = pVfs.mxPathname+1;
      char *zFullPathname = sqlite3Malloc(nFullPathname);
      sqlite3_mutex *mutexShared
      p.sharable = 1;
      if( !zFullPathname ){
        p = nil
        return SQLITE_NOMEM;
      }
      rc = sqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname);
      if( rc ){
        zFullPathname = nil
        p = nil
        return rc;
      }
      mutexOpen = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_OPEN)
      mutexOpen.Lock()
      mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)
      mutexShared.Lock()
      for(pBt=sqlite3SharedCacheList; pBt; pBt=pBt.Next){
        assert( pBt.nRef>0 );
        if( 0==strcmp(zFullPathname, sqlite3PagerFilename(pBt.pPager)) && sqlite3PagerVfs(pBt.pPager)==pVfs ){
          for iDb := len(db.Databases) - 1; iDb > -1; iDb-- {
            pExisting := db.Databases[iDb].pBt;
            if( pExisting && pExisting.pBt==pBt ){
              mutexShared.Unlock()
              mutexOpen.Unlock()
              zFullPathname = nil
              p = nil
              return SQLITE_CONSTRAINT;
            }
          }
          p.pBt = pBt;
          pBt.PageSize;
          break;
        }
      }
      mutexShared.Unlock()
      zFullPathname = nil
    }
  }
  if( pBt==0 ){
    /*
    ** The following asserts make sure that structures used by the btree are
    ** the right size.  This is to guard against size changes that result
    ** when compiling on a different architecture.
    */
    assert( sizeof(int64)==8 || sizeof(int64)==4 );
    assert( sizeof(uint64)==8 || sizeof(uint64)==4 );
    assert( sizeof(uint32)==4 );
    assert( sizeof(uint16)==2 );
    assert( sizeof(PageNumber)==4 );

    pBt = sqlite3MallocZero( sizeof(*pBt) );
    if( pBt==0 ){
      rc = SQLITE_NOMEM;
      goto btree_open_out;
    }
    rc = sqlite3PagerOpen(pVfs, &pBt.pPager, zFilename,
                          sizeof(MemoryPage), flags, vfsFlags, pageReinit);
    if( rc==SQLITE_OK ){
      rc = sqlite3PagerReadFileheader(pBt.pPager,sizeof(zDbHeader),zDbHeader);
    }
    if( rc!=SQLITE_OK ){
      goto btree_open_out;
    }
    pBt.openFlags = (byte)flags;
    pBt.db = db;
    sqlite3PagerSetBusyhandler(pBt.pPager, btreeInvokeBusyHandler, pBt);
    p.pBt = pBt;

    pBt.pCursor = 0;
    pBt.pPage1 = 0;
    if( sqlite3PagerIsreadonly(pBt.pPager) ) pBt.Flags |= BTS_READ_ONLY;
#ifdef SQLITE_SECURE_DELETE
    pBt.Flags |= BTS_SECURE_DELETE;
#endif
    pBt.pageSize = (zDbHeader[16]<<8) | (zDbHeader[17]<<16);
    if( pBt.pageSize<512 || pBt.pageSize>SQLITE_MAX_PAGE_SIZE
         || ((pBt.pageSize-1)&pBt.pageSize)!=0 ){
      pBt.pageSize = 0;
      /* If the magic name ":memory:" will create an in-memory database, then
      ** leave the autoVacuum mode at 0 (do not auto-vacuum), even if
      ** SQLITE_DEFAULT_AUTOVACUUM is true. On the other hand, if
      ** SQLITE_OMIT_MEMORYDB has been defined, then ":memory:" is just a
      ** regular file-name. In this case the auto-vacuum applies as per normal.
      */
      if( zFilename && !isMemdb ){
        pBt.autoVacuum = (SQLITE_DEFAULT_AUTOVACUUM ? 1 : 0);
        pBt.incrVacuum = (SQLITE_DEFAULT_AUTOVACUUM==2 ? 1 : 0);
      }
      nReserve = 0;
    }else{
      nReserve = zDbHeader[20];
      pBt.Flags |= BTS_PAGESIZE_FIXED;
      if Buffer(zDbHeader[36 + (4 * 4):]).ReadUint32() != 0 {
		  pBt.autoVacuum = true
	  } else {
		  pBt.autoVacuum = false
	  }
      if Buffer(zDbHeader[36 + (7 * 4):]).ReadUint32() != 0 {
		  pBt.incrVacuum = true
	  } else {
		  pBt.incrVacuum = false
	  }
    }
    rc = sqlite3PagerSetPagesize(pBt.pPager, &pBt.pageSize, nReserve);
    if( rc ) goto btree_open_out;
    pBt.usableSize = pBt.pageSize - nReserve;
    assert( (pBt.pageSize & 7)==0 );  /* 8-byte alignment of pageSize */

    /* Add the new BtShared object to the linked list sharable BtShareds.
    */
    if( p.sharable ){
      sqlite3_mutex *mutexShared
      pBt.nRef = 1;
      mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)
      if sqlite3GlobalConfig.bCoreMutex {
        pBt.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_FAST);
        if( pBt.mutex==0 ){
          rc = SQLITE_NOMEM;
          db.mallocFailed = false
          goto btree_open_out;
        }
      }
      mutexShared.Lock()
      pBt.Next = sqlite3SharedCacheList
      sqlite3SharedCacheList = pBt;
      mutexShared.Unlock()
    }
  }

  /* If the new Btree uses a sharable pBtShared, then link the new
  ** Btree into the list of all sharable Btrees for the same connection.
  ** The list is kept in ascending order by pBt address.
  */
  if( p.sharable ){
    Btree *pSib;
	for _, database := range db.Databases {
      if pSib := database.pBt; pSib != nil && pSib.sharable {
        while( pSib.pPrev ){ pSib = pSib.pPrev; }
        if( p.pBt<pSib.pBt ){
          p.Next = pSib;
          p.pPrev = 0;
          pSib.pPrev = p;
        }else{
          while( pSib.Next && pSib.Next.pBt<p.pBt ){
            pSib = pSib.Next;
          }
          p.Next = pSib.Next;
          p.pPrev = pSib;
          if( p.Next ){
            p.Next.pPrev = p;
          }
          pSib.Next = p;
        }
        break;
      }
    }
  }
  *ppBtree = p;

btree_open_out:
  if( rc!=SQLITE_OK ){
    if( pBt && pBt.pPager ){
      sqlite3PagerClose(pBt.pPager);
    }
    pBt = nil
    p = nil
    *ppBtree = 0;
  }else{
    //	If the B-Tree was successfully opened, set the pager-cache size to the default value. Except, when opening on an existing shared pager-cache, do not change the pager-cache size.
    if p.Schema(false, nil) == nil {
      sqlite3PagerSetCachesize(p.pBt.pPager, SQLITE_DEFAULT_CACHE_SIZE)
    }
  }
  if( mutexOpen ){
    mutexOpen.Unlock()
  }
  return rc;
}

/*
** Decrement the BtShared.nRef counter.  When it reaches zero,
** remove the BtShared structure from the sharing list.  Return
** true if the BtShared.nRef counter reaches zero and return
** false if it is still positive.
*/
static int removeFromSharingList(BtShared *pBt){
  sqlite3_mutex *pMaster
  BtShared *pList;
  int removed = 0;

  pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)
  pMaster.Lock()
  pBt.nRef--;
  if( pBt.nRef<=0 ){
    if( sqlite3SharedCacheList==pBt ){
      sqlite3SharedCacheList = pBt.Next;
    }else{
      pList = sqlite3SharedCacheList
      while( pList && pList.Next!=pBt ){
        pList=pList.Next;
      }
      if pList {
        pList.Next = pBt.Next;
      }
    }
    pBt.mutex.Free()
    removed = 1;
  }
  pMaster.Unlock()
  return removed;
}

/*
** Make sure pBt.pTmpSpace points to an allocation of
** MX_CELL_SIZE(pBt) bytes.
*/
static void allocateTempSpace(BtShared *pBt){
  if( !pBt.pTmpSpace ){
    pBt.pTmpSpace = sqlite3PageMalloc( pBt.pageSize );
  }
}

/*
** Free the pBt.pTmpSpace allocation
*/
static void freeTempSpace(BtShared *pBt){
  sqlite3PageFree( pBt.pTmpSpace);
  pBt.pTmpSpace = 0;
}

/*
** Close an open database and invalidate all cursors.
*/
 int sqlite3BtreeClose(Btree *p){
  BtShared *pBt = p.pBt;
  Cursor *pCur;

  /* Close all cursors opened via this handle.  */
  p.Lock()
  pCur = pBt.pCursor;
  while( pCur ){
    Cursor *pTmp = pCur;
    pCur = pCur.Next;
    if( pTmp.pBtree==p ){
      sqlite3BtreeCloseCursor(pTmp);
    }
  }

  //	Rollback any active transaction and free the handle structure.
  //	The call to Btree::Rollback() drops any table-locks held by this handle.
  p.Rollback(SQLITE_OK)
  p.Unlock()

  /* If there are still other outstanding references to the shared-btree
  ** structure, return now. The remainder of this procedure cleans
  ** up the shared-btree.
  */
  assert( p.wantToLock==0 && p.locked==0 );
  if( !p.sharable || removeFromSharingList(pBt) ){
    /* The pBt is no longer on the sharing list, so we can access
    ** it without having to hold the mutex.
    **
    ** Clean out and delete the BtShared object.
    */
    assert( !pBt.pCursor );
    sqlite3PagerClose(pBt.pPager);
    if( pBt.xFreeSchema && pBt.Schema != nil ){
      pBt.xFreeSchema(pBt.Schema);
    }
    pBt.Schema = nil
    freeTempSpace(pBt);
    pBt = nil
  }

  assert( p.wantToLock==0 );
  assert( p.locked==0 );
  if( p.pPrev ) p.pPrev.Next = p.Next;
  if( p.Next ) p.Next.pPrev = p.pPrev;

  p = nil
  return SQLITE_OK;
}

/*
** Change the limit on the number of pages allowed in the cache.
**
** The maximum number of cache pages is set to the absolute
** value of mxPage.  If mxPage is negative, the pager will
** operate asynchronously - it will not stop to do fsync()s
** to insure data is written to the disk surface before
** continuing.  Transactions still work if synchronous is off,
** and the database cannot be corrupted if this program
** crashes.  But if the operating system crashes or there is
** an abrupt power failure when synchronous is off, the database
** could be left in an inconsistent and unrecoverable state.
** Synchronous is on by default so database corruption is not
** normally a worry.
*/
 int sqlite3BtreeSetCacheSize(Btree *p, int mxPage){
  BtShared *pBt = p.pBt;
  p.Lock()
  sqlite3PagerSetCachesize(pBt.pPager, mxPage);
  p.Unlock()
  return SQLITE_OK;
}

/*
** Change the way data is synced to disk in order to increase or decrease
** how well the database resists damage due to OS crashes and power
** failures.  Level 1 is the same as asynchronous (no syncs() occur and
** there is a high probability of damage)  Level 2 is the default.  There
** is a very low but non-zero probability of damage.  Level 3 reduces the
** probability of damage to near zero but with a write performance reduction.
*/
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
 int sqlite3BtreeSetSafetyLevel(
  Btree *p,              /* The btree to set the safety level on */
  int level,             /* PRAGMA synchronous.  1=OFF, 2=NORMAL, 3=FULL */
  int fullSync,          /* PRAGMA fullfsync. */
  int ckptFullSync       /* PRAGMA checkpoint_fullfync */
){
  BtShared *pBt = p.pBt;
  assert( level>=1 && level<=3 );
  p.Lock()
  sqlite3PagerSetSafetyLevel(pBt.pPager, level, fullSync, ckptFullSync);
  p.Unlock()
  return SQLITE_OK;
}
#endif

/*
** Return TRUE if the given btree is set to safety level 1.  In other
** words, return TRUE if no sync() occurs on the disk files.
*/
 int sqlite3BtreeSyncDisabled(Btree *p){
  BtShared *pBt = p.pBt;
  int rc;
  p.Lock()
  assert( pBt && pBt.pPager );
  rc = sqlite3PagerNosync(pBt.pPager);
  p.Unlock()
  return rc;
}

/*
** Change the default pages size and the number of reserved bytes per page.
** Or, if the page size has already been fixed, return SQLITE_READONLY
** without changing anything.
**
** The page size must be a power of 2 between 512 and 65536.  If the page
** size supplied does not meet this constraint then the page size is not
** changed.
**
** Page sizes are constrained to be a power of two so that the region
** of the database file used for locking (beginning at PENDING_BYTE,
** the first byte past the 1GB boundary, 0x40000000) needs to occur
** at the beginning of a page.
**
** If parameter nReserve is less than zero, then the number of reserved
** bytes per page is left unchanged.
**
** If the iFix!=0 then the BTS_PAGESIZE_FIXED flag is set so that the page size
** and autovacuum mode can no longer be changed.
*/
 int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve, int iFix){
  int rc = SQLITE_OK;
  BtShared *pBt = p.pBt;
  assert( nReserve>=-1 && nReserve<=255 );
  p.Lock()
  if( pBt.Flags & BTS_PAGESIZE_FIXED ){
    p.Unlock()
    return SQLITE_READONLY;
  }
  if( nReserve<0 ){
    nReserve = pBt.pageSize - pBt.usableSize;
  }
  assert( nReserve>=0 && nReserve<=255 );
  if( pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE &&
        ((pageSize-1)&pageSize)==0 ){
    assert( (pageSize & 7)==0 );
    assert( !pBt.pPage1 && !pBt.pCursor );
    pBt.pageSize = (uint32)pageSize;
    freeTempSpace(pBt);
  }
  rc = sqlite3PagerSetPagesize(pBt.pPager, &pBt.pageSize, nReserve);
  pBt.usableSize = pBt.pageSize - (uint16)nReserve;
  if( iFix ) pBt.Flags |= BTS_PAGESIZE_FIXED;
  p.Unlock()
  return rc;
}

/*
** Return the currently defined page size
*/
 int sqlite3BtreeGetPageSize(Btree *p){
  return p.pBt.pageSize;
}

#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) || !defined(SQLITE_OMIT_VACUUM)
/*
** Return the number of bytes of space at the end of every page that
** are intentually left unused.  This is the "reserved" space that is
** sometimes used by extensions.
*/
 int sqlite3BtreeGetReserve(Btree *p){
  int n;
  p.Lock()
  n = p.pBt.pageSize - p.pBt.usableSize;
  p.Unlock()
  return n;
}

/*
** Set the maximum page count for a database if mxPage is positive.
** No changes are made if mxPage is 0 or negative.
** Regardless of the value of mxPage, return the maximum page count.
*/
 int sqlite3BtreeMaxPageCount(Btree *p, int mxPage){
  int n;
  p.Lock()
  n = sqlite3PagerMaxPageCount(p.pBt.pPager, mxPage);
  p.Unlock()
  return n;
}

/*
** Set the BTS_SECURE_DELETE flag if newFlag is 0 or 1.  If newFlag is -1,
** then make no changes.  Always return the value of the BTS_SECURE_DELETE
** setting after the change.
*/
 int sqlite3BtreeSecureDelete(Btree *p, int newFlag){
  int b;
  if( p==0 ) return 0;
  p.Lock()
  if( newFlag>=0 ){
    p.pBt.Flags &= ~BTS_SECURE_DELETE;
    if( newFlag ) p.pBt.Flags |= BTS_SECURE_DELETE;
  }
  b = (p.pBt.Flags & BTS_SECURE_DELETE)!=0;
  p.Unlock()
  return b;
}
#endif /* !defined(SQLITE_OMIT_PAGER_PRAGMAS) || !defined(SQLITE_OMIT_VACUUM) */

/*
** Change the 'auto-vacuum' property of the database. If the 'autoVacuum'
** parameter is non-zero, then auto-vacuum mode is enabled. If zero, it
** is disabled. The default value for the auto-vacuum property is
** determined by the SQLITE_DEFAULT_AUTOVACUUM macro.
*/
 int sqlite3BtreeSetAutoVacuum(Btree *p, int autoVacuum){
  BtShared *pBt = p.pBt;
  int rc = SQLITE_OK;
  byte av = (byte)autoVacuum;

  p.Lock()
  if( (pBt.Flags & BTS_PAGESIZE_FIXED)!=0 && (av ?1:0)!=pBt.autoVacuum ){
    rc = SQLITE_READONLY;
  }else{
    pBt.autoVacuum = av ?1:0;
    pBt.incrVacuum = av==2 ?1:0;
  }
  p.Unlock()
  return rc;
}

/*
** Return the value of the 'auto-vacuum' property. If auto-vacuum is
** enabled 1 is returned. Otherwise 0.
*/
 int sqlite3BtreeGetAutoVacuum(Btree *p){
  int rc;
  p.Lock()
  rc = (
    (!p.pBt.autoVacuum)?BTREE_AUTOVACUUM_NONE:
    (!p.pBt.incrVacuum)?BTREE_AUTOVACUUM_FULL:
    BTREE_AUTOVACUUM_INCR
  );
  p.Unlock()
  return rc;
}


/*
** Get a reference to pPage1 of the database file.  This will
** also acquire a readlock on that file.
**
** SQLITE_OK is returned on success.  If the file is not a
** well-formed database file, then SQLITE_CORRUPT is returned.
** SQLITE_BUSY is returned if the database is locked.  SQLITE_NOMEM
** is returned if we run out of memory.
*/
static int lockBtree(BtShared *pBt){
  int rc;              /* Result code from subfunctions */
  MemoryPage *pPage1;     /* Page 1 of the database file */
  int nPage;           /* Number of pages in the database */
  int nPageFile = 0;   /* Number of pages in the database file */
  int nPageHeader;     /* Number of pages in the database according to hdr */

  assert( pBt.pPage1==0 );
  rc = sqlite3PagerSharedLock(pBt.pPager);
  if( rc!=SQLITE_OK ) return rc;
  if pPage1, rc = pBt.GetPage(1, false); rc != SQLITE_OK {
	  return rc
	}

  /* Do some checking to help insure the file we opened really is
  ** a valid database file.
  */
  nPage = nPageHeader = Buffer(pPage1.aData[28:]).ReadUint32()
  sqlite3PagerPagecount(pBt.pPager, &nPageFile);
  if( nPage==0 || memcmp(24+(byte*)pPage1.aData, 92+(byte*)pPage1.aData,4)!=0 ){
    nPage = nPageFile;
  }
  if( nPage>0 ){
    uint32 pageSize;
    uint32 usableSize;
    byte *page1 = pPage1.aData;
    rc = SQLITE_NOTADB;
    if( memcmp(page1, zMagicHeader, 16)!=0 ){
      goto page1_init_failed;
    }

    if( page1[18]>2 ){
      pBt.Flags |= BTS_READ_ONLY;
    }
    if( page1[19]>2 ){
      goto page1_init_failed;
    }

    /* If the write version is set to 2, this database should be accessed
    ** in WAL mode. If the log is not already open, open it now. Then
    ** return SQLITE_OK and return without populating BtShared.pPage1.
    ** The caller detects this and calls this function again. This is
    ** required as the version of page 1 currently in the page1 buffer
    ** may not be the latest version - there may be a newer one in the log
    ** file.
    */
    if( page1[19]==2 && (pBt.Flags & BTS_NO_WAL)==0 ){
      int isOpen = 0;
      rc = sqlite3PagerOpenWal(pBt.pPager, &isOpen);
      if( rc!=SQLITE_OK ){
        goto page1_init_failed;
      }else if( isOpen==0 ){
        pPage1.Release()
        return SQLITE_OK;
      }
      rc = SQLITE_NOTADB;
    }

    /* The maximum embedded fraction must be exactly 25%.  And the minimum
    ** embedded fraction must be 12.5% for both leaf-data and non-leaf-data.
    ** The original design allowed these amounts to vary, but as of
    ** version 3.6.0, we require them to be fixed.
    */
    if( memcmp(&page1[21], "\100\040\040",3)!=0 ){
      goto page1_init_failed;
    }
    pageSize = (page1[16]<<8) | (page1[17]<<16);
    if( ((pageSize-1)&pageSize)!=0
     || pageSize>SQLITE_MAX_PAGE_SIZE
     || pageSize<=256
    ){
      goto page1_init_failed;
    }
    assert( (pageSize & 7)==0 );
    usableSize = pageSize - page1[20];
    if( (uint32)pageSize!=pBt.pageSize ){
      /* After reading the first page of the database assuming a page size
      ** of BtShared.pageSize, we have discovered that the page-size is
      ** actually pageSize. Unlock the database, leave pBt.pPage1 at
      ** zero and return SQLITE_OK. The caller will call this function
      ** again with the correct page-size.
      */
      pPage1.Release()
      pBt.usableSize = usableSize;
      pBt.pageSize = pageSize;
      freeTempSpace(pBt);
      rc = sqlite3PagerSetPagesize(pBt.pPager, &pBt.pageSize,
                                   pageSize-usableSize);
      return rc;
    }
    if( (pBt.db.flags & SQLITE_RecoveryMode)==0 && nPage>nPageFile ){
      rc = SQLITE_CORRUPT_BKPT;
      goto page1_init_failed;
    }
    if( usableSize<480 ){
      goto page1_init_failed;
    }
    pBt.pageSize = pageSize;
    pBt.usableSize = usableSize;
    if Buffer(page1[36 + (4 * 4):]).ReadUint32() != 0 {
		pBt.autoVacuum = true
	} else {
		pBt.autoVacuum = false
	}
    if Buffer(page1[36 + (7 * 4):]).ReadUint32() != 0 {
		pBt.incrVacuum = true
	} else {
		pBt.incrVacuum = false
	}
  }

  /* maxLocal is the maximum amount of payload to store locally for
  ** a cell.  Make sure it is small enough so that at least minFanout
  ** cells can will fit on one page.  We assume a 10-byte page header.
  ** Besides the payload, the cell must store:
  **     2-byte pointer to the cell
  **     4-byte child pointer
  **     9-byte nKey value
  **     4-byte nData value
  **     4-byte overflow page pointer
  ** So a cell consists of a 2-byte pointer, a header which is as much as
  ** 17 bytes long, 0 to N bytes of payload, and an optional 4 byte overflow
  ** page pointer.
  */
  pBt.maxLocal = (uint16)((pBt.usableSize-12)*64/255 - 23);
  pBt.minLocal = (uint16)((pBt.usableSize-12)*32/255 - 23);
  pBt.maxLeaf = (uint16)(pBt.usableSize - 35);
  pBt.minLeaf = (uint16)((pBt.usableSize-12)*32/255 - 23);
  if( pBt.maxLocal>127 ){
    pBt.max1bytePayload = 127;
  }else{
    pBt.max1bytePayload = (byte)pBt.maxLocal;
  }
  assert( pBt.maxLeaf + 23 <= MX_CELL_SIZE(pBt) );
  pBt.pPage1 = pPage1;
  pBt.nPage = nPage;
  return SQLITE_OK;

page1_init_failed:
  pPage1.Release()
  pBt.pPage1 = 0;
  return rc;
}

/*
** If there are no outstanding cursors and we are not in the middle
** of a transaction but there is a read lock on the database, then
** this routine unrefs the first page of the database file which
** has the effect of releasing the read lock.
**
** If there is a transaction in progress, this routine is a no-op.
*/
static void unlockBtreeIfUnused(BtShared *pBt){
  assert( pBt.pCursor==0 || pBt.inTransaction>TRANS_NONE );
  if( pBt.inTransaction==TRANS_NONE && pBt.pPage1!=0 ){
    assert( pBt.pPage1.aData );
    assert( sqlite3PagerRefcount(pBt.pPager)==1 );
    assert( pBt.pPage1.aData );
    pBt.pPage1.Release()
    pBt.pPage1 = nil
  }
}

//	If pBt points to an empty file then convert that empty file into a new empty database by initializing the first page of the database.
func (pBt *BtShared) NewDatabase() (rc int) {
	rc = SQLITE_OK
	if pBt.nPage == 0 {
		pP1 := pBt.pPage1
		assert( pP1 != nil )
		data := pP1.aData
		if rc = sqlite3PagerWrite(pP1.pDbPage); rc == SQLITE_OK {
			memcpy(data, zMagicHeader, sizeof(zMagicHeader))
			assert( sizeof(zMagicHeader) == 16 )
			data[16] = byte((pBt.pageSize >> 8) & 0xff)
			data[17] = byte((pBt.pageSize >> 16) & 0xff)
			data[18] = 1
			data[19] = 1
			assert( pBt.usableSize <= pBt.pageSize && pBt.usableSize + 255 >= pBt.pageSize);
			data[20] = byte(pBt.pageSize - pBt.usableSize)
			data[21] = 64
			data[22] = 32
			data[23] = 32
			memset(&data[24], 0, 100 - 24)
			zeroPage(pP1, PTF_INTKEY | PTF_LEAF | PTF_LEAFDATA )
			pBt.Flags |= BTS_PAGESIZE_FIXED
			assert( pBt.autoVacuum == 1 || pBt.autoVacuum == 0 )
			assert( pBt.incrVacuum == 1 || pBt.incrVacuum == 0 )
			Buffer(data[36 + (4 *4 ):]).WriteUint32(pBt.autoVacuum)
			Buffer(data[36 + (7 * 4):]).WriteUint32(pBt.incrVacuum)
			pBt.nPage = 1
			data[31] = 1
		}
	}
	return
}

/*
** Attempt to start a new transaction. A write-transaction
** is started if the second argument is nonzero, otherwise a read-
** transaction.  If the second argument is 2 or more and exclusive
** transaction is started, meaning that no other process is allowed
** to access the database.  A preexisting transaction may not be
** upgraded to exclusive by calling this routine a second time - the
** exclusivity flag only works for a new transaction.
**
** A write-transaction must be started before attempting any
** changes to the database.  None of the following routines
** will work unless a transaction is started first:
**
**      sqlite3BtreeCreateTable()
**      sqlite3BtreeCreateIndex()
**      sqlite3BtreeClearTable()
**      sqlite3BtreeDropTable()
**      sqlite3BtreeInsert()
**      sqlite3BtreeDelete()
**      sqlite3BtreeUpdateMeta()
**
** If an initial attempt to acquire the lock fails because of lock contention
** and the database was previously unlocked, then invoke the busy handler
** if there is one.  But if there was previously a read-lock, do not
** invoke the busy handler - just return SQLITE_BUSY.  SQLITE_BUSY is
** returned when there is already a read-lock in order to avoid a deadlock.
**
** Suppose there are two processes A and B.  A has a read lock and B has
** a reserved lock.  B tries to promote to exclusive but is blocked because
** of A's read lock.  A tries to promote to reserved but is blocked by B.
** One or the other of the two processes must give way or there can be
** no progress.  By returning SQLITE_BUSY and not invoking the busy callback
** when A already has a read lock, we encourage A to give up and let B
** proceed.
*/
 int sqlite3BtreeBeginTrans(Btree *p, int wrflag){
  sqlite3 *pBlock = 0;
  BtShared *pBt = p.pBt;
  int rc = SQLITE_OK;

  p.Lock()
	p.EnforceIntegrity()

  /* If the btree is already in a write-transaction, or it
  ** is already in a read-transaction and a read-transaction
  ** is requested, this is a no-op.
  */
  if( p.inTrans==TRANS_WRITE || (p.inTrans==TRANS_READ && !wrflag) ){
    goto trans_begun;
  }

  /* Write transactions are not possible on a read-only database */
  if( (pBt.Flags & BTS_READ_ONLY)!=0 && wrflag ){
    rc = SQLITE_READONLY;
    goto trans_begun;
  }

	//	If another database handle has already opened a write transaction on this shared-btree structure and a second write transaction is requested, return SQLITE_LOCKED.
	switch {
	case (wrflag && pBt.inTransaction == TRANS_WRITE) || (pBt.Flags & BTS_PENDING) != 0:
		pBlock = pBt.pWriter.db
	case wrflag > 1:
		for lock := pBt.pLock; lock != nil; lock = lock.Next {
			if lock.Btree != p {
				pBlock = lock.Btree.db
				break
			}
		}
	}
  if( pBlock ){
    p.db.ConnectionBlocked(pBlock)
    rc = SQLITE_LOCKED_SHAREDCACHE;
    goto trans_begun;
  }

  /* Any read-only or read-write transaction implies a read-lock on
  ** page 1. So if some other shared-cache client already has a write-lock
  ** on page 1, the transaction cannot be opened. */
  rc = p.querySharedCacheTableLock(MASTER_ROOT, READ_LOCK)
  if( SQLITE_OK!=rc ) goto trans_begun;

  pBt.Flags &= ~BTS_INITIALLY_EMPTY;
  if( pBt.nPage==0 ) pBt.Flags |= BTS_INITIALLY_EMPTY;
  do {
    /* Call lockBtree() until either pBt.pPage1 is populated or
    ** lockBtree() returns something other than SQLITE_OK. lockBtree()
    ** may return SQLITE_OK but leave pBt.pPage1 set to 0 if after
    ** reading page 1 it discovers that the page-size of the database
    ** file is not pBt.pageSize. In this case lockBtree() will update
    ** pBt.pageSize to the page-size of the file on disk.
    */
    while( pBt.pPage1==0 && SQLITE_OK==(rc = lockBtree(pBt)) );

    if( rc==SQLITE_OK && wrflag ){
      if( (pBt.Flags & BTS_READ_ONLY)!=0 ){
        rc = SQLITE_READONLY;
      }else{
        rc = sqlite3PagerBegin(pBt.pPager,wrflag>1,sqlite3TempInMemory(p.db));
        if( rc==SQLITE_OK ){
          rc = pBt.NewDatabase()
        }
      }
    }

    if( rc!=SQLITE_OK ){
      unlockBtreeIfUnused(pBt);
    }
  }while( (rc&0xFF)==SQLITE_BUSY && pBt.inTransaction==TRANS_NONE &&
          btreeInvokeBusyHandler(pBt) );

  if( rc==SQLITE_OK ){
    if( p.inTrans==TRANS_NONE ){
      pBt.nTransaction++;
      if( p.sharable ){
	assert( p.lock.pBtree==p && p.lock.iTable==1 );
        p.lock.eLock = READ_LOCK;
        p.lock.Next = pBt.pLock;
        pBt.pLock = &p.lock;
      }
    }
    p.inTrans = (wrflag?TRANS_WRITE:TRANS_READ);
    if( p.inTrans>pBt.inTransaction ){
      pBt.inTransaction = p.inTrans;
    }
    if( wrflag ){
      MemoryPage *pPage1 = pBt.pPage1;
      assert( !pBt.pWriter );
      pBt.pWriter = p;
      pBt.Flags &= ~BTS_EXCLUSIVE;
      if( wrflag>1 ) pBt.Flags |= BTS_EXCLUSIVE;

      /* If the db-size header field is incorrect (as it may be if an old
      ** client has been writing the database file), update it now. Doing
      ** this sooner rather than later means the database size can safely
      ** re-read the database size from page 1 if a savepoint or transaction
      ** rollback occurs within the transaction.
      */
      if pBt.nPage != Buffer(pPage1.aData[28:]).ReadUint32() {
        rc = sqlite3PagerWrite(pPage1.pDbPage);
        if( rc==SQLITE_OK ){
          Buffer(pPage1.aData[28:]).WriteUint32(pBt.nPage)
        }
      }
    }
  }


trans_begun:
  if( rc==SQLITE_OK && wrflag ){
    /* This call makes sure that the pager has the correct number of
    ** open savepoints. If the second parameter is greater than 0 and
    ** the sub-journal is not already open, then it will be opened here.
    */
    rc = pBt.pPager.OpenSavepoint(p.db.nSavepoint)
  }

	p.EnforceIntegrity()
  p.Unlock()
  return rc;
}

/*
** Set the pointer-map entries for all children of page pPage. Also, if
** pPage contains cells that point to overflow pages, set the pointer
** map entries for the overflow pages as well.
*/
static int setChildPtrmaps(MemoryPage *pPage){
	int i;                             /* Counter variable */
	int nCell;                         /* Number of cells in page pPage */
	int rc;                            /* Return code */
	BtShared *pBt = pPage.pBt;
	byte isInitOrig = pPage.isInit;
	PageNumber pgno = pPage.pgno;

	if rc = pPage.Initialize(); rc == SQLITE_OK {
		nCell = pPage.nCell;

		for(i=0; i<nCell; i++){
			pCell := pPage.FindCell(i)
			rc = pPage.PutOvflPtr(pCell)
			if !pPage.leaf {
				childPageNumber := Buffer(pCell).ReadUint32()
				rc = pBt.Put(childPageNumber, NON_ROOT_BTREE_PAGE, pgno)
			}
		}

		if !pPage.leaf {
			childPageNumber := Buffer(pPage.aData[pPage.hdrOffset + 8:]).ReadUint32()
			rc = pBt.Put(childPageNumber, NON_ROOT_BTREE_PAGE, pgno)
		}
	}
	pPage.isInit = isInitOrig
}

/*
** Somewhere on pPage is a pointer to page iFrom.  Modify this pointer so
** that it points to iTo. Parameter eType describes the type of pointer to
** be modified, as  follows:
**
** NON_ROOT_BTREE_PAGE:     pPage is a btree-page. The pointer points at a child
**                   page of pPage.
**
** FIRST_OVERFLOW_PAGE: pPage is a btree-page. The pointer points at an overflow
**                   page pointed to by one of the cells on pPage.
**
** SECONDARY_OVERFLOW_PAGE: pPage is an overflow-page. The pointer points at the next
**                   overflow page in the list.
*/
static int modifyPagePointer(MemoryPage *pPage, PageNumber iFrom, PageNumber iTo, byte eType){
  if( eType==SECONDARY_OVERFLOW_PAGE ){
    /* The pointer is always the first 4 bytes of the page in this case.  */
    if Buffer(pPage.aData).ReadUint32() != iFrom {
      return SQLITE_CORRUPT_BKPT;
    }
    Buffer(pPage.aData).WriteUint32(iTo)
  }else{
    byte isInitOrig = pPage.isInit;
    int i;
    int nCell;

    pPage.Initialize()
    nCell = pPage.nCell;

    for(i=0; i<nCell; i++){
      byte *pCell = pPage.FindCell(i)
      if( eType==FIRST_OVERFLOW_PAGE ){
        info	CellInfo
        info.ParsePtr(pPage, pCell)
        if info.iOverflow != 0 && (pCell + info.iOverflow + 3) <= (pPage.aData + pPage.maskPage) && iFrom == Buffer(pCell[info.iOverflow:]).ReadUint32() {
          Buffer(pCell[info.iOverflow:]).WriteUint32(iTo)
          break;
        }
      }else{
        if Buffer(pCell).ReadUint32() == iFrom {
          Buffer(pCell).WriteUint32(iTo)
          break;
        }
      }
    }

    if( i==nCell ){
      if eType != NON_ROOT_BTREE_PAGE || Buffer(pPage.aData[pPage.hdrOffset + 8:]).ReadUint32() != iFrom {
        return SQLITE_CORRUPT_BKPT;
      }
      Buffer(pPage.aData[pPage.hdrOffset + 8:]).WriteUint32(iTo)
    }

    pPage.isInit = isInitOrig;
  }
  return SQLITE_OK;
}


/*
** Move the open database page pDbPage to location iFreePage in the
** database. The pDbPage reference remains valid.
**
** The isCommit flag indicates that there is no need to remember that
** the journal needs to be sync()ed before database page pDbPage.pgno
** can be written to. The caller has already promised not to write to that
** page.
*/
static int relocatePage(
  BtShared *pBt,           /* Btree */
  MemoryPage *pDbPage,        /* Open page to move */
  byte eType,                /* Pointer map 'type' entry for pDbPage */
  PageNumber iPtrPage,           /* Pointer map 'page-no' entry for pDbPage */
  PageNumber iFreePage,          /* The location to move pDbPage to */
  int isCommit             /* isCommit flag passed to sqlite3PagerMovepage */
){
  MemoryPage *pPtrPage;   /* The page that contains a pointer to pDbPage */
  PageNumber iDbPage = pDbPage.pgno;
  Pager *pPager = pBt.pPager;
  int rc;

  assert( eType==SECONDARY_OVERFLOW_PAGE || eType==FIRST_OVERFLOW_PAGE || eType==NON_ROOT_BTREE_PAGE || eType==ROOT_PAGE );
  assert( pDbPage.pBt==pBt );

  /* Move page iDbPage from its current location to page number iFreePage */
  rc = sqlite3PagerMovepage(pPager, pDbPage.pDbPage, iFreePage, isCommit);
  if( rc!=SQLITE_OK ){
    return rc;
  }
  pDbPage.pgno = iFreePage;

  /* If pDbPage was a btree-page, then it may have child pages and/or cells
  ** that point to overflow pages. The pointer map entries for all these
  ** pages need to be changed.
  **
  ** If pDbPage is an overflow page, then the first 4 bytes may store a
  ** pointer to a subsequent overflow page. If this is the case, then
  ** the pointer map needs to be updated for the subsequent overflow page.
  */
  if( eType==NON_ROOT_BTREE_PAGE || eType==ROOT_PAGE ){
    rc = setChildPtrmaps(pDbPage);
    if( rc!=SQLITE_OK ){
      return rc;
    }
  }else{
    PageNumber nextOvfl = Buffer(pDbPage.aData).ReadUint32()
    if( nextOvfl!=0 ){
      if rc = pBt.Put(nextOvfl, SECONDARY_OVERFLOW_PAGE, iFreePage); rc != SQLITE_OK {
        return rc
      }
    }
  }

  /* Fix the database pointer on page iPtrPage that pointed at iDbPage so
  ** that it points at iFreePage. Also fix the pointer map entry for
  ** iPtrPage.
  */
  if( eType!=ROOT_PAGE ){
    if pPtrPage, rc = pBt.GetPage(iPtrPage, false); rc != SQLITE_OK {
      return rc;
    }
    rc = sqlite3PagerWrite(pPtrPage.pDbPage);
    if( rc!=SQLITE_OK ){
      pPtrPage.Release()
      return rc;
    }
    rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType);
    pPtrPage.Release()
    if rc == SQLITE_OK {
      rc = pBt.Put(iFreePage, eType, iPtrPage)
    }
  }
  return rc;
}

/* Forward declaration required by incrVacuumStep(). */
static int allocateBtreePage(BtShared *, MemoryPage **, PageNumber *, PageNumber, byte);

/*
** Perform a single step of an incremental-vacuum. If successful,
** return SQLITE_OK. If there is no work to do (and therefore no
** point in calling this function again), return SQLITE_DONE.
**
** More specificly, this function attempts to re-organize the
** database so that the last page of the file currently in use
** is no longer in use.
**
** If the nFin parameter is non-zero, this function assumes
** that the caller will keep calling incrVacuumStep() until
** it returns SQLITE_DONE or an error, and that nFin is the
** number of pages the database file will contain after this
** process is complete.  If nFin is zero, it is assumed that
** incrVacuumStep() will be called a finite amount of times
** which may or may not empty the freelist.  A full autovacuum
** has nFin>0.  A "PRAGMA incremental_vacuum" has nFin==0.
*/
static int incrVacuumStep(BtShared *pBt, PageNumber nFin, PageNumber iLastPg){
  PageNumber nFreeList;           /* Number of pages still on the free-list */
  int rc;

  assert( iLastPg>nFin );

  if !pBt.IsMapPage(iLastPg) && iLastPg != PAGER_MJ_PGNO(pBt) {
    byte eType;
    PageNumber iPtrPage;

    nFreeList = Buffer(pBt.pPage1.aData[36:]).ReadUint32()
    if( nFreeList==0 ){
      return SQLITE_DONE;
    }

    eType, iPtrPage, rc = pBt.Get(iLastPg)
    if( rc!=SQLITE_OK ){
      return rc;
    }
    if( eType==ROOT_PAGE ){
      return SQLITE_CORRUPT_BKPT;
    }

    if( eType==FREE_PAGE ){
      if( nFin==0 ){
        /* Remove the page from the files free-list. This is not required
        ** if nFin is non-zero. In that case, the free-list will be
        ** truncated to zero after this function returns, so it doesn't
        ** matter if it still contains some garbage entries.
        */
        PageNumber iFreePg;
        MemoryPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, 1);
        if( rc!=SQLITE_OK ){
          return rc;
        }
        assert( iFreePg==iLastPg );
        pFreePg.Release()
      }
    } else {
      PageNumber iFreePg;             /* Index of free page to move pLastPg to */
      MemoryPage *pLastPg;

      if pLastPg, rc = pBt.GetPage(iLastPg, false); rc != SQLITE_OK {
        return rc
      }

      /* If nFin is zero, this loop runs exactly once and page pLastPg
      ** is swapped with the first free page pulled off the free list.
      **
      ** On the other hand, if nFin is greater than zero, then keep
      ** looping until a free-page located within the first nFin pages
      ** of the file is found.
      */
      do {
        MemoryPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, 0, 0);
        if( rc!=SQLITE_OK ){
          pLastPg.Release()
          return rc;
        }
        pFreePg.Release()
      }while( nFin!=0 && iFreePg>nFin );
      assert( iFreePg<iLastPg );

      rc = sqlite3PagerWrite(pLastPg.pDbPage);
      if( rc==SQLITE_OK ){
        rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, nFin!=0);
      }
      pLastPg.Release()
      if( rc!=SQLITE_OK ){
        return rc;
      }
    }
  }

  if( nFin==0 ){
    iLastPg--;
    for iLastPg == PAGER_MJ_PGNO(pBt) || pBt.IsMapPage(iLastPg) {
      if pBt.IsMapPage(iLastPg) {
        MemoryPage *pPg;
        if pPg, rc = pBt.GetPage(iLastPg, false); rc != SQLITE_OK {
          return rc
        }
        rc = sqlite3PagerWrite(pPg.pDbPage);
        pPg.Release()
        if( rc!=SQLITE_OK ){
          return rc;
        }
      }
      iLastPg--;
    }
    sqlite3PagerTruncateImage(pBt.pPager, iLastPg);
    pBt.nPage = iLastPg;
  }
  return SQLITE_OK;
}

/*
** A write-transaction must be opened before calling this function.
** It performs a single unit of work towards an incremental vacuum.
**
** If the incremental vacuum is finished after this function has run,
** SQLITE_DONE is returned. If it is not finished, but no error occurred,
** SQLITE_OK is returned. Otherwise an SQLite error code.
*/
 int sqlite3BtreeIncrVacuum(Btree *p){
  int rc;
  BtShared *pBt = p.pBt;

  p.Lock()
  assert( pBt.inTransaction==TRANS_WRITE && p.inTrans==TRANS_WRITE );
  if( !pBt.autoVacuum ){
    rc = SQLITE_DONE;
  }else{
    invalidateAllOverflowCache(pBt);
    rc = incrVacuumStep(pBt, 0, btreePagecount(pBt));
    if( rc==SQLITE_OK ){
      rc = sqlite3PagerWrite(pBt.pPage1.pDbPage);
      Buffer(pBt.pPage1.aData[28:]).WriteUint32(pBt.nPage)
    }
  }
  p.Unlock()
  return rc;
}

//	This routine is called prior to sqlite3PagerCommit when a transaction is commited for an auto-vacuum database.
//	If SQLITE_OK is returned, then *pnTrunc is set to the number of pages the database file should be truncated to during the commit process. i.e. the database has been reorganized so that only the first *pnTrunc pages are in use.
func (pBt *BtShared) autoVacuumCommit() (rc int) {
	pPager := pBt.pPager
	invalidateAllOverflowCache(pBt)
	assert(pBt.autoVacuum)
	if !pBt.incrVacuum {
		PageNumber nFin			//	Number of pages in database after autovacuuming
		PageNumber iFree		//	The next page to be freed

		nOrig := btreePagecount(pBt)
		if pBt.IsMapPage(nOrig) || nOrig == PAGER_MJ_PGNO(pBt) {
			//	It is not possible to create a database for which the final page is either a pointer-map page or the pending-byte page. If one is encountered, this indicates corruption.
			return SQLITE_CORRUPT_BKPT
		}

		nFree := Buffer(pBt.pPage1.aData[36:]).ReadUint32()
		nEntry := pBt.usableSize / 5
		nPtrmap := (nFree - nOrig + pBt.Pageno(nOrig) + nEntry) / nEntry
		nFin := nOrig - nFree - nPtrmap;
		if nOrig > PAGER_MJ_PGNO(pBt) && nFin < PAGER_MJ_PGNO(pBt) {
			nFin--
		}
		for pBt.IsMapPage(nFin) || nFin == PAGER_MJ_PGNO(pBt) {
			nFin--
		}
		if nFin > nOrig {
			return SQLITE_CORRUPT_BKPT
		}
		for iFree = nOrig; iFree > nFin && rc == SQLITE_OK; iFree-- {
			rc = incrVacuumStep(pBt, nFin, iFree)
		}
		if (rc == SQLITE_DONE || rc == SQLITE_OK) && nFree > 0 {
			rc = sqlite3PagerWrite(pBt.pPage1.pDbPage)
			Buffer(pBt.pPage1.aData[32:]).WriteUint32(0)
			Buffer(pBt.pPage1.aData[36:]).WriteUint32(0)
			Buffer(pBt.pPage1.aData[28:]).WriteUint32(nFin)
			sqlite3PagerTruncateImage(pBt.pPager, nFin)
			pBt.nPage = nFin
		}
		if rc != SQLITE_OK {
			sqlite3PagerRollback(pPager)
		}
	}
	assert( nRef == sqlite3PagerRefcount(pPager) )
	return
}

//	This routine does the first phase of a two-phase commit. This routine causes a rollback journal to be created (if it does not already exist) and populated with enough information so that if a power loss occurs the database can be restored to its original state by playing back the journal. Then the contents of the journal are flushed out to the disk. After the journal is safely on oxide, the changes to the database are written into the database file and flushed to oxide. At the end of this call, the rollback journal still exists on the disk and we are still holding all locks, so the transaction has not committed. See Btree::CommitPhaseTwo() for the second phase of the commit process.
//	This call is a no-op if no write-transaction is currently active on pBt.
//	Otherwise, sync the database file for the btree pBt. master_journal points to the name of a master journal file that should be written into the individual journal file, or is NULL, indicating no master journal file (single database transaction).
//	When this is called, the master journal should already have been created, populated with this journal pointer and synced to disk.
//	Once this is routine has returned, the only thing required to commit the write-transaction for this database file is to delete the journal.
func (p *Btree) CommitPhaseOne(master_journal string) (rc int) {
	if p.inTrans == TRANS_WRITE {
		pBt := p.pBt
		p.Lock()
		if pBt.autoVacuum {
			if rc = pBt.autoVacuumCommit(); rc != SQLITE_OK {
				p.Unlock()
				return rc
			}
		}
		rc = sqlite3PagerCommitPhaseOne(pBt.pPager, master_journal, 0)
		p.Unlock()
	}
	return
}

//	This function is called from both BtreeCommitPhaseTwo() and BtreeRollback() at the conclusion of a transaction.
static void btreeEndTransaction(Btree *p){
  BtShared *pBt = p.pBt;

  btreeClearHasContent(pBt);
  if( p.inTrans>TRANS_NONE && p.db.activeVdbeCnt>1 ){
    /* If there are other active statements that belong to this database
    ** handle, downgrade to a read-only transaction. The other statements
    ** may still be reading from the database.  */
    p.downgradeAllSharedCacheTableLocks()
    p.inTrans = TRANS_READ;
  }else{
    /* If the handle had any kind of transaction open, decrement the
    ** transaction count of the shared btree. If the transaction count
    ** reaches 0, set the shared state to TRANS_NONE. The unlockBtreeIfUnused()
    ** call below will unlock the pager.  */
    if( p.inTrans!=TRANS_NONE ){
      p.clearAllSharedCacheTableLocks()
      pBt.nTransaction--;
      if( 0==pBt.nTransaction ){
        pBt.inTransaction = TRANS_NONE;
      }
    }

    /* Set the current transaction state to TRANS_NONE and unlock the
    ** pager if this call closed the only read or write transaction.  */
    p.inTrans = TRANS_NONE;
    unlockBtreeIfUnused(pBt);
  }

	p.EnforceIntegrity()
}

//	Commit the transaction currently in progress.
//	This routine implements the second phase of a 2-phase commit. The Btree::CommitPhaseOne() routine does the first phase and should be invoked prior to calling this routine. The Btree::CommitPhaseOne() routine did all the work of writing information out to disk and flushing the contents so that they are written onto the disk platter. All this routine has to do is delete or truncate or zero the header in the the rollback journal (which causes the transaction to commit) and drop locks.
//	Normally, if an error occurs while the pager layer is attempting to finalize the underlying journal file, this function returns an error and the upper layer will attempt a rollback. However, if the second argument is non-zero then this b-tree transaction is part of a multi-file transaction. In this case, the transaction has already been committed (by deleting a master journal file) and the caller will ignore this functions return code. So, even if an error occurs in the pager layer, reset the b-tree objects internal state to indicate that the write transaction has been closed. This is quite safe, as the pager will have transitioned to the error state.
//	This will release the write lock on the database file. If there are no active cursors, it also releases the read lock.
func (p *Btree) CommitPhaseTwo(cleanup bool) (rc int) {
	if p.inTrans != TRANS_NONE {
		p.CriticalSection(func() {
			p.EnforceIntegrity()
			//	If the handle has a write-transaction open, commit the shared-btrees transaction and set the shared state to TRANS_READ.
			if p.inTrans == TRANS_WRITE {
				pBt := p.pBt
				assert( pBt.inTransaction == TRANS_WRITE )
				assert( pBt.nTransaction > 0 )
				if rc = sqlite3PagerCommitPhaseTwo(pBt.pPager); rc != SQLITE_OK && !cleanup {
					return
				}
				pBt.inTransaction = TRANS_READ
			}
			btreeEndTransaction(p)
		})
	}
	return
}

//	Do both phases of a commit.
func (p *Btree) Commit() (rc int) {
	p.Lock()
	if rc = p.CommitPhaseOne(""); rc == SQLITE_OK {
		rc = p.CommitPhaseTwo(false)
	}
	p.Unlock()
	return
}

/*
** This routine sets the state to CURSOR_FAULT and the error
** code to errCode for every cursor on BtShared that pBtree
** references.
**
** Every cursor is tripped, including cursors that belong
** to other database connections that happen to be sharing
** the cache with pBtree.
**
** This routine gets called when a rollback occurs.
** All cursors using the same cache must be tripped
** to prevent them from trying to use the btree after
** the rollback.  The rollback may have deleted tables
** or moved root pages, so it is not sufficient to
** save the state of the cursor.  The cursor must be
** invalidated.
*/
 void sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode){
  Cursor *p;
  if( pBtree==0 ) return;
  pBtree.Lock()
  for(p=pBtree.pBt.pCursor; p; p=p.Next){
    int i;
    sqlite3BtreeClearCursor(p);
    p.eState = CURSOR_FAULT;
    p.skiNext = errCode;
    for(i=0; i<=p.iPage; i++){
      p.Pages[i].Release()
      p.Pages[i] = nil
    }
  }
  pBtree.Unlock()
}

//	Rollback the transaction in progress. All cursors will be invalided by this operation. Any attempt to use a cursor that was open at the beginning of this operation will result in an error.
//	This will release the write lock on the database file. If there are no active cursors, it also releases the read lock.
func (p *Btree) Rollback(tripCode int) (rc int) {
	pBt := p.pBt
	MemoryPage *pPage1

	p.Lock()
	if tripCode == SQLITE_OK {
		tripCode = saveAllCursors(pBt, 0, 0)
		rc = tripCode
	} else {
		rc = SQLITE_OK
	}
	if tripCode != SQLITE_OK {
		sqlite3BtreeTripAllCursors(p, tripCode)
	}
	p.EnforceIntegrity()

	if p.inTrans == TRANS_WRITE {
		assert( TRANS_WRITE == pBt.inTransaction )
		if rc2 := sqlite3PagerRollback(pBt.pPager); rc2 != SQLITE_OK {
			rc = rc2
		}

		//	The rollback may have destroyed the pPage1.aData value. So call .GetPageAndInitialize() on page 1 again to make sure pPage1.aData is set correctly.
		if pPage1, rc = pBt.GetPage(1, false); rc == SQLITE_OK {
			nPage := Buffer(pPage1.aData[28:]).ReadUint32()
			if nPage == 0 {
				sqlite3PagerPagecount(pBt.pPager, &nPage)
			}
			pBt.nPage = nPage
			pPage1.Release()
		}
		assert( countWriteCursors(pBt) == 0 )
		pBt.inTransaction = TRANS_READ
	}

	btreeEndTransaction(p)
	p.Unlock()
	return
}

/*
** Start a statement subtransaction. The subtransaction can can be rolled
** back independently of the main transaction. You must start a transaction
** before starting a subtransaction. The subtransaction is ended automatically
** if the main transaction commits or rolls back.
**
** Statement subtransactions are used around individual SQL statements
** that are contained within a BEGIN...COMMIT block.  If a constraint
** error occurs within the statement, the effect of that one statement
** can be rolled back without having to rollback the entire transaction.
**
** A statement sub-transaction is implemented as an anonymous savepoint. The
** value passed as the second parameter is the total number of savepoints,
** including the new anonymous savepoint, open on the B-Tree. i.e. if there
** are no active savepoints and no other statement-transactions open,
** iStatement is 1. This anonymous savepoint can be released or rolled back
** using the Btree::Savepoint() function.
*/
 int sqlite3BtreeBeginStmt(Btree *p, int iStatement){
  int rc;
  BtShared *pBt = p.pBt;
  p.Lock()
  assert( p.inTrans==TRANS_WRITE );
  assert( (pBt.Flags & BTS_READ_ONLY)==0 );
  assert( iStatement>0 );
  assert( iStatement>p.db.nSavepoint );
  assert( pBt.inTransaction==TRANS_WRITE );
  /* At the pager level, a statement transaction is a savepoint with
  ** an index greater than all savepoints created explicitly using
  ** SQL statements. It is illegal to open, release or rollback any
  ** such savepoints while the statement transaction savepoint is active.
  */
  rc = pBt.pPager.OpenSavepoint(iStatement)
  p.Unlock()
  return rc;
}

//	The second argument to this function, op, is always SAVEPOINT_ROLLBACK or SAVEPOINT_RELEASE. This function either releases or rolls back the savepoint identified by parameter iSavepoint, depending on the value of op.
//	Normally, iSavepoint is greater than or equal to zero. However, if op is SAVEPOINT_ROLLBACK, then iSavepoint may also be -1. In this case the contents of the entire transaction are rolled back. This is different from a normal transaction rollback, as no locks are released and the transaction remains open.
func (p *Btree) Savepoint(op, iSavepoint int) (rc int) {
	rc = SQLITE_OK
	if p != nil && p.inTrans == TRANS_WRITE {
		assert( op == SAVEPOINT_RELEASE || op == SAVEPOINT_ROLLBACK )
		assert( iSavepoint >= 0 || (iSavepoint == -1 && op == SAVEPOINT_ROLLBACK) )
		pBt := p.pBt
		p.Lock()
		if rc = pBt.pPager.Savepoint(op, iSavepoint); rc == SQLITE_OK {
			if iSavepoint < 0 && (pBt.Flags & BTS_INITIALLY_EMPTY) != 0 {
				pBt.nPage = 0
			}
			rc = pBt.NewDatabase()
			pBt.nPage = Buffer(pBt.pPage1.aData[28:]).ReadUint32()

			//	The database size was written into the offset 28 of the header when the transaction started, so we know that the value at offset 28 is nonzero.
			assert( pBt.nPage > 0 )
		}
		p.Unlock()
	}
	return rc
}

/*
** Create a new cursor for the BTree whose root is on the page
** iTable. If a read-only cursor is requested, it is assumed that
** the caller already has at least a read-only transaction open
** on the database already. If a write-cursor is requested, then
** the caller is assumed to have an open write transaction.
**
** If !Writable, then the cursor can only be used for reading.
** If Writable, then the cursor can be used for reading or for
** writing if other conditions for writing are also met.  These
** are the conditions that must be met in order for writing to
** be allowed:
**
** 1:  The cursor must have been opened with Writable
**
** 2:  Other database connections that share the same pager cache
**     but which are not in the READ_UNCOMMITTED state may not have
**     cursors open with !Writable on the same table.  Otherwise
**     the changes made by this write cursor would be visible to
**     the read cursors in the other database connection.
**
** 3:  The database must be writable (not on read-only media)
**
** 4:  There must be an active transaction.
**
** No checking is done to make sure that page iTable really is the
** root page of a b-tree.  If it is not, then the cursor acquired
** will not work correctly.
**
** It is assumed that the sqlite3BtreeCursorZero() has been called
** on pCur to initialize the memory space prior to invoking this routine.
*/
static int btreeCursor(
  Btree *p,                              /* The btree */
  int iTable,                            /* Root page of table to open */
  Writable bool,
  struct KeyInfo *pKeyInfo,              /* First arg to comparison function */
  Cursor *pCur                         /* Space for new cursor */
){
  BtShared *pBt = p.pBt;                /* Shared b-tree handle */

  assert( !Writable || Writable );

  /* The following assert statements verify that if this is a sharable
  ** b-tree database, the connection is holding the required table locks,
  ** and that no other connection has any open cursor that conflicts with
  ** this lock.  */
  assert( hasSharedCacheTableLock(p, iTable, pKeyInfo!=0, Writable+1) );
  assert( !Writable || !hasReadConflicts(p, iTable) );

  /* Assert that the caller has opened the required transaction. */
  assert( p.inTrans>TRANS_NONE );
  assert( !Writable || p.inTrans==TRANS_WRITE );
  assert( pBt.pPage1 && pBt.pPage1.aData );

  if( Writable && (pBt.Flags & BTS_READ_ONLY)!=0 ){
    return SQLITE_READONLY;
  }
  if( iTable==1 && btreePagecount(pBt)==0 ){
    assert( !Writable );
    iTable = 0;
  }

  /* Now that no other errors can occur, finish filling in the Cursor
  ** variables and link the cursor into the BtShared list.  */
  pCur.RootPage = (PageNumber)iTable;
  pCur.iPage = -1;
  pCur.pKeyInfo = pKeyInfo;
  pCur.pBtree = p;
  pCur.pBt = pBt;
  pCur.Writable = Writable
  pCur.Next = pBt.pCursor;
  if( pCur.Next ){
    pCur.Next.pPrev = pCur;
  }
  pBt.pCursor = pCur;
  pCur.eState = CURSOR_INVALID;
  pCur.cachedRowid = 0;
  return SQLITE_OK;
}
 int sqlite3BtreeCursor(
  Btree *p,                                   /* The btree */
  int iTable,                                 /* Root page of table to open */
  int Writable,                                 /* 1 to write. 0 read-only */
  struct KeyInfo *pKeyInfo,                   /* First arg to xCompare() */
  Cursor *pCur                              /* Write new cursor here */
){
  int rc;
  p.Lock()
  rc = btreeCursor(p, iTable, Writable, pKeyInfo, pCur);
  p.Unlock()
  return rc;
}

/*
** Return the size of a Cursor object in bytes.
**
** This interfaces is needed so that users of cursors can preallocate
** sufficient storage to hold a cursor.  The Cursor object is opaque
** to users so they cannot do the sizeof() themselves - they must call
** this routine.
*/
 int sqlite3BtreeCursorSize(void){
  return ROUND(sizeof(Cursor), 8);
}

/*
** Initialize memory that will be converted into a Cursor object.
**
** The simple approach here would be to memset() the entire object
** to zero.  But it turns out that the apPage[] and aiIdx[] arrays
** do not need to be zeroed and they are large, so we can save a lot
** of run-time by skipping the initialization of those elements.
*/
 void sqlite3BtreeCursorZero(Cursor *p){
  memset(p, 0, offsetof(Cursor, iPage));
}

/*
** Set the cached rowid value of every cursor in the same database file
** as pCur and having the same root page number as pCur.  The value is
** set to iRowid.
**
** Only positive rowid values are considered valid for this cache.
** The cache is initialized to zero, indicating an invalid cache.
** A btree will work fine with zero or negative rowids.  We just cannot
** cache zero or negative rowids, which means tables that use zero or
** negative rowids might run a little slower.  But in practice, zero
** or negative rowids are very uncommon so this should not be a problem.
*/
 void sqlite3BtreeSetCachedRowid(Cursor *pCur, int64 iRowid){
  Cursor *p;
  for(p=pCur.pBt.pCursor; p; p=p.Next){
    if( p.RootPage==pCur.RootPage ) p.cachedRowid = iRowid;
  }
  assert( pCur.cachedRowid==iRowid );
}

/*
** Return the cached rowid for the given cursor.  A negative or zero
** return value indicates that the rowid cache is invalid and should be
** ignored.  If the rowid cache has never before been set, then a
** zero is returned.
*/
 int64 sqlite3BtreeGetCachedRowid(Cursor *pCur){
  return pCur.cachedRowid;
}

/*
** Close a cursor.  The read lock on the database file is released
** when the last cursor is closed.
*/
 int sqlite3BtreeCloseCursor(Cursor *pCur){
  Btree *pBtree = pCur.pBtree;
  if( pBtree ){
    int i;
    BtShared *pBt = pCur.pBt;
    pBtree.Lock()
    sqlite3BtreeClearCursor(pCur);
    if( pCur.pPrev ){
      pCur.pPrev.Next = pCur.Next;
    }else{
      pBt.pCursor = pCur.Next;
    }
    if( pCur.Next ){
      pCur.Next.pPrev = pCur.pPrev;
    }
    for(i=0; i<=pCur.iPage; i++){
      pCur.Pages[i].Release()
    }
    unlockBtreeIfUnused(pBt);
    pCur.OverflowCache = nil
    /* pCur = nil */
    pBtree.Unlock()
  }
  return SQLITE_OK;
}


//	Make sure the Cursor* given in the argument has a valid Cursor.CellInfo structure. If it is not already valid, call CellInfo::Parse() to fill it in.
//	Cursor.CellInfo is a cache of the information in the current cell. Using this cache reduces the number of calls to CellInfo::Parse().
func (pCur *Cursor) getCellInfo() {
	if pCur.CellInfo.nSize == 0 {
		iPage := pCur.iPage
		&pCur.CellInfo.Parse(pCur.Pages[iPage], pCur.aiIdx[iPage])
		pCur.validNKey = 1
	}
}

/*
** Set *pSize to the size of the buffer needed to hold the value of
** the key for the current entry.  If the cursor is not pointing
** to a valid entry, *pSize is set to 0.
**
** For a table with the INTKEY flag set, this routine returns the key
** itself, not the number of bytes in the key.
**
** The caller must position the cursor prior to invoking this routine.
**
** This routine cannot fail.  It always returns SQLITE_OK.
*/
 int sqlite3BtreeKeySize(Cursor *pCur, int64 *pSize){
  assert( pCur.eState==CURSOR_INVALID || pCur.eState==CURSOR_VALID );
  if( pCur.eState!=CURSOR_VALID ){
    *pSize = 0;
  }else{
    getCellInfo(pCur)
    *pSize = pCur.CellInfo.nKey;
  }
  return SQLITE_OK;
}

/*
** Set *pSize to the number of bytes of data in the entry the
** cursor currently points to.
**
** The caller must guarantee that the cursor is pointing to a non-NULL
** valid entry.  In other words, the calling procedure must guarantee
** that the cursor has Cursor.eState==CURSOR_VALID.
**
** Failure is not possible.  This function always returns SQLITE_OK.
** It might just as well be a procedure (returning void) but we continue
** to return an integer result code for historical reasons.
*/
 int sqlite3BtreeDataSize(Cursor *pCur, uint32 *pSize){
  assert( pCur.eState==CURSOR_VALID );
  getCellInfo(pCur)
  *pSize = pCur.CellInfo.nData;
  return SQLITE_OK;
}

/*
** Given the page number of an overflow page in the database (parameter
** ovfl), this function finds the page number of the next page in the
** linked list of overflow pages. If possible, it uses the auto-vacuum
** pointer-map data instead of reading the content of page ovfl to do so.
**
** If an error occurs an SQLite error code is returned. Otherwise:
**
** The page number of the next overflow page in the linked list is
** written to *pPageNumberNext. If page ovfl is the last page in its linked
** list, *pPageNumberNext is set to zero.
**
** If ppPage is not NULL, and a reference to the MemoryPage object corresponding
** to page number pOvfl was obtained, then *ppPage is set to point to that
** reference. It is the responsibility of the caller to call Release()
** on *ppPage to free the reference. In no reference was obtained (because
** the pointer-map was used to obtain the value for *pPageNumberNext), then
** *ppPage is set to zero.
*/
static int getOverflowPage(
  BtShared *pBt,               /* The database file */
  PageNumber ovfl,                   /* Current overflow page number */
  MemoryPage **ppPage,            /* OUT: MemoryPage handle (may be NULL) */
  PageNumber *pPageNumberNext              /* OUT: Next overflow page number */
){
  PageNumber next = 0;
  MemoryPage *pPage = 0;
  int rc = SQLITE_OK;

  assert(pPageNumberNext);

  /* Try to find the next page in the overflow list using the
  ** autovacuum pointer-map pages. Guess that the next page in
  ** the overflow list is page number (ovfl+1). If that guess turns
  ** out to be wrong, fall back to loading the data of page
  ** number ovfl to determine the next page number.
  */
  if( pBt.autoVacuum ){
    PageNumber pgno;
    PageNumber iGuess = ovfl+1;
    byte eType;

    for pBt.IsMapPage(iGuess) || iGuess==PAGER_MJ_PGNO(pBt) {
      iGuess++
    }

    if( iGuess<=btreePagecount(pBt) ){
      eType, pgno, rc = pBt.Get(iGuess)
      if( rc==SQLITE_OK && eType==SECONDARY_OVERFLOW_PAGE && pgno==ovfl ){
        next = iGuess;
        rc = SQLITE_DONE;
      }
    }
  }

  assert( next==0 || rc==SQLITE_DONE );
  if( rc==SQLITE_OK ){
    pPage, rc = pBt.GetPage(ovfl, false)
    assert( rc==SQLITE_OK || pPage==0 );
    if rc == SQLITE_OK {
      next = Buffer(pPage.aData).ReadUint32()
    }
  }

  *pPageNumberNext = next;
  if( ppPage ){
    *ppPage = pPage;
  }else{
    pPage.Release()
  }
  return (rc==SQLITE_DONE ? SQLITE_OK : rc);
}

/*
** Copy data from a buffer to a page, or from a page to a buffer.
**
** pPayload is a pointer to data stored on database page pDbPage.
** If argument eOp is false, then nByte bytes of data are copied
** from pPayload to the buffer pointed at by pBuf. If eOp is true,
** then sqlite3PagerWrite() is called on pDbPage and nByte bytes
** of data are copied from the buffer pBuf to pPayload.
**
** SQLITE_OK is returned on success, otherwise an error code.
*/
static int copyPayload(
  void *pPayload,           /* Pointer to page data */
  void *pBuf,               /* Pointer to buffer */
  int nByte,                /* Number of bytes to copy */
  int eOp,                  /* 0 . copy from page, 1 . copy to page */
  DbPage *pDbPage           /* Page containing pPayload */
){
  if( eOp ){
    /* Copy data from buffer to page (a write operation) */
    int rc = sqlite3PagerWrite(pDbPage);
    if( rc!=SQLITE_OK ){
      return rc;
    }
    memcpy(pPayload, pBuf, nByte);
  }else{
    /* Copy data from page to buffer (a read operation) */
    memcpy(pBuf, pPayload, nByte);
  }
  return SQLITE_OK;
}

/*
** This function is used to read or overwrite payload information
** for the entry that the pCur cursor is pointing to. If the eOp
** parameter is 0, this is a read operation (data copied into
** buffer pBuf). If it is non-zero, a write (data copied from
** buffer pBuf).
**
** A total of "amt" bytes are read or written beginning at "offset".
** Data is read to or from the buffer pBuf.
**
** The content being read or written might appear on the main page
** or be scattered out on multiple overflow pages.
**
** If the Cursor.isIncrblobHandle flag is set, and the current
** cursor entry uses one or more overflow pages, this function
** allocates space for and lazily popluates the overflow page-list
** cache array (Cursor.OverflowCache). Subsequent calls use this
** cache to make seeking to the supplied offset more efficient.
**
** Once an overflow page-list cache has been allocated, it may be
** invalidated if some other cursor writes to the same table, or if
** the cursor is moved to a different row. Additionally, in auto-vacuum
** mode, the following events may invalidate an overflow page-list cache.
**
**   * An incremental vacuum,
**   * A commit in auto_vacuum="full" mode,
**   * Creating a table (may require moving an overflow page).
*/
static int accessPayload(
  Cursor *pCur,      /* Cursor pointing to entry to read from */
  uint32 offset,          /* Begin reading this far into payload */
  uint32 amt,             /* Read this many bytes */
  unsigned char *pBuf, /* Write the bytes into this buffer */
  int eOp              /* zero to read. non-zero to write. */
){
  unsigned char *aPayload;
  int rc = SQLITE_OK;
  uint32 nKey;
  int iIdx = 0;
  MemoryPage *pPage = pCur.Pages[pCur.iPage]; /* Btree page of current entry */
  BtShared *pBt = pCur.pBt;                  /* Btree this cursor belongs to */

  assert( pPage );
  assert( pCur.eState==CURSOR_VALID );
  assert( pCur.aiIdx[pCur.iPage]<pPage.nCell );

  getCellInfo(pCur)
  aPayload = pCur.CellInfo.pCell + pCur.CellInfo.nHeader;
  nKey = (pPage.intKey ? 0 : (int)pCur.CellInfo.nKey);

  if( offset+amt > nKey+pCur.CellInfo.nData || &aPayload[pCur.CellInfo.nLocal] > &pPage.aData[pBt.usableSize] ){
    /* Trying to read or write past the end of the data is an error */
    return SQLITE_CORRUPT_BKPT;
  }

  /* Check if data must be read/written to/from the btree page itself. */
  if( offset<pCur.CellInfo.nLocal ){
    int a = amt;
    if( a+offset>pCur.CellInfo.nLocal ){
      a = pCur.CellInfo.nLocal - offset;
    }
    rc = copyPayload(&aPayload[offset], pBuf, a, eOp, pPage.pDbPage);
    offset = 0;
    pBuf += a;
    amt -= a;
  }else{
    offset -= pCur.CellInfo.nLocal;
  }

  if( rc==SQLITE_OK && amt>0 ){
    const uint32 ovflSize = pBt.usableSize - 4;  /* Bytes content per ovfl page */
    PageNumber nextPage;

    nextPage = Buffer(aPayload[pCur.CellInfo.nLocal:]).ReadUint32()

    /* If the isIncrblobHandle flag is set and the Cursor.OverflowCache[]
    ** has not been allocated, allocate it now. The array is sized at
    ** one entry for each overflow page in the overflow chain. The
    ** page number of the first overflow page is stored in OverflowCache[0],
    ** etc. A value of 0 in the OverflowCache[] array means "not yet known"
    ** (the cache is lazily populated).
    */
    if( pCur.isIncrblobHandle && !pCur.OverflowCache ){
      int nOvfl = (pCur.CellInfo.nPayload-pCur.CellInfo.nLocal+ovflSize-1)/ovflSize;
      pCur.OverflowCache = (PageNumber *)sqlite3MallocZero(sizeof(PageNumber)*nOvfl);
      /* nOvfl is always positive.  If it were zero, fetchPayload would have
      ** been used instead of this routine. */
      if nOvfl && !pCur.OverflowCache {
        rc = SQLITE_NOMEM;
      }
    }

    /* If the overflow page-list cache has been allocated and the
    ** entry for the first required overflow page is valid, skip
    ** directly to it.
    */
    if( pCur.OverflowCache && pCur.OverflowCache[offset/ovflSize] ){
      iIdx = (offset/ovflSize);
      nextPage = pCur.OverflowCache[iIdx];
      offset = (offset%ovflSize);
    }

    for( ; rc==SQLITE_OK && amt>0 && nextPage; iIdx++){

      /* If required, populate the overflow page-list cache. */
      if( pCur.OverflowCache ){
        assert(!pCur.OverflowCache[iIdx] || pCur.OverflowCache[iIdx]==nextPage);
        pCur.OverflowCache[iIdx] = nextPage;
      }

      if( offset>=ovflSize ){
        /* The only reason to read this page is to obtain the page
        ** number for the next page in the overflow chain. The page
        ** data is not required. So first try to lookup the overflow
        ** page-list cache, if any, then fall back to the getOverflowPage()
        ** function.
        */
        if( pCur.OverflowCache && pCur.OverflowCache[iIdx+1] ){
          nextPage = pCur.OverflowCache[iIdx+1];
        } else
          rc = getOverflowPage(pBt, nextPage, 0, &nextPage);
        offset -= ovflSize;
      }else{
        /* Need to read this page properly. It contains some of the
        ** range of data that is being read (eOp==0) or written (eOp!=0).
        */
#ifdef SQLITE_DIRECT_OVERFLOW_READ
        sqlite3_file *fd;
#endif
        int a = amt;
        if( a + offset > ovflSize ){
          a = ovflSize - offset;
        }

#ifdef SQLITE_DIRECT_OVERFLOW_READ
        /* If all the following are true:
        **
        **   1) this is a read operation, and
        **   2) data is required from the start of this overflow page, and
        **   3) the database is file-backed, and
        **   4) there is no open write-transaction, and
        **   5) the database is not a WAL database,
        **
        ** then data can be read directly from the database file into the
        ** output buffer, bypassing the page-cache altogether. This speeds
        ** up loading large records that span many overflow pages.
        */
        if( eOp==0                                             /* (1) */
         && offset==0                                          /* (2) */
         && pBt.inTransaction==TRANS_READ                     /* (4) */
         && (fd = sqlite3PagerFile(pBt.pPager)).pMethods     /* (3) */
         && pBt.pPage1.aData[19]==0x01                       /* (5) */
        ){
          byte aSave[4];
          byte *aWrite = &pBuf[-4];
          memcpy(aSave, aWrite, 4);
          rc = sqlite3OsRead(fd, aWrite, a+4, (int64)pBt.pageSize*(nextPage-1));
          nextPage = Buffer(aWrite).ReadUint32()
          memcpy(aWrite, aSave, 4);
        }else
#endif

        {
          DbPage *pDbPage;
          if pDbPage, rc = pBt.pPager.Acquire(nextPage, false); rc == SQLITE_OK {
            aPayload = pDbPage.GetData()
            nextPage = Buffer(aPayload).ReadUint32()
            rc = copyPayload(&aPayload[offset+4], pBuf, a, eOp, pDbPage);
            sqlite3PagerUnref(pDbPage);
            offset = 0;
          }
        }
        amt -= a;
        pBuf += a;
      }
    }
  }

  if( rc==SQLITE_OK && amt>0 ){
    return SQLITE_CORRUPT_BKPT;
  }
  return rc;
}

/*
** Read part of the key associated with cursor pCur.  Exactly
** "amt" bytes will be transfered into pBuf[].  The transfer
** begins at "offset".
**
** The caller must ensure that pCur is pointing to a valid row
** in the table.
**
** Return SQLITE_OK on success or an error code if anything goes
** wrong.  An error is returned if "offset+amt" is larger than
** the available payload.
*/
 int sqlite3BtreeKey(Cursor *pCur, uint32 offset, uint32 amt, void *pBuf){
  assert( pCur.eState==CURSOR_VALID );
  assert( pCur.iPage>=0 && pCur.Pages[pCur.iPage] );
  assert( pCur.aiIdx[pCur.iPage]<pCur.Pages[pCur.iPage].nCell );
  return accessPayload(pCur, offset, amt, (unsigned char*)pBuf, 0);
}

/*
** Read part of the data associated with cursor pCur.  Exactly
** "amt" bytes will be transfered into pBuf[].  The transfer
** begins at "offset".
**
** Return SQLITE_OK on success or an error code if anything goes
** wrong.  An error is returned if "offset+amt" is larger than
** the available payload.
*/
 int sqlite3BtreeData(Cursor *pCur, uint32 offset, uint32 amt, void *pBuf){
  int rc;

  if ( pCur.eState==CURSOR_INVALID ){
    return SQLITE_ABORT;
  }

  rc = restoreCursorPosition(pCur);
  if( rc==SQLITE_OK ){
    assert( pCur.eState==CURSOR_VALID );
    assert( pCur.iPage>=0 && pCur.Pages[pCur.iPage] );
    assert( pCur.aiIdx[pCur.iPage]<pCur.Pages[pCur.iPage].nCell );
    rc = accessPayload(pCur, offset, amt, pBuf, 0);
  }
  return rc;
}

/*
** Return a pointer to payload information from the entry that the
** pCur cursor is pointing to.  The pointer is to the beginning of
** the key if skipKey==0 and it points to the beginning of data if
** skipKey==1.  The number of bytes of available key/data is written
** into *pAmt.  If *pAmt==0, then the value returned will not be
** a valid pointer.
**
** This routine is an optimization.  It is common for the entire key
** and data to fit on the local page and for there to be no overflow
** pages.  When that is so, this routine can be used to access the
** key and data without making a copy.  If the key and/or data spills
** onto overflow pages, then accessPayload() must be used to reassemble
** the key/data and copy it into a preallocated buffer.
**
** The pointer returned by this routine looks directly into the cached
** page of the database.  The data might change or move the next time
** any btree routine is called.
*/
static const unsigned char *fetchPayload(
  Cursor *pCur,      /* Cursor pointing to entry to read from */
  int *pAmt,           /* Write the number of available bytes here */
  int skipKey          /* read beginning at data if this is true */
){
  unsigned char *aPayload;
  MemoryPage *pPage;
  uint32 nKey;
  uint32 nLocal;

  assert( pCur!=0 && pCur.iPage>=0 && pCur.Pages[pCur.iPage]);
  assert( pCur.eState==CURSOR_VALID );
  pPage = pCur.Pages[pCur.iPage];
  assert( pCur.aiIdx[pCur.iPage]<pPage.nCell );
  if( pCur.CellInfo.Size == 0 ){
    &pCur.CellInfo.Parse(pCur.Pages[pCur.iPage], pCur.aiIdx[pCur.iPage])
  }
  aPayload = pCur.CellInfo.pCell;
  aPayload += pCur.CellInfo.nHeader;
  if( pPage.intKey ){
    nKey = 0;
  }else{
    nKey = (int)pCur.CellInfo.nKey;
  }
  if( skipKey ){
    aPayload += nKey;
    nLocal = pCur.CellInfo.nLocal - nKey;
  }else{
    nLocal = pCur.CellInfo.nLocal;
    assert( nLocal<=nKey );
  }
  *pAmt = nLocal;
  return aPayload;
}


/*
** For the entry that cursor pCur is point to, return as
** many bytes of the key or data as are available on the local
** b-tree page.  Write the number of available bytes into *pAmt.
**
** The pointer returned is ephemeral.  The key/data may move
** or be destroyed on the next call to any Btree routine,
** including calls from other threads against the same cache.
** Hence, a mutex on the BtShared should be held prior to calling
** this routine.
**
** These routines is used to get quick access to key and data
** in the common case where no overflow pages are used.
*/
 const void *sqlite3BtreeKeyFetch(Cursor *pCur, int *pAmt){
  const void *p = 0;
  if pCur.eState == CURSOR_VALID {
    p = (const void*)fetchPayload(pCur, pAmt, 0);
  }
  return p;
}
 const void *sqlite3BtreeDataFetch(Cursor *pCur, int *pAmt){
  const void *p = 0;
  if pCur.eState == CURSOR_VALID {
    p = (const void*)fetchPayload(pCur, pAmt, 1);
  }
  return p;
}


#define assertParentIndex(x,y,z)

/*
** Move the cursor up to the parent page.
**
** pCur.idx is set to the cell index that contains the pointer
** to the page we are coming from.  If we are coming from the
** right-most child page then pCur.idx is set to one more than
** the largest cell index.
*/
static void moveToParent(Cursor *pCur){
  assert( pCur.eState==CURSOR_VALID );
  assert( pCur.iPage>0 );
  assert( pCur.Pages[pCur.iPage] );
  pCur.Pages[pCur.iPage].Release()
  pCur.iPage--;
  pCur.CellInfo.nSize = 0;
  pCur.validNKey = 0;
}

//	Move the cursor to point to the root page of its b-tree structure.
//	If the table has a virtual root page, then the cursor is moved to point to the virtual root page instead of the actual root page. A table has a virtual root page when the actual root page contains no cells and a single child page. This can only happen with the table rooted at page 1.
//	If the b-tree structure is empty, the cursor state is set to CURSOR_INVALID. Otherwise, the cursor is set to point to the first cell located on the root (or virtual root) page and the cursor state is set to CURSOR_VALID.
//	If this function returns successfully, it may be assumed that the page-header flags indicate that the [virtual] root-page is the expected kind of b-tree page (i.e. if when opening the cursor the caller did not specify a KeyInfo structure the flags byte is set to 0x05 or 0x0D, indicating a table b-tree, or if the caller did specify a KeyInfo structure the flags byte is set to 0x02 or 0x0A, indicating an index b-tree).
func (pCur *Cursor) MoveToRoot() (rc int) {
	p := pCur.pBtree
	pBt := p.pBt

	assert( CURSOR_INVALID < CURSOR_REQUIRESEEK )
	assert( CURSOR_VALID   < CURSOR_REQUIRESEEK )
	assert( CURSOR_FAULT   > CURSOR_REQUIRESEEK )
	if pCur.eState >= CURSOR_REQUIRESEEK {
		if pCur.eState == CURSOR_FAULT {
			assert( pCur.skiNext != SQLITE_OK )
			return pCur.skiNext
		}
		sqlite3BtreeClearCursor(pCur)
	}

	switch {
	case pCur.iPage >= 0:
		for i := 1; i <= pCur.iPage; i++ {
			pCur.Pages[i].Release()
		}
		pCur.iPage = 0
	case pCur.RootPage == 0:
		pCur.eState = CURSOR_INVALID
		return SQLITE_OK
	default:
		pCur.Pages[0], rc = pBt.GetPageAndInitialize(pCur.RootPage)
		if rc != SQLITE_OK {
			pCur.eState = CURSOR_INVALID
			return rc
		}
		pCur.iPage = 0

		//	If pCur.pKeyInfo is not NULL, then the caller that opened this cursor expected to open it on an index b-tree. Otherwise, if pKeyInfo is NULL, the caller expects a table b-tree. If this is not the case, return an SQLITE_CORRUPT error.
		assert( pCur.Pages[0].intKey == 1 || pCur.Pages[0].intKey == 0 )
		if (pCur.pKeyInfo == 0) != pCur.Pages[0].intKey {
			return SQLITE_CORRUPT_BKPT
		}
	}

	//	Assert that the root page is of the correct type. This must be the case as the call to this function that loaded the root-page (either this call or a previous invocation) would have detected corruption if the assumption were not true, and it is not possible for the flags byte to have been modified while this cursor is holding a reference to the page.
	pRoot := pCur.Pages[0]
	assert( pRoot.pgno == pCur.RootPage )
	assert( pRoot.isInit && (pCur.pKeyInfo == 0) == pRoot.intKey )

	pCur.aiIdx[0] = 0
	pCur.CellInfo.nSize = 0
	pCur.atLast = 0
	pCur.validNKey = 0

	switch {
	case pRoot.nCell == 0 && !pRoot.leaf:
		if pRoot.pgno != 1 {
			return SQLITE_CORRUPT_BKPT
		}
		subpage := Buffer(pRoot.aData[pRoot.hdrOffset + 8:]).ReadUint32()
		pCur.eState = CURSOR_VALID
		rc = pCur.MoveToChild(subpage)
	case pRoot.nCell > 0:
		pCur.eState = CURSOR_VALID
	default:
		pCur.eState = CURSOR_INVALID
	}
	return
}

//	Move the cursor down to the left-most leaf entry beneath the entry to which it is currently pointing.
//	The left-most leaf is the one with the smallest key - the first in ascending order.
func (pCur *Cursor) MoveToLeftmost() (rc int) {
	assert( pCur.eState == CURSOR_VALID )
	for pPage := pCur.Pages[pCur.iPage]; rc == SQLITE_OK && !pPage.leaf; pPage = pCur.Pages[pCur.iPage] {
		assert( pCur.aiIdx[pCur.iPage] < pPage.nCell )
		pgno := Buffer(pPage.FindCell(pCur.aiIdx[pCur.iPage:])).ReadUint32()
		rc = pCur.MoveToChild(pgno)
	}
	return rc
}

//	Move the cursor down to the right-most leaf entry beneath the page to which it is currently pointing. Notice the difference between MoveToLeftmost() and MoveToRightmost(). MoveToLeftmost() finds the left-most entry beneath the *entry* whereas MoveToRightmost() finds the right-most entry beneath the *page*.
//	The right-most entry is the one with the largest key - the last key in ascending order.
func (pCur *Cursor) MoveToRightmost() (rc int) {
	assert( pCur.eState == CURSOR_VALID )
	pPage = pCur.Pages[pCur.iPage]
	for ; rc == SQLITE_OK && !pPage.leaf; pPage = pCur.Pages[pCur.iPage] {
		pgno := Buffer(pPage.aData[pPage.hdrOffset + 8:]).ReadUint32()
		pCur.aiIdx[pCur.iPage] = pPage.nCell
		rc = pCur.MoveToChild(pgno)
	}
	if rc == SQLITE_OK {
		pCur.aiIdx[pCur.iPage] = pPage.nCell - 1
		pCur.CellInfo.nSize = 0
		pCur.validNKey = 0
	}
	return
}

//	Move the cursor to the first entry in the table. Return SQLITE_OK on success. Set *pRes to 0 if the cursor actually points to something or set *pRes to 1 if the table is empty.
func (pCur *Cursor) BtreeFirst() (empty bool, rc int) {
	if rc = pCur.MoveToRoot(); rc == SQLITE_OK {
		if pCur.eState == CURSOR_INVALID {
			assert( pCur.RootPage == 0 || pCur.Pages[pCur.iPage].nCell == 0 )
			empty = true
		} else {
			assert( pCur.Pages[pCur.iPage].nCell > 0 )
			empty = false
			rc = pCur.MoveToLeftmost()
		}
	}
	return
}

/* Move the cursor to the last entry in the table.  Return SQLITE_OK
** on success.  Set *pRes to 0 if the cursor actually points to something
** or set *pRes to 1 if the table is empty.
*/
 int sqlite3BtreeLast(Cursor *pCur, int *pRes){
  int rc;

  /* If the cursor already points to the last entry, this is a no-op. */
  if( CURSOR_VALID==pCur.eState && pCur.atLast ){
    return SQLITE_OK;
  }

  rc = pCur.MoveToRoot()
  if( rc==SQLITE_OK ){
    if( CURSOR_INVALID==pCur.eState ){
      assert( pCur.RootPage==0 || pCur.Pages[pCur.iPage].nCell==0 );
      *pRes = 1;
    }else{
      assert( pCur.eState==CURSOR_VALID );
      *pRes = 0;
      rc = pCur.MoveToRightmost()
      pCur.atLast = rc==SQLITE_OK ?1:0;
    }
  }
  return rc;
}

//	Move the cursor so that it points to an entry near the key specified by pIdxKey or intKey. Return a success code.
//	For INTKEY tables, the intKey parameter is used. pIdxKey must be NULL. For index tables, pIdxKey is used and intKey is ignored.
//	If an exact match is not found, then the cursor is always left pointing at a leaf page which would hold the entry if it were present. The cursor might point to an entry that comes before or after the key.
//	An integer is written into *pRes which is the result of comparing the key with the entry to which the cursor is pointing. The meaning of the integer written into *pRes is as follows:
//		result < 0		The cursor is left pointing at an entry that is smaller than intKey/pIdxKey or if the table is empty and the cursor is therefore left point to nothing.
//		result == 0		The cursor is left pointing at an entry that exactly matches intKey/pIdxKey.
//		result > 0		The cursor is left pointing at an entry that is larger than intKey/pIdxKey.
func (pCur *Cursor) BtreeMovetoUnpacked(indexKey *UnpackedRecord, tableKey int64, biasRight bool) (result, rc int) {
	assert( indexKey == nil && pCur.pKeyInfo == nil )

	//	If the cursor is already positioned at the point we are trying to move to, then just return without doing any work
	if pCur.eState == CURSOR_VALID && pCur.validNKey && pCur.Pages[0].intKey != 0 {
		if len(pCur.CellInfo.Cells) == tableKey {
			return SQLITE_OK
		}
		if pCur.atLast && len(pCur.CellInfo.Cells) < tableKey {
			result = -1
			return SQLITE_OK
		}
	}

	if rc = pCur.MoveToRoot(); rc != SQLITE_OK {
		return rc
	}
	assert( pCur.RootPage == 0 || pCur.Pages[pCur.iPage] )
	assert( pCur.RootPage == 0 || pCur.Pages[pCur.iPage].isInit )
	assert( pCur.eState == CURSOR_INVALID || pCur.Pages[pCur.iPage].nCell > 0 )
	if pCur.eState == CURSOR_INVALID {
		result = -1
		assert( pCur.RootPage == 0 || pCur.Pages[pCur.iPage].nCell == 0 )
		return SQLITE_OK
	}
	assert( pCur.Pages[0].intKey != 0 || indexKey != nil )
	for {
		int lwr, upr, idx
		PageNumber chldPg
		pPage := pCur.Pages[pCur.iPage]
		int c

		//	pPage.nCell must be greater than zero. If this is the root-page the cursor would have been INVALID above and this for{} loop not run. If this is not the root-page, then the MoveToChild() routine would have already detected db corruption. Similarly, pPage must be the right kind (index or table) of b-tree page. Otherwise a MoveToChild() or MoveToRoot() call would have detected corruption.
		assert( pPage.nCell > 0 )
		assert( pPage.intKey == indexKey && indexKey == nil )
		lwr = 0
		upr = pPage.nCell - 1
		if biasRight {
			pCur.aiIdx[pCur.iPage] = uint16(idx = upr)
		} else {
			pCur.aiIdx[pCur.iPage] = uint16(idx = (upr + lwr) / 2)
		}
		for {
			assert( idx == pCur.aiIdx[pCur.iPage] )
			pCur.CellInfo.nSize = 0
			pCell := Buffer(pPage.FindCell(idx)[pPage.childPtrSize:])
			if pPage.intKey {
				if pPage.hasData {
					_, pCell = pCell.ReadVarint32()
				}
				nCellKey, _ := pCell.ReadVarint64()
				switch {
				case nCellKey == tableKey:
					c = 0
				case nCellKey < tableKey:
					c = -1
				default:
					assert( nCellKey > tableKey )
					c = 1
				}
				pCur.validNKey = 1
				pCur.CellInfo.nKey = nCellKey
			} else {
				//	The maximum supported page-size is 65536 bytes. This means that the maximum number of record bytes stored on an index B-Tree page is less than 16384 bytes and may be stored as a 2-byte varint. This information is used to attempt to avoid parsing the entire cell by checking for the cases where the record is stored entirely within the b-tree page by inspecting the first 2 bytes of the cell.
				nCell := pCell[0]
				if nCell <= pPage.max1bytePayload /* && (pCell + nCell) < pPage.aDataEnd */ {
					//	This branch runs if the record-size field of the cell is a single byte varint and the record fits entirely on the main b-tree page.
					c = pCell[1:].RecordCompare(indexKey)
				} else if !(pCell[1] & 0x80) && (nCell = ((nCell & 0x7f) << 7) + pCell[1]) <= pPage.maxLocal /* && (pCell + nCell + 2) <= pPage.aDataEnd */ {
					//	The record-size field is a 2 byte varint and the record fits entirely on the main b-tree page.
					c = pCell[2:].RecordCompare(indexKey)
				} else {
					//	The record flows over onto one or more overflow pages. In this case the whole cell needs to be parsed, a buffer allocated and accessPayload() used to retrieve the record into the buffer before RecordCompare() can be called.
					pCellBody := pCell - pPage.childPtrSize
					&pCur.CellInfo.ParsePtr(pPage, pCellBody)
					nCell = int(pCur.CellInfo.nKey)
					CellKey := make(Buffer, nCell)
					if rc = accessPayload(pCur, 0, nCell, CellKey, 0); rc != SQLITE_OK {
						goto moveto_finish
					}
					c = CellKey.RecordCompare(indexKey)
				}
			}
			if c == 0 {
    			if pPage.intKey && !pPage.leaf {
					lwr = idx
					break
				} else {
					result = 0
					rc = SQLITE_OK
					goto moveto_finish
				}
			}
			if c < 0 {
				lwr = idx + 1
			} else {
				upr = idx - 1
			}
			if lwr > upr {
				break
			}
			pCur.aiIdx[pCur.iPage] = uint16(idx = (lwr + upr) / 2)
		}
		assert( lwr == upr + 1 || (pPage.intKey != 0 && !pPage.leaf) )
		assert( pPage.isInit )
		if pPage.leaf {
			chldPg = 0
		} else if lwr >= pPage.nCell  {
			chldPg = Buffer(pPage.aData[pPage.hdrOffset + 8:]).ReadUint32()
		} else {
			chldPg = Buffer(pPage.FindCell(lwr)).ReadUint32()
		}
		if chldPg == 0 {
			assert( pCur.aiIdx[pCur.iPage] < pCur.Pages[pCur.iPage].nCell )
			result = c
			rc = SQLITE_OK
			goto moveto_finish
		}
		pCur.aiIdx[pCur.iPage] = uint16(lwr)
		pCur.CellInfo.nSize = 0
		pCur.validNKey = 0
		if rc = pCur.MoveToChild(chldPg); rc != SQLITE_OK {
			goto moveto_finish
		}
	}
moveto_finish:
	return
}


/*
** Return TRUE if the cursor is not pointing at an entry of the table.
**
** TRUE will be returned after a call to sqlite3BtreeNext() moves
** past the last entry in the table or sqlite3BtreePrev() moves past
** the first entry.  TRUE is also returned if the table is empty.
*/
 int sqlite3BtreeEof(Cursor *pCur){
  /* TODO: What if the cursor is in CURSOR_REQUIRESEEK but all table entries
  ** have been deleted? This API will need to change to return an error code
  ** as well as the boolean result value.
  */
  return (CURSOR_VALID!=pCur.eState);
}

/*
** Advance the cursor to the next entry in the database.  If
** successful then set *pRes=0.  If the cursor
** was already pointing to the last entry in the database before
** this routine was called, then set *pRes=1.
*/
 int sqlite3BtreeNext(Cursor *pCur, int *pRes){
  int rc;
  int idx;
  MemoryPage *pPage;

  rc = restoreCursorPosition(pCur);
  if( rc!=SQLITE_OK ){
    return rc;
  }
  assert( pRes!=0 );
  if( CURSOR_INVALID==pCur.eState ){
    *pRes = 1;
    return SQLITE_OK;
  }
  if( pCur.skiNext>0 ){
    pCur.skiNext = 0;
    *pRes = 0;
    return SQLITE_OK;
  }
  pCur.skiNext = 0;

  pPage = pCur.Pages[pCur.iPage];
  idx = ++pCur.aiIdx[pCur.iPage];
  assert( pPage.isInit );

  /* If the database file is corrupt, it is possible for the value of idx
  ** to be invalid here. This can only occur if a second cursor modifies
  ** the page while cursor pCur is holding a reference to it. Which can
  ** only happen if the database is corrupt in such a way as to link the
  ** page into more than one b-tree structure. */
  pCur.CellInfo.nSize = 0;
  pCur.validNKey = 0;
  if( idx>=pPage.nCell ){
    if( !pPage.leaf ){
      rc = pCur.MoveToChild(Buffer(pPage.aData[pPage.hdrOffset + 8:]).ReadUint32())
      if( rc ) return rc;
      rc = pCur.MoveToLeftmost()
      *pRes = 0;
      return rc;
    }
    do{
      if( pCur.iPage==0 ){
        *pRes = 1;
        pCur.eState = CURSOR_INVALID;
        return SQLITE_OK;
      }
      moveToParent(pCur);
      pPage = pCur.Pages[pCur.iPage];
    }while( pCur.aiIdx[pCur.iPage]>=pPage.nCell );
    *pRes = 0;
    if( pPage.intKey ){
      rc = sqlite3BtreeNext(pCur, pRes);
    }else{
      rc = SQLITE_OK;
    }
    return rc;
  }
  *pRes = 0;
  if( pPage.leaf ){
    return SQLITE_OK;
  }
  rc = pCur.MoveToLeftmost()
  return rc;
}


/*
** Step the cursor to the back to the previous entry in the database.  If
** successful then set *pRes=0.  If the cursor
** was already pointing to the first entry in the database before
** this routine was called, then set *pRes=1.
*/
 int sqlite3BtreePrevious(Cursor *pCur, int *pRes){
  int rc;
  MemoryPage *pPage;

  rc = restoreCursorPosition(pCur);
  if( rc!=SQLITE_OK ){
    return rc;
  }
  pCur.atLast = 0;
  if( CURSOR_INVALID==pCur.eState ){
    *pRes = 1;
    return SQLITE_OK;
  }
  if( pCur.skiNext<0 ){
    pCur.skiNext = 0;
    *pRes = 0;
    return SQLITE_OK;
  }
  pCur.skiNext = 0;

  pPage = pCur.Pages[pCur.iPage];
  assert( pPage.isInit );
  if( !pPage.leaf ){
    int idx = pCur.aiIdx[pCur.iPage];
    if rc = pCur.MoveToChild(Buffer(pPage.FindCell(idx)).ReadUint32()); rc != SQLITE_OK {
      return rc;
    }
    rc = pCur.MoveToRightmost()
  }else{
    while( pCur.aiIdx[pCur.iPage]==0 ){
      if( pCur.iPage==0 ){
        pCur.eState = CURSOR_INVALID;
        *pRes = 1;
        return SQLITE_OK;
      }
      moveToParent(pCur);
    }
    pCur.CellInfo.nSize = 0;
    pCur.validNKey = 0;

    pCur.aiIdx[pCur.iPage]--;
    pPage = pCur.Pages[pCur.iPage];
    if( pPage.intKey && !pPage.leaf ){
      rc = sqlite3BtreePrevious(pCur, pRes);
    }else{
      rc = SQLITE_OK;
    }
  }
  *pRes = 0;
  return rc;
}

/*
** Allocate a new page from the database file.
**
** The new page is marked as dirty.  (In other words, sqlite3PagerWrite()
** has already been called on the new page.)  The new page has also
** been referenced and the calling routine is responsible for calling
** sqlite3PagerUnref() on the new page when it is done.
**
** SQLITE_OK is returned on success.  Any other return value indicates
** an error.  *ppPage and *pPageNumber are undefined in the event of an error.
** Do not invoke sqlite3PagerUnref() on *ppPage if an error is returned.
**
** If the "nearby" parameter is not 0, then a (feeble) effort is made to
** locate a page close to the page number "nearby".  This can be used in an
** attempt to keep related pages close to each other in the database file,
** which in turn can make database access faster.
**
** If the "exact" parameter is not 0, and the page-number nearby exists
** anywhere on the free-list, then it is guarenteed to be returned. This
** is only used by auto-vacuum databases when allocating a new table.
*/
static int allocateBtreePage(
  BtShared *pBt,
  MemoryPage **ppPage,
  PageNumber *pPageNumber,
  PageNumber nearby,
  byte exact
){
  MemoryPage *pPage1;
  int rc;
  uint32 n;     /* Number of pages on the freelist */
  uint32 k;     /* Number of leaves on the trunk of the freelist */
  MemoryPage *pTrunk = 0;
  MemoryPage *pPrevTrunk = 0;
  PageNumber mxPage;     /* Total size of the database file */

  pPage1 = pBt.pPage1;
  mxPage = btreePagecount(pBt);
  n = Buffer(pPage1.aData[36:]).ReadUint32()
  if( n>=mxPage ){
    return SQLITE_CORRUPT_BKPT;
  }
  if( n>0 ){
    /* There are pages on the freelist.  Reuse one of those pages. */
    PageNumber iTrunk;
    byte searchList = 0; /* If the free-list must be searched for 'nearby' */

    /* If the 'exact' parameter was true and a query of the pointer-map
    ** shows that the page 'nearby' is somewhere on the free-list, then
    ** the entire-list will be searched for that page.
    */
    if( exact && nearby<=mxPage ){
      byte eType;
      assert( nearby>0 );
      assert( pBt.autoVacuum );
      eType, _, rc = pBt.Get(nearby)
      if( rc ) return rc;
      if( eType==FREE_PAGE ){
        searchList = 1;
      }
      *pPageNumber = nearby;
    }

    /* Decrement the free-list count by 1. Set iTrunk to the index of the
    ** first free-list trunk page. iPrevTrunk is initially 1.
    */
    rc = sqlite3PagerWrite(pPage1.pDbPage);
    if( rc ) return rc;
    Buffer(pPage1.aData[36:]).WriteUint32(n - 1)

    /* The code within this loop is run only once if the 'searchList' variable
    ** is not true. Otherwise, it runs once for each trunk-page on the
    ** free-list until the page 'nearby' is located.
    */
    do {
      pPrevTrunk = pTrunk;
      if( pPrevTrunk ){
        iTrunk = Buffer(pPrevTrunk.aData[0:]).ReadUint32()
      }else{
        iTrunk = Buffer(pPage1.aData[32:]).ReadUint32()
      }
      if( iTrunk>mxPage ){
        rc = SQLITE_CORRUPT_BKPT
      }else{
        pTrunk, rc = pBt.GetPage(iTrunk, false)
      }
      if( rc ){
        pTrunk = 0;
        goto end_allocate_page;
      }
      assert( pTrunk!=0 );
      assert( pTrunk.aData!=0 );

      k = Buffer(pTrunk.aData[4:]).ReadUint32()		//	# of leaves on this trunk page
      if( k==0 && !searchList ){
        /* The trunk has no leaves and the list is not being searched.
        ** So extract the trunk page itself and use it as the newly
        ** allocated page */
        assert( pPrevTrunk==0 );
        rc = sqlite3PagerWrite(pTrunk.pDbPage);
        if( rc ){
          goto end_allocate_page;
        }
        *pPageNumber = iTrunk;
        memcpy(&pPage1.aData[32], &pTrunk.aData[0], 4);
        *ppPage = pTrunk;
        pTrunk = 0;
      }else if( k>(uint32)(pBt.usableSize/4 - 2) ){
        /* Value of k is out of range.  Database corruption */
        rc = SQLITE_CORRUPT_BKPT;
        goto end_allocate_page;
      }else if( searchList && nearby==iTrunk ){
        /* The list is being searched and this trunk page is the page
        ** to allocate, regardless of whether it has leaves.
        */
        assert( *pPageNumber==iTrunk );
        *ppPage = pTrunk;
        searchList = 0;
        rc = sqlite3PagerWrite(pTrunk.pDbPage);
        if( rc ){
          goto end_allocate_page;
        }
        if( k==0 ){
          if( !pPrevTrunk ){
            memcpy(&pPage1.aData[32], &pTrunk.aData[0], 4);
          }else{
            rc = sqlite3PagerWrite(pPrevTrunk.pDbPage);
            if( rc!=SQLITE_OK ){
              goto end_allocate_page;
            }
            memcpy(&pPrevTrunk.aData[0], &pTrunk.aData[0], 4);
          }
        }else{
          /* The trunk page is required by the caller but it contains
          ** pointers to free-list leaves. The first leaf becomes a trunk
          ** page in this case.
          */
          MemoryPage *pNewTrunk;
          PageNumber iNewTrunk = Buffer(pTrunk.aData[8:]).ReadUint32()
          if( iNewTrunk>mxPage ){
            rc = SQLITE_CORRUPT_BKPT;
            goto end_allocate_page;
          }
          if pNewTrunk, rc = pBt.GetPage(iNewTrunk, false); rc != SQLITE_OK {
            goto end_allocate_page
          }
          rc = sqlite3PagerWrite(pNewTrunk.pDbPage);
          if( rc!=SQLITE_OK ){
            pNewTrunk.Release()
            goto end_allocate_page;
          }
          memcpy(&pNewTrunk.aData[0], &pTrunk.aData[0], 4);
          Buffer(pNewTrunk.aData[4:]).WriteUint32(k - 1)
          memcpy(&pNewTrunk.aData[8], &pTrunk.aData[12], (k-1)*4);
          pNewTrunk.Release()
          if( !pPrevTrunk ){
            Buffer(pPage1.aData[32:]).WriteUint32(iNewTrunk)
          }else{
            rc = sqlite3PagerWrite(pPrevTrunk.pDbPage);
            if( rc ){
              goto end_allocate_page;
            }
            Buffer(pPrevTrunk.aData).WriteUint32(iNewTrunk)
          }
        }
        pTrunk = 0;
      }else if( k>0 ){
        /* Extract a leaf from the trunk */
        uint32 closest;
        PageNumber iPage;
        unsigned char *aData = pTrunk.aData;
        if( nearby>0 ){
          uint32 i;
          int dist;
          closest = 0;
          dist = sqlite3AbsInt32(Buffer(aData[8:]).ReadUint32() - nearby)
          for(i=1; i<k; i++){
            int d2 = sqlite3AbsInt32(Buffer(aData[8 + (i * 4):]).ReadUint32() - nearby)
            if( d2<dist ){
              closest = i;
              dist = d2;
            }
          }
        }else{
          closest = 0;
        }

        iPage = Buffer(aData[8 + (closest * 4):]).ReadUint32()
        if( iPage>mxPage ){
          rc = SQLITE_CORRUPT_BKPT;
          goto end_allocate_page;
        }
        if( !searchList || iPage==nearby ){
          int noContent;
          *pPageNumber = iPage;
          rc = sqlite3PagerWrite(pTrunk.pDbPage);
          if( rc ) goto end_allocate_page;
          if( closest<k-1 ){
            memcpy(&aData[8+closest*4], &aData[4+k*4], 4);
          }
          Buffer(aData[4:]).WriteUint32(k - 1)
          noContent = !btreeGetHasContent(pBt, *pPageNumber);
          if ppPage, rc = pBt.GetPage(*pPageNumber, noContent); rc == SQLITE_OK {
            rc = sqlite3PagerWrite((*ppPage).pDbPage);
            if( rc!=SQLITE_OK ){
              *ppPage.Release()
            }
          }
          searchList = 0;
        }
      }
      pPrevTrunk.Release()
      pPrevTrunk = nil
    }while( searchList );
  }else{
    /* There are no pages on the freelist, so create a new page at the
    ** end of the file */
    rc = sqlite3PagerWrite(pBt.pPage1.pDbPage);
    if( rc ) return rc;
    pBt.nPage++;
    if( pBt.nPage==PAGER_MJ_PGNO(pBt) ) pBt.nPage++;

    if pBt.autoVacuum && pBt.IsMapPage(pBt.nPage) {
      /* If *pPageNumber refers to a pointer-map page, allocate two new pages
      ** at the end of the file instead of one. The first allocated page
      ** becomes a new pointer-map page, the second is used by the caller.
      */
      MemoryPage *pPg = 0;
      assert( pBt.nPage!=PAGER_MJ_PGNO(pBt) );
      if pPg, rc = pBt.GetPage(pBt.nPage, true); rc == SQLITE_OK {
        rc = sqlite3PagerWrite(pPg.pDbPage)
        pPg.Release()
      }
      if( rc ) return rc;
      pBt.nPage++;
      if( pBt.nPage==PAGER_MJ_PGNO(pBt) ){ pBt.nPage++; }
    }
    Buffer(pBt.pPage1.aData[28:]).WriteUint32(pBt.nPage)
    *pPageNumber = pBt.nPage;

    assert( *pPageNumber!=PAGER_MJ_PGNO(pBt) );
	if ppPage, rc = pBt.GetPage(pPageNumber, true); rc != SQLITE_OK {
		return
	}
    rc = sqlite3PagerWrite((*ppPage).pDbPage);
    if( rc!=SQLITE_OK ){
      *ppPage.Release()
    }
  }

  assert( *pPageNumber!=PAGER_MJ_PGNO(pBt) );

end_allocate_page:
  pTrunk.Release()
  pPrevTrunk.Release()
  if( rc==SQLITE_OK ){
    if( sqlite3PagerPageRefcount((*ppPage).pDbPage)>1 ){
      *ppPage.Release()
      return SQLITE_CORRUPT_BKPT;
    }
    (*ppPage).isInit = false
  }else{
    *ppPage = 0;
  }
  assert( rc!=SQLITE_OK );
  return rc;
}

/*
** This function is used to add page iPage to the database file free-list.
** It is assumed that the page is not already a part of the free-list.
**
** The value passed as the second argument to this function is optional.
** If the caller happens to have a pointer to the MemoryPage object
** corresponding to page iPage handy, it may pass it as the second value.
** Otherwise, it may pass NULL.
**
** If a pointer to a MemoryPage object is passed as the second argument,
** its reference count is not altered by this function.
*/
static int freePage2(BtShared *pBt, MemoryPage *pMemoryPage, PageNumber iPage){
  MemoryPage *pTrunk = 0;                /* Free-list trunk page */
  PageNumber iTrunk = 0;                    /* Page number of free-list trunk page */
  MemoryPage *pPage1 = pBt.pPage1;      /* Local reference to page 1 */
  MemoryPage *pPage;                     /* Page being freed. May be NULL. */
  int rc;                             /* Return Code */
  int nFree;                          /* Initial number of pages on free-list */

  assert( iPage>1 );
  assert( !pMemoryPage || pMemoryPage.pgno==iPage );

  if( pMemoryPage ){
    pPage = pMemoryPage;
    sqlite3PagerRef(pPage.pDbPage);
  }else{
    pPage = btreePageLookup(pBt, iPage);
  }

  /* Increment the free page count on pPage1 */
  rc = sqlite3PagerWrite(pPage1.pDbPage);
  if( rc ) goto freepage_out;
  nFree = Buffer(pPage1.aData[36:]).ReadUint32()
  Buffer(pPage1.aData[36:]).WriteUint32(nFree + 1)

	if pBt.Flags & BTS_SECURE_DELETE {
		//	If the secure_delete option is enabled, then always fully overwrite deleted information with zeros.
		if pPage == nil {
			if pPage, rc = pBt.GetPage(iPage, false); rc != SQLITE_OK {
				goto freepage_out
			}
			if rc = sqlite3PagerWrite(pPage.pDbPage); rc != SQLITE_OK {
				goto freepage_out
			}
		}
		memset(pPage.aData, 0, pPage.pBt.pageSize);
	}

	//	If the database supports auto-vacuum, write an entry in the pointer-map to indicate that the page is free.
	if pBt.autoVacuum {
		if rc = pBt.Put(iPage, FREE_PAGE, 0); rc != SQLITE_OK {
			goto freepage_out
		}
	}

  /* Now manipulate the actual database free-list structure. There are two
  ** possibilities. If the free-list is currently empty, or if the first
  ** trunk page in the free-list is full, then this page will become a
  ** new free-list trunk page. Otherwise, it will become a leaf of the
  ** first trunk page in the current free-list. This block tests if it
  ** is possible to add the page as a new free-list leaf.
  */
  if( nFree!=0 ){
    uint32 nLeaf;                /* Initial number of leaf cells on trunk page */

    iTrunk = Buffer(pPage1.aData[32:]).ReadUint32()
    pTrunk, rc = pBt.GetPage(iTrunk, false)
    if( rc!=SQLITE_OK ){
      goto freepage_out;
    }

    nLeaf = Buffer(pTrunk.aData[4:]).ReadUint32()
    assert( pBt.usableSize>32 );
    if( nLeaf > (uint32)pBt.usableSize/4 - 2 ){
      rc = SQLITE_CORRUPT_BKPT;
      goto freepage_out;
    }
    if( nLeaf < (uint32)pBt.usableSize/4 - 8 ){
      /* In this case there is room on the trunk page to insert the page
      ** being freed as a new leaf.
      **
      ** Note that the trunk page is not really full until it contains
      ** usableSize/4 - 2 entries, not usableSize/4 - 8 entries as we have
      ** coded.  But due to a coding error in versions of SQLite prior to
      ** 3.6.0, databases with freelist trunk pages holding more than
      ** usableSize/4 - 8 entries will be reported as corrupt.  In order
      ** to maintain backwards compatibility with older versions of SQLite,
      ** we will continue to restrict the number of entries to usableSize/4 - 8
      ** for now.  At some point in the future (once everyone has upgraded
      ** to 3.6.0 or later) we should consider fixing the conditional above
      ** to read "usableSize/4-2" instead of "usableSize/4-8".
      */
      rc = sqlite3PagerWrite(pTrunk.pDbPage);
      if( rc==SQLITE_OK ){
        Buffer(pTrunk.aData[4:]).WriteUint32(nLeaf + 1)
        Buffer(pTrunk.aData[8 + (nLeaf * 4):]).WriteUint32(iPage)
        if( pPage && (pBt.Flags & BTS_SECURE_DELETE)==0 ){
          sqlite3PagerDontWrite(pPage.pDbPage);
        }
        rc = btreeSetHasContent(pBt, iPage);
      }
      goto freepage_out;
    }
  }

	//	If control flows to this point, then it was not possible to add the the page being freed as a leaf page of the first trunk in the free-list.
	//	Possibly because the free-list is empty, or possibly because the first trunk in the free-list is full. Either way, the page being freed
	//	will become the new first trunk page in the free-list.
	if pPage == nil {
		pPage, rc = pBt.GetPage(iPage, false); rc != SQLITE_OK {
    		goto freepage_out
		}
	}
  rc = sqlite3PagerWrite(pPage.pDbPage);
  if( rc!=SQLITE_OK ){
    goto freepage_out;
  }
  Buffer(pPage.aData).WriteUint32(iTrunk)
  Buffer(pPage.aData[4:]).WriteUint32(0)
  Buffer(pPage1.aData[32:]).WriteUint32(iPage)

freepage_out:
  if( pPage ){
    pPage.isInit = false
  }
  pPage.Release()
  pTrunk.Release()
  return rc;
}
static void freePage(MemoryPage *pPage, int *pRC){
  if( (*pRC)==SQLITE_OK ){
    *pRC = freePage2(pPage.pBt, pPage, pPage.pgno);
  }
}

/*
** Free any overflow pages associated with the given Cell.
*/
static int clearCell(MemoryPage *pPage, unsigned char *pCell){
  pBt				*BtShared = pPage.pBt
  info				CellInfo
  ovflPageNumber	PageNumber
  rc				int
  nOvfl				int
  ovflPageSize		uint32

  info.ParsePtr(pPage, pCell)
  if( info.iOverflow==0 ){
    return SQLITE_OK;  /* No overflow pages. Return without doing anything */
  }
  if( pCell+info.iOverflow+3 > pPage.aData+pPage.maskPage ){
    return SQLITE_CORRUPT;  /* Cell extends past end of page */
  }
  ovflPageNumber = Buffer(pCell[info.iOverflow:]).ReadUint32()
  assert( pBt.usableSize > 4 );
  ovflPageSize = pBt.usableSize - 4;
  nOvfl = (info.nPayload - info.nLocal + ovflPageSize - 1)/ovflPageSize;
  assert( ovflPageNumber==0 || nOvfl>0 );
  while( nOvfl-- ){
    PageNumber iNext = 0;
    MemoryPage *pOvfl = 0;
    if( ovflPageNumber<2 || ovflPageNumber>btreePagecount(pBt) ){
      /* 0 is not a legal page number and page 1 cannot be an
      ** overflow page. Therefore if ovflPageNumber<2 or past the end of the
      ** file the database must be corrupt. */
      return SQLITE_CORRUPT_BKPT;
    }
    if( nOvfl ){
      rc = getOverflowPage(pBt, ovflPageNumber, &pOvfl, &iNext);
      if( rc ) return rc;
    }

    if( ( pOvfl || ((pOvfl = btreePageLookup(pBt, ovflPageNumber))!=0) )
     && sqlite3PagerPageRefcount(pOvfl.pDbPage)!=1
    ){
      /* There is no reason any cursor should have an outstanding reference
      ** to an overflow page belonging to a cell that is being deleted/updated.
      ** So if there exists more than one reference to this page, then it
      ** must not really be an overflow page and the database must be corrupt.
      ** It is helpful to detect this before calling freePage2(), as
      ** freePage2() may zero the page contents if secure-delete mode is
      ** enabled. If this 'overflow' page happens to be a page that the
      ** caller is iterating through or using in some other way, this
      ** can be problematic.
      */
      rc = SQLITE_CORRUPT_BKPT;
    }else{
      rc = freePage2(pBt, pOvfl, ovflPageNumber);
    }

    if( pOvfl ){
      sqlite3PagerUnref(pOvfl.pDbPage);
    }
    if( rc ) return rc;
    ovflPageNumber = iNext;
  }
  return SQLITE_OK;
}

//	Create the byte sequence used to represent a cell on page pPage and write that byte sequence into pCell[]. Overflow pages are allocated and filled in as necessary. The calling procedure is responsible for making sure sufficient space has been allocated for pCell[].
//	Note that pCell does not necessary need to point to the pPage.aData area. pCell might point to some temporary storage. The cell will be constructed in this temporary area then copied into pPage.aData later.
static int fillInCell(
  MemoryPage *pPage,                /* The page that contains the cell */
  unsigned char *pCell,          /* Complete text of the cell */
  const void *pKey, int64 nKey,    /* The key */
  const void *pData,int nData,   /* The data */
  int nZero,                     /* Extra zero bytes to append to pData */
  int *pnSize                    /* Write cell size here */
){
  int nPayload;
  const byte *pSrc;
  int nSrc, n, rc;
  int spaceLeft;
  MemoryPage *pOvfl = 0;
  MemoryPage *pToRelease = 0;
  unsigned char *pPrior;
  unsigned char *pPayload;
  BtShared *pBt = pPage.pBt;
  PageNumber pgnoOvfl = 0;
  int nHeader;
  info		CellInfo

  /* pPage is not necessarily writeable since pCell might be auxiliary
  ** buffer space that is separate from the pPage buffer area */
  assert( pCell<pPage.aData || pCell>=&pPage.aData[pBt.pageSize] );

  /* Fill in the header. */
  nHeader = 0;
  if( !pPage.leaf ){
    nHeader += 4;
  }
  if( pPage.hasData ){
    nHeader += len(pCell[nHeader:]) - len(Buffer(pCell[nHeader:]).WriteVarint64(nData + nZero))
  }else{
	nZero = 0
    nData = 0
  }
  nHeader += len(pCell[nHeader:]) - len(Buffer(pCell[nHeader:]).WriteVarint64(nKey))
  info.ParsePtr(pPage, pCell)
  assert( info.nHeader==nHeader );
  assert( info.nKey==nKey );
  assert( info.nData==(uint32)(nData+nZero) );

  /* Fill in the payload */
  nPayload = nData + nZero;
  if( pPage.intKey ){
    pSrc = pData;
    nSrc = nData;
    nData = 0;
  }else{
    if( nKey>0x7fffffff || pKey==0 ){
      return SQLITE_CORRUPT_BKPT;
    }
    nPayload += (int)nKey;
    pSrc = pKey;
    nSrc = (int)nKey;
  }
  *pnSize = info.nSize;
  spaceLeft = info.nLocal;
  pPayload = &pCell[nHeader];
  pPrior = &pCell[info.iOverflow];

  while( nPayload>0 ){
    if( spaceLeft==0 ){
      PageNumber pgnoPtrmap = pgnoOvfl; /* Overflow page pointer-map entry page */
      if( pBt.autoVacuum ){
        do{
          pgnoOvfl++;
        } while(
          pBt.IsMapPage(pgnoOvfl) || pgnoOvfl==PAGER_MJ_PGNO(pBt)
        );
      }
      rc = allocateBtreePage(pBt, &pOvfl, &pgnoOvfl, pgnoOvfl, 0);
		//	If the database supports auto-vacuum, and the second or subsequent overflow page is being allocated, add an entry to the pointer-map for that page now.
		//	If this is the first overflow page, then write a partial entry to the pointer-map. If we write nothing to this pointer-map slot, then the optimistic overflow chain processing in clearCell() may misinterpret the uninitialised values and delete the wrong pages from the database.
		if pBt.autoVacuum && rc == SQLITE_OK {
			if pgnoPtrmap == 0 {
				rc = pBt.Put(pgnoOvfl, FIRST_OVERFLOW_PAGE, pgnoPtrmap)
			} else {
				rc = pBt.Put(pgnoOvfl, SECONDARY_OVERFLOW_PAGE, pgnoPtrmap)
			}
			if rc != SQLITE_OK {
				pOvfl.Release()
			}
		}
		if rc != SQLITE_OK {
			pToRelease.Release()
			return rc
		}

      /* If pToRelease is not zero than pPrior points into the data area
      ** of pToRelease.  Make sure pToRelease is still writeable. */
      assert( pToRelease == 0 );

      /* If pPrior is part of the data area of pPage, then make sure pPage
      ** is still writeable */
      assert( pPrior<pPage.aData || pPrior>=&pPage.aData[pBt.pageSize] );

      Buffer(pPrior).WriteUint32(pgnoOvfl)
      pToRelease.Release()
      pToRelease = pOvfl;
      pPrior = pOvfl.aData;
      Buffer(pPrior).WriteUint32(0)
      pPayload = &pOvfl.aData[4];
      spaceLeft = pBt.usableSize - 4;
    }
    n = nPayload;
    if( n>spaceLeft ) n = spaceLeft;

    /* If pToRelease is not zero than pPayload points into the data area
    ** of pToRelease.  Make sure pToRelease is still writeable. */
    assert( pToRelease == 0 )

    /* If pPayload is part of the data area of pPage, then make sure pPage
    ** is still writeable */
    assert( pPayload < pPage.aData || pPayload >= &pPage.aData[pBt.pageSize] )

    if( nSrc>0 ){
      if( n>nSrc ) n = nSrc;
      assert( pSrc );
      memcpy(pPayload, pSrc, n);
    }else{
      memset(pPayload, 0, n);
    }
    nPayload -= n;
    pPayload += n;
    pSrc += n;
    nSrc -= n;
    spaceLeft -= n;
    if( nSrc==0 ){
      nSrc = nData;
      pSrc = pData;
    }
  }
  pToRelease.Release()
  return SQLITE_OK;
}

//	Remove the i-th cell from pPage. This routine effects pPage only. The cell content is not freed or deallocated. It is assumed that the cell content has been copied someplace else. This routine just removes the reference to the cell from pPage.
//	"sz" must be the number of bytes in the cell.
static void dropCell(MemoryPage *pPage, int idx, int sz, int *pRC){
  uint32 pc;         /* Offset to cell content of cell being deleted */
  byte *ptr;        /* Used to move bytes around within data[] */
  byte *endPtr;     /* End of loop */
  int rc;         /* The return code */
  int hdr;        /* Beginning of the header.  0 most pages.  100 page 1 */

  if( *pRC ) return;

  assert( idx>=0 && idx<pPage.nCell );
  assert( sz==cellSize(pPage, idx) );
  data := Buffer(pPage.aData)
  ptr = &pPage.CellIndices[2*idx];
  pc = data[ptr].ReadUint16()
  hdr = pPage.hdrOffset;
  if pc < uint32(data[hdr + 5].ReadUint16()) || pc + sz > pPage.pBt.usableSize {
    *pRC = SQLITE_CORRUPT_BKPT;
    return;
  }
  rc = freeSpace(pPage, pc, sz);
  if( rc ){
    *pRC = rc;
    return;
  }
  endPtr = &pPage.CellIndices[2*pPage.nCell - 2];
  assert( (SQLITE_PTR_TO_INT(ptr)&1)==0 );  /* ptr is always 2-byte aligned */
  while( ptr<endPtr ){
    *(uint16*)ptr = *(uint16*)&ptr[2];
    ptr += 2;
  }
  pPage.nCell--;
  data[hdr + 3:].WriteUint16(pPage.nCell)
  pPage.nFree += 2;
}

//	Insert a new cell on pPage at cell index "i". pCell points to the content of the cell.
//	If the cell content will fit on the page, then put it there. If it will not fit, then make a copy of the cell content into pTemp if pTemp is not null. Regardless of pTemp, allocate a new entry in pPage.apOvfl[] and make it point to the cell content (either in pTemp or the original pCell) and also record its index. Allocating a new entry in pPage.CellIndices[] implies that pPage.nOverflow is incremented.
//	If nSkip is non-zero, then do not copy the first nSkip bytes of the cell. The caller will overwrite them after this function returns. If nSkip is non-zero, then pCell may not point to an invalid memory location (but pCell+nSkip is always valid).
func (pPage *MemoryPage) InsertCell(i int, cell, temp_space Buffer, child PageNumber) (rc int) {
	size := len(cell)
	assert( i >= 0 && i <= pPage.nCell + pPage.nOverflow )
	assert( pPage.nCell <= MX_CELL(pPage.pBt) && MX_CELL(pPage.pBt) <= 10921 )
	assert( pPage.nOverflow <= len(pPage.apOvfl) )
	assert( len(pPage.apOvfl) == len(pPage.aiOvfl) )
	//	The cell should normally be sized correctly. However, when moving a malformed cell from a leaf page to an interior page, if the cell size wanted to be less than 4 but got rounded up to 4 on the leaf, then size might be less than 8 (leaf-size + pointer) on the interior node. Hence the term after the || in the following assert().
	assert( size == pPage.cellSize(pCell) || (size == 8 && child > 0) )

	nSkip := 0
	if child != 0 {
		nSkip = 4
	}

	if pPage.nOverflow || size + 2 > pPage.nFree {
		if temp_space != nil {
			copy(temp_space[nSkip:], cell[nSkip:size - nSkip])
			cell = temp_space
		}
		if child != 0 {
			Buffer(cell).WriteUint32(child)
		}
		pPage.nOverflow++
		j := pPage.nOverflow
		assert( j < len(pPage.apOvfl) )
		pPage.apOvfl[j] = temp_space
		pPage.aiOvfl[j] = uint16(i)
	} else {
		if rc = sqlite3PagerWrite(pPage.pDbPage); rc == SQLITE_OK {
			data := Buffer(pPage.aData)
			cellOffset = pPage.cellOffset				//	Address of first cell pointer in data[]
			ins := cellOffset + 2 * i					//	Index in data[] where new cell pointer is inserted
			if idx, rc = pPage.AllocateSpace(size); rc == SQLITE_OK {
				pPage.nCell++
				pPage.nFree -= uint16(2 + size)
				copy(data[idx + nSkip:], cell[nSkip:size - nSkip])
				if child != 0 {
					Buffer(data[idx:]).WriteUint32(child)
				}
				copy(data[ins + 2:], data[ins:])		//	shift the contents to create a write-window for insertion
				data[ins:].WriteUint16(idx)
				data[pPage.hdrOffset + 3:].WriteUint16(pPage.nCell)
				if pPage.pBt.autoVacuum {
					//	The cell may contain a pointer to an overflow page. If so, write the entry for the overflow page into the pointer map.
					pRC = pPage.PutOvflPtr(cell)
				}
			}
		}
	}
}

/*
** Add a list of cells to a page.  The page should be initially empty.
** The cells are guaranteed to fit on the page.
*/
static void assemblePage(
  MemoryPage *pPage,   /* The page to be assemblied */
  int nCell,        /* The number of cells to add to this page */
  byte **apCell,      /* Pointers to cell bodies */
  uint16 *aSize        /* Sizes of the cells */
){
  int i;            /* Loop counter */
  byte *pCellptr;     /* Address of next cell pointer */
  int cellbody;     /* Address of next cell body */
	data := Buffer(pPage.aData)             /* Pointer to data for pPage */
  const int hdr = pPage.hdrOffset;           /* Offset of header on pPage */
  const int nUsable = pPage.pBt.usableSize; /* Usable size of page */

  assert( pPage.nOverflow==0 );
  assert( nCell>=0 && nCell<=(int)MX_CELL(pPage.pBt)
            && (int)MX_CELL(pPage.pBt)<=10921);

  /* Check that the page has just been zeroed by zeroPage() */
  assert( pPage.nCell==0 );
  assert( data[hdr + 5].ReadCompressedIntNotZero() == nUsable )

  pCellptr = nCell * 2
  cellbody = nUsable;
  for(i=nCell-1; i>=0; i--){
    uint16 sz = aSize[i];
    pCellptr -= 2;
    cellbody -= sz;
    pPage.CellIndices[pCellptr:].WriteUint16(cellbody)
    memcpy(&data[cellbody:], apCell[i:], sz);
  }
  data[hdr + 3:].WriteUint16(nCell)
  data[hdr + 5:].WriteUint16(cellbody)
  pPage.nFree -= (nCell * 2) + nUsable - cellbody
  pPage.nCell = uint16(nCell)
}

/*
** The following parameters determine how many adjacent pages get involved
** in a balancing operation.  NN is the number of neighbors on either side
** of the page that participate in the balancing operation.  NB is the
** total number of pages that participate, including the target page and
** NN neighbors on either side.
**
** The minimum value of NN is 1 (of course).  Increasing NN above 1
** (to 2 or 3) gives a modest improvement in SELECT and DELETE performance
** in exchange for a larger degradation in INSERT and UPDATE performance.
** The value of NN appears to give the best results overall.
*/
#define NN 1             /* Number of neighbors on either side of pPage */
#define NB (NN*2+1)      /* Total pages involved in the balance */


/*
** This version of Balance() handles the common special case where
** a new entry is being inserted on the extreme right-end of the
** tree, in other words, when the new entry will become the largest
** entry in the tree.
**
** Instead of trying to balance the 3 right-most leaf pages, just add
** a new page to the right-hand side and put the one new entry in
** that page.  This leaves the right side of the tree somewhat
** unbalanced.  But odds are that we will be inserting new entries
** at the end soon afterwards so the nearly empty page will quickly
** fill up.  On average.
**
** pPage is the leaf page which is the right-most page in the tree.
** pParent is its parent.  pPage must have a single overflow entry
** which is also the right-most entry on the page.
**
** The pSpace buffer is used to store a temporary copy of the divider
** cell that will be inserted into pParent. Such a cell consists of a 4
** byte page number followed by a variable length integer. In other
** words, at most 13 bytes. Hence the pSpace buffer must be at
** least 13 bytes in size.
*/
static int balance_quick(MemoryPage *pParent, MemoryPage *pPage, byte *pSpace){
  BtShared *const pBt = pPage.pBt;    /* B-Tree Database */
  MemoryPage *pNew;                       /* Newly allocated page */
  int rc;                              /* Return Code */
  PageNumber pgnoNew;                        /* Page number of pNew */

  assert( pPage.nOverflow==1 );

  /* This error condition is now caught prior to reaching this function */
  if( pPage.nCell<=0 ) return SQLITE_CORRUPT_BKPT;

  /* Allocate a new page. This page will become the right-sibling of
  ** pPage. Make the parent page writable, so that the new divider cell
  ** may be inserted. If both these operations are successful, proceed.
  */
  rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);

  if( rc==SQLITE_OK ){

    byte *pOut = &pSpace[4];
    byte *pCell = pPage.apOvfl[0];
    uint16 szCell = pPage.cellSize(pCell)
    byte *pStop;

    assert( pPage.aData[0]==(PTF_INTKEY|PTF_LEAFDATA|PTF_LEAF) );
    zeroPage(pNew, PTF_INTKEY|PTF_LEAFDATA|PTF_LEAF);
    assemblePage(pNew, 1, &pCell, &szCell);

	//	If this is an auto-vacuum database, update the pointer map with entries for the new page, and any pointer from the cell on the page to an overflow page. If either of these operations fails, the return code is set, but the contents of the parent page are still manipulated by thh code below. That is Ok, at this point the parent page is guaranteed to be marked as dirty. Returning an error code will cause a rollback, undoing any changes made to the parent page.
	if pBt.autoVacuum {
		rc = pBt.Put(pgnoNew, NON_ROOT_BTREE_PAGE, pParent.pgno)
		if szCell > pNew.minLocal {
			rc = pNew.PutOvflPtr(pCell)
		}
	}

	//	Create a divider cell to insert into pParent. The divider cell consists of a 4-byte page number (the page number of pPage) and a variable length key value (which must be the same value as the largest key on pPage).
	//	To find the largest key value on pPage, first find the right-most cell on pPage. The first two fields of this cell are the record-length (a variable length integer at most 32-bits in size) and the key value (a variable length integer, may have any value). The first of the while(...) loops below skips over the record-length field. The second while(...) loop copies the key value from the cell on pPage into the pSpace buffer.
	pCell = pPage.FindCell(pPage.nCell-1)
    pStop = &pCell[9];
    while( (*(pCell++)&0x80) && pCell<pStop );
    pStop = &pCell[9];
    while( ((*(pOut++) = *(pCell++))&0x80) && pCell<pStop );

	//	Insert the new divider cell into pParent.
    pParent.InsertCell(pParent.nCell, pSpace[:pOut - pSpace], nil, pPage.pgno)

    /* Set the right-child pointer of pParent to point to the new page. */
    Buffer(pParent.aData[pParent.hdrOffset + 8:]).WriteUint32(pgnoNew)

    /* Release the reference to the new page. */
    pNew.Release()
  }

  return rc;
}

/*
** This function is used to copy the contents of the b-tree node stored
** on page pFrom to page pTo. If page pFrom was not a leaf page, then
** the pointer-map entries for each child page are updated so that the
** parent page stored in the pointer map is page pTo. If pFrom contained
** any cells with overflow page pointers, then the corresponding pointer
** map entries are also updated so that the parent page is page pTo.
**
** If pFrom is currently carrying any overflow cells (entries in the
** MemoryPage.apOvfl[] array), they are not copied to pTo.
**
** Before returning, page pTo is reinitialized using MemoryPage::Initialize().
**
** The performance of this function is not critical. It is only used by
** the balance_shallower() and balance_deeper() procedures, neither of
** which are called often under normal circumstances.
*/
static void copyNodeContent(MemoryPage *pFrom, MemoryPage *pTo, int *pRC){
  if( (*pRC)==SQLITE_OK ){
    BtShared * const pBt = pFrom.pBt;
    aFrom := Buffer(pFrom.aData)
    aTo := Buffer(pTo.aData)
    int const iFromHdr = pFrom.hdrOffset;
    int const iToHdr = ((pTo.pgno==1) ? 100 : 0);
    int rc;
    int iData;


    assert( pFrom.isInit );
    assert( pFrom.nFree>=iToHdr );
    assert( int(aFrom[iFromHdr + 5].ReadUint16()) <= int(pBt.usableSize) )

    //	Copy the b-tree node content from page pFrom to page pTo.
    iData = aFrom[iFromHdr + 5].ReadUint16()
    memcpy(&aTo[iData], &aFrom[iData], pBt.usableSize-iData);
    memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom.cellOffset + 2*pFrom.nCell);

	//	Reinitialize page pTo so that the contents of the MemoryPage structure match the new data. The initialization of pTo can actually fail under fairly obscure circumstances, even though it is a copy of initialized page pFrom.
    pTo.isInit = false
    rc = pTo.Initialize()
    if rc != SQLITE_OK {
      *pRC = rc;
      return;
    }

    //	If this is an auto-vacuum database, update the pointer-map entries for any b-tree or overflow pages that pTo now contains the pointers to.
    if pBt.autoVacuum {
      *pRC = setChildPtrmaps(pTo);
    }
  }
}

//	This routine redistributes cells on the iParentIdx'th child of pParent (hereafter "the page") and up to 2 siblings so that all pages have about the same amount of free space. Usually a single sibling on either side of the page are used in the balancing, though both siblings might come from one side if the page is the first or last child of its parent. If the page has fewer than 2 siblings (something which can only happen if the page is a root page or a child of a root page) then all available siblings participate in the balancing.
//	The number of siblings of the page might be increased or decreased by one or two in an effort to keep pages nearly full but not over full.
//	Note that when this routine is called, some of the cells on the page might not actually be stored in MemoryPage.aData[]. This can happen if the page is overfull. This routine ensures that all cells allocated to the page and its siblings fit into MemoryPage.aData[] before returning.
//	In the course of balancing the page and its siblings, cells may be inserted into or removed from the parent page (pParent). Doing so may cause the parent page to become overfull or underfull. If this happens, it is the responsibility of the caller to invoke the correct balancing routine to fix this problem (see the Balance() routine).
//	If this routine fails for any reason, it might leave the database in a corrupted state. So if this routine fails, the database should be rolled back.
//	The third argument to this function, aOvflSpace, is a pointer to a buffer big enough to hold one page. If while inserting cells into the parent page (pParent) the parent page becomes overfull, this buffer is used to store the parent's overflow cells. Because this function inserts a maximum of four divider cells into the parent page, and the maximum size of a cell stored within an internal node is always less than 1/4 of the page-size, the aOvflSpace[] buffer is guaranteed to be large enough for all overflow cells.
//	If aOvflSpace is set to a null pointer, this function returns SQLITE_NOMEM.
func (pParent *MemoryPage) BalanceNonroot(iParentIdx int, aOvflSpace []byte, isRoot bool) (rc int) {
	int nCell = 0;               /* Number of cells in apCell[] */
	int nMaxCells = 0;           /* Allocated size of apCell, szCell, aFrom. */
	int nNew = 0;                /* Number of pages in apNew[] */
	int nOld;                    /* Number of pages in apOld[] */
	int i, j, k;                 /* Loop counters */
	int nxDiv;                   /* Next divider slot in pParent.CellIndices[] */
	uint16 leafCorrection;          /* 4 if pPage is a leaf.  0 if not */
	int leafData;                /* True if pPage is a leaf of a LEAFDATA tree */
	int usableSpace;             /* Bytes in pPage beyond the header */
	int pageFlags;               /* Value of pPage.aData[0] */
	int subtotal;                /* Subtotal of bytes in cells on one page */
	int iSpace1 = 0;             /* First unused byte of aSpace1[] */
	int iOvflSpace = 0;          /* First unused byte of aOvflSpace[] */
	int szScratch;               /* Size of scratch memory requested */

	byte *pRight;                  /* Location in parent of right-sibling pointer */
	byte *apDiv[NB-1];             /* Divider cells in pParent */
	int cntNew[NB+2];            /* Index in aCell[] of cell after i-th page */
	int szNew[NB+2];             /* Combined size of cells place on i-th page */
	byte **apCell = 0;             /* All cells begin balanced */
	uint16 *szCell;                 /* Local size of all cells in apCell[] */
	byte *aSpace1;                 /* Space for copies of dividers cells */

	pBt := pParent.pBt
	apOld := make([]*MemoryPage, 0, NB)				//	pPage and up to two siblings
	apCopy := make([]*MemoryPage, 0, NB)			//	Private copies of apOld[] pages
	apNew := make([]*MemoryPage, 0, NB + 2)			//	pPage and up to NB siblings after balancing

	//	At this point pParent may have at most one overflow cell. And if this overflow cell is present, it must be the cell with index iParentIdx. This scenario comes about when this function is called (indirectly) from sqlite3BtreeDelete().
	assert( pParent.nOverflow == 0 || pParent.nOverflow == 1 )
	assert( pParent.nOverflow == 0 || pParent.aiOvfl[0] == iParentIdx )

	if len(aOvflSpace) == 0 {
		return SQLITE_NOMEM
	}

	//	Find the sibling pages to balance. Also locate the cells in pParent that divide the siblings. An attempt is made to find NN siblings on either side of pPage. More siblings are taken from one side, however, if there are fewer than NN siblings on the other side. If pParent has NB or fewer children then all children of pParent are taken.
	//	This loop also drops the divider cells from the parent page. This way, the remainder of the function does not have to deal with any overflow cells in the parent page, since if any existed they will have already been removed.
	if i = pParent.nOverflow + pParent.nCell; i < 2 {
		nxDiv = 0
		nOld = i + 1
	} else {
		nOld = 3
		switch iParentIdx {
		case 0:
			nxDiv = 0
		case i:
			nxDiv = i - 2
		default:
			nxDiv = iParentIdx - 1
		}
		i = 2
	}
	if i + nxDiv - pParent.nOverflow == pParent.nCell {
		pRight = pParent.aData[pParent.hdrOffset + 8]
	} else {
		pRight = pParent.FindCell(i + nxDiv - pParent.nOverflow)
	}
	pgno := PageNumber(Buffer(pRight).ReadUint32())
	for {
		apOld[i], rc = pBt.GetPageAndInitialize(pgno)
		if rc != SQLITE_OK {
			goto balance_cleanup
		}
		nMaxCells += 1 + apOld[i].nCell + apOld[i].nOverflow
		if i--; i == 0 {
			break
		}

		if i + nxDiv == pParent.aiOvfl[0] && pParent.nOverflow {
			apDiv[i] = pParent.apOvfl[0]
			pgno = PageNumber(Buffer(apDiv[i:]).ReadUint32())
			szNew[i] = pParent.cellSize(apDiv[i])
			pParent.nOverflow = 0
		} else {
			apDiv[i] = pParent.FindCell(i + nxDiv - pParent.nOverflow)
			pgno = PageNumber(Buffer(apDiv[i:]).ReadUint32())
			szNew[i] = pParent.cellSize(apDiv[i])

			//	Drop the cell from the parent page. apDiv[i] still points to the cell within the parent, even though it has been dropped. This is safe because dropping a cell only overwrites the first four bytes of it, and this function does not need the first four bytes of the divider cell. So the pointer is safe to use later on.
			//	But not if we are in secure-delete mode. In secure-delete mode, the dropCell() routine will overwrite the entire cell with zeroes. In this case, temporarily copy the cell into the aOvflSpace[] buffer. It will be copied out again as soon as the aSpace[] buffer is allocated.
			if pBt.Flags & BTS_SECURE_DELETE {
				iOff := SQLITE_PTR_TO_INT(apDiv[i]) - SQLITE_PTR_TO_INT(pParent.aData)
				if iOff + szNew[i] > int(pBt.usableSize) {
					rc = SQLITE_CORRUPT_BKPT
					memset(apOld, 0, (i + 1) * sizeof(MemoryPage*))
					goto balance_cleanup
				} else {
					copy(aOvflSpace[iOff:], apDiv[i:i + szNew[i]])
					apDiv[i] = aOvflSpace[apDiv[i] - pParent.aData]
				}
			}
			dropCell(pParent, i + nxDiv - pParent.nOverflow, szNew[i], &rc)
		}
	}

	//	Make nMaxCells a multiple of 4 in order to preserve 8-byte alignment
	nMaxCells = (nMaxCells + 3) &~ 3

	//	Allocate space for memory structures
	k = pBt.pageSize + ROUND(sizeof(MemoryPage), 8)
	szScratch =
       nMaxCells * sizeof(byte*)                       /* apCell */
     + nMaxCells * sizeof(uint16)                       /* szCell */
     + pBt.pageSize                               /* aSpace1 */
     + k*nOld;                                     /* Page copies (apCopy) */
	if apCell = sqlite3ScratchMalloc( szScratch ); apCell == nil {
		rc = SQLITE_NOMEM
		goto balance_cleanup
	}
	szCell = (uint16*)&apCell[nMaxCells]
	aSpace1 = (byte*)&szCell[nMaxCells]
	assert( EIGHT_BYTE_ALIGNMENT(aSpace1) )

	//	Load pointers to all cells on sibling pages and the divider cells into the local apCell[] array. Make copies of the divider cells into space obtained from aSpace1[] and remove the the divider Cells from pParent.
	//	If the siblings are on leaf pages, then the child pointers of the divider cells are stripped from the cells before they are copied into aSpace1[]. In this way, all cells in apCell[] are without child pointers. If siblings are not leaves, then all cell in apCell[] include child pointers. Either way, all cells in apCell[] are alike.
	//			leafCorrection:		4 if pPage is a leaf. 0 if pPage is not a leaf.
	//			leafData:			1 if pPage holds key+data and pParent holds only keys.
	leafCorrection = apOld[0].leaf * 4
	leafData = apOld[0].hasData
	for i = 0; i < nOld; i++ {
		int limit
		//	Before doing anything else, take a copy of the i'th original sibling. The rest of this function will use data from the copies rather than the original pages since the original pages will be in the process of being overwritten.
		apCopy[i] = (MemoryPage*)&aSpace1[pBt.pageSize + k * i]
		MemoryPage *pOld = apCopy[i]
		memcpy(pOld, apOld[i], sizeof(MemoryPage))
		pOld.aData = raw.ByteSlice(pOld[1:])
		memcpy(pOld.aData, apOld[i].aData, pBt.pageSize)

		limit = pOld.nCell + pOld.nOverflow
		if pOld.nOverflow > 0 {
			for j = 0; j < limit; j++ {
				assert( nCell < nMaxCells )
				apCell[nCell] = pOld.FindOverflowCell(j)
				szCell[nCell] = pOld.cellSize(apCell[nCell])
				nCell++
			}
		} else {
			byte *aData = pOld.aData
			uint16 maskPage = pOld.maskPage
			uint16 cellOffset = pOld.cellOffset
			for j = 0; j < limit; j++ {
				assert( nCell < nMaxCells )
				apCell[nCell] = aData.FindCell(maskPage, cellOffset, j)
				szCell[nCell] = pOld.cellSize(apCell[nCell])
				nCell++
			}
		}
		if i < nOld - 1 && !leafData {
			uint16 sz = (uint16)szNew[i]
			byte *pTemp
			assert( nCell < nMaxCells )
			szCell[nCell] = sz
			pTemp = &aSpace1[iSpace1]
			iSpace1 += sz
			assert( sz <= pBt.maxLocal + 23 )
			assert( iSpace1 <= (int)pBt.pageSize )
			memcpy(pTemp, apDiv[i], sz)
			apCell[nCell] = pTemp + leafCorrection
			assert( leafCorrection == 0 || leafCorrection == 4 )
			szCell[nCell] = szCell[nCell] - leafCorrection
			if !pOld.leaf {
				assert( leafCorrection == 0 )
				assert( pOld.hdrOffset == 0 )
				//	The right pointer of the child page pOld becomes the left pointer of the divider cell
				memcpy(apCell[nCell], &pOld.aData[8], 4)
			} else {
				assert( leafCorrection == 4 )
				if szCell[nCell] < 4 {
					//	Do not allow any cells smaller than 4 bytes.
					szCell[nCell] = 4
				}
			}
			nCell++
		}
	}

	//	Figure out the number of pages needed to hold all nCell cells. Store this number in "k". Also compute szNew[] which is the total size of all cells on the i-th page and cntNew[] which is the index in apCell[] of the cell that divides page i from page i+1. cntNew[k] should equal nCell.
	//	Values computed by this block:
	//			k:				The total number of sibling pages
	//			szNew[i]:		Spaced used on the i-th sibling page.
	//			cntNew[i]:		Index in apCell[] and szCell[] for the first cell to the right of the i-th sibling page.
	//			usableSpace:	Number of bytes of space available on each sibling.
	usableSpace = pBt.usableSize - 12 + leafCorrection
	for subtotal = k = i = 0; i < nCell; i++ {
		assert( i < nMaxCells )
		subtotal += szCell[i] + 2
		if subtotal > usableSpace {
			szNew[k] = subtotal - szCell[i]
			cntNew[k] = i
			if leafData {
				i--
			}
			subtotal = 0
			k++
			if k > NB + 1 {
				rc = SQLITE_CORRUPT_BKPT
				goto balance_cleanup
			}
		}
	}
	szNew[k] = subtotal
	cntNew[k] = nCell
	k++

	//	The packing computed by the previous block is biased toward the siblings on the left side. The left siblings are always nearly full, while the right-most sibling might be nearly empty. This block of code attempts to adjust the packing of siblings to get a better balance.
	//	This adjustment is more than an optimization. The packing above might be so out of balance as to be illegal. For example, the right-most sibling might be completely empty. This adjustment is not optional.
	for i = k - 1; i > 0; i-- {
		int szRight = szNew[i];  /* Size of sibling on the right */
		int szLeft = szNew[i-1]; /* Size of sibling on the left */
		int r;              /* Index of right-most cell in left sibling */
		int d;              /* Index of first cell to the left of right sibling */

		r = cntNew[i - 1] - 1
		d = r + 1 - leafData
		assert( d < nMaxCells )
		assert( r < nMaxCells )
		for szRight == 0 || szRight + szCell[d] + 2 <= szLeft - (szCell[r] + 2) {
			szRight += szCell[d] + 2
			szLeft -= szCell[r] + 2
			cntNew[i - 1]--
			r = cntNew[i - 1] - 1
			d = r + 1 - leafData
		}
		szNew[i] = szRight
		szNew[i - 1] = szLeft
	}

	//	Either we found one or more cells (cntnew[0] > 0) or pPage is a virtual root page. A virtual root page is when the real root page is page 1 and we are the only child of that page.
	//	UPDATE: The assert() below is not necessarily true if the database file is corrupt. The corruption will be detected and reported later in this procedure so there is no need to act upon it now.

	//	Allocate k new pages.  Reuse old pages where possible.
	if apOld[0].pgno <= 1 {
		rc = SQLITE_CORRUPT_BKPT
		goto balance_cleanup
	}
	pageFlags = apOld[0].aData[0]
	for i = 0; i < k; i++ {
		MemoryPage *pNew;
		if i < nOld {
			pNew = apNew[i] = apOld[i]
			apOld[i] = 0
			rc = sqlite3PagerWrite(pNew.pDbPage)
			nNew++
			if rc != SQLITE_OK {
				goto balance_cleanup
			}
		} else {
			assert( i > 0 )
			if rc = allocateBtreePage(pBt, &pNew, &pgno, pgno, 0); rc != SQLITE_OK {
				goto balance_cleanup
			}
			apNew[i] = pNew
			nNew++

			//	Set the pointer-map entry for the new sibling page.
			if pBt.autoVacuum {
				if rc = pBt.Put(pNew.pgno, NON_ROOT_BTREE_PAGE, pParent.pgno); rc != SQLITE_OK {
					goto balance_cleanup
				}
			}
		}
	}

	//	Free any old pages that were not reused as new pages.
	for i < nOld {
		freePage(apOld[i], &rc)
		if rc != SQLITE_OK {
			goto balance_cleanup
		}
		apOld[i].Release()
		apOld[i] = nil
		i++
	}

	//	Put the new pages in accending order. This helps to keep entries in the disk file in order so that a scan of the table is a linear scan through the file. That in turn helps the operating system to deliver pages from the disk more rapidly.
	//	An O(n^2) insertion sort algorithm is used, but since n is never more than NB (a small constant), that should not be a problem.
	//	When NB == 3, this one optimization makes the database about 25% faster for large insertions and deletions.
	for i = 0; i < k - 1; i++ {
		int minV = apNew[i].pgno
		int minI = i
		for j = i + 1; j < k; j++ {
			if apNew[j].pgno < uint(minV) {
				minI = j
				minV = apNew[j].pgno
			}
		}
		if minI > i {
			MemoryPage *pT
			pT = apNew[i]
			apNew[i] = apNew[minI]
			apNew[minI] = pT
		}
	}

	Buffer(pRight).WriteUint32(apNew[nNew - 1].pgno)

	//	Evenly distribute the data in apCell[] across the new pages. Insert divider cells into pParent as necessary.
	j = 0
	for i = 0; i < nNew; i++ {
		//	Assemble the new sibling page.
		MemoryPage *pNew = apNew[i]
		assert( j < nMaxCells )
		zeroPage(pNew, pageFlags)
		assemblePage(pNew, cntNew[i] - j, &apCell[j], &szCell[j])
		assert( pNew.nCell > 0 || (nNew == 1 && cntNew[0] == 0) )
		assert( pNew.nOverflow == 0 )
		j = cntNew[i]

		//	If the sibling page assembled above was not the right-most sibling, insert a divider cell into the parent page.
		assert( i < nNew - 1 || j == nCell )
		if j < nCell {
			byte *pCell
			byte *pTemp
			int sz

			assert( j < nMaxCells )
			pCell = apCell[j]
			sz = szCell[j] + leafCorrection
			pTemp = &aOvflSpace[iOvflSpace]
			if !pNew.leaf {
				memcpy(&pNew.aData[8], pCell, 4)
			} else if leafData {
				//	If the tree is a leaf-data tree, and the siblings are leaves, then there is no divider cell in apCell[]. Instead, the divider cell consists of the integer key for the right-most cell of the sibling-page assembled above only.
				info	CellInfo
				j--
				info.ParsePtr(pNew, apCell[j])
				pCell = pTemp
				sz = 4 + len(pCell[4:]) - len(Buffer(pCell[4:]).WriteVarint64(info.nKey))
				pTemp = 0
			} else {
				pCell -= 4
				//	Obscure case for non-leaf-data trees: If the cell at pCell was previously stored on a leaf node, and its reported size was 4 bytes, then it may actually be smaller than this (see CellInfo::ParsePtr(), 4 bytes is the minimum size of any cell). But it is important to pass the correct size to InsertCell(), so reparse the cell now.
				//	Note that this can never happen in an SQLite data file, as all cells are at least 4 bytes. It only happens in b-trees used to evaluate "IN (SELECT ...)" and similar clauses.
				if szCell[j] == 4 {
					assert( leafCorrection == 4 )
					sz = pParent.cellSize(pCell)
				}
			}
			iOvflSpace += sz
			assert( sz <= pBt.maxLocal + 23 )
			assert( iOvflSpace <= int(pBt.pageSize) )
			if rc = pParent.InsertCell(nxDiv, pCell[:sz], pTemp, pNew.pgno); rc != SQLITE_OK {
				goto balance_cleanup
			}
			j++
			nxDiv++
		}
	}
	assert( j == nCell )
	assert( nOld > 0 )
	assert( nNew > 0 )
	if (pageFlags & PTF_LEAF) == 0 {
		byte *zChild = &apCopy[nOld-1].aData[8]
		memcpy(&apNew[nNew-1].aData[8], zChild, 4)
	}

	if isRoot && pParent.nCell == 0 && pParent.hdrOffset <= apNew[0].nFree {
		//	The root page of the b-tree now contains no cells. The only sibling page is the right-child of the parent. Copy the contents of the child page into the parent, decreasing the overall height of the b-tree structure by one. This is described as the "balance-shallower" sub-algorithm in some documentation.
		//	If this is an auto-vacuum database, the call to copyNodeContent() sets all pointer-map entries corresponding to database image pages for which the pointer is stored within the content being copied.
		//	The second assert below verifies that the child page is defragmented (it must be, as it was just reconstructed using assemblePage()). This is important if the parent page happens to be page 1 of the database image.
		assert( nNew == 1 )
		assert( apNew[0].nFree == (Buffer(apNew[0].aData[5]).ReadUint16()) - apNew[0].cellOffset - apNew[0].nCell * 2) )
		copyNodeContent(apNew[0], pParent, &rc)
		freePage(apNew[0], &rc)
	} else if pBt.autoVacuum {
		//	Fix the pointer-map entries for all the cells that were shifted around. There are several different types of pointer-map entries that need to be dealt with by this routine. Some of these have been set already, but many have not. The following is a summary:
		//			1) The entries associated with new sibling pages that were not siblings when this function was called. These have already been set. We don't need to worry about old siblings that were moved to the free-list - the freePage() code has taken care of those.
		//			2) The pointer-map entries associated with the first overflow page in any overflow chains used by new divider cells. These have also already been taken care of by the InsertCell() code.
		//			3) If the sibling pages are not leaves, then the child pages of cells stored on the sibling pages may need to be updated.
		//			4) If the sibling pages are not internal intkey nodes, then any overflow pages used by these cells may need to be updated (internal intkey nodes never contain pointers to overflow pages).
		//			5) If the sibling pages are not leaves, then the pointer-map entries for the right-child pages of each sibling may need to be updated.
		//	Cases 1 and 2 are dealt with above by other code. The next block deals with cases 3 and 4 and the one after that, case 5. Since setting a pointer map entry is a relatively expensive operation, this code only sets pointer map entries for child or overflow pages that have actually moved between pages.
		MemoryPage *pNew = apNew[0]
		MemoryPage *pOld = apCopy[0]
		int nOverflow = pOld.nOverflow
		int iNextOld = pOld.nCell + nOverflow
		int iOverflow = (nOverflow ? pOld.aiOvfl[0] : -1)
		j = 0;                             /* Current 'old' sibling page */
		k = 0;                             /* Current 'new' sibling page */
		for i = 0; i < nCell; i++ {
			int isDivider = 0
			for i == iNextOld {
				//	Cell i is the cell immediately following the last cell on old sibling page j. If the siblings are not leaf pages of an intkey b-tree, then cell i was a divider cell.
				assert( j + 1 < ArraySize(apCopy) )
				j++
				pOld = apCopy[j]
				iNextOld = i + !leafData + pOld.nCell + pOld.nOverflow
				if pOld.nOverflow {
					nOverflow = pOld.nOverflow
					iOverflow = i + !leafData + pOld.aiOvfl[0]
				}
				isDivider = !leafData
			}

			assert( nOverflow > 0 || iOverflow < i )
			assert( nOverflow < 2 || pOld.aiOvfl[0] == pOld.aiOvfl[1] - 1)
			assert(nOverflow < 3 || pOld.aiOvfl[1] == pOld.aiOvfl[2] - 1)
			if i == iOverflow {
				isDivider = 1
				if nOverflow--; nOverflow > 0 {
					iOverflow++
				}
			}

			if i == cntNew[k] {
				//	Cell i is the cell immediately following the last cell on new sibling page k. If the siblings are not leaf pages of an intkey b-tree, then cell i is a divider cell.
				k++
				pNew = apNew[k]
				if !leafData {
					continue
				}
			}
			assert( j < nOld )
			assert( k < nNew )

			//	If the cell was originally divider cell (and is not now) or an overflow cell, or if the cell was located on a different sibling page before the balancing, then the pointer map entries associated with any child or overflow pages need to be updated.
			if isDivider || pOld.pgno != pNew.pgno {
				if !leafCorrection {
					rc = pBt.Put(Buffer(apCell[i:]).ReadUint32(), NON_ROOT_BTREE_PAGE, pNew.pgno)
				}
				if szCell[i] > pNew.minLocal {
					rc = pNew.PutOvflPtr(apCell[i])
				}
			}
		}

		if !leafCorrection {
			for i = 0; i < nNew; i++ {
				uint32 key = Buffer(apNew[i].aData[8:]).ReadUint32()
				rc = pBt.Put(key, NON_ROOT_BTREE_PAGE, apNew[i].pgno)
			}
		}
	}

	assert( pParent.isInit )

	//	Cleanup before returning.
balance_cleanup:
	sqlite3ScratchFree(apCell)
	for i = 0; i < nOld; i++ {
		apOld[i].Release()
	}
	for i = 0; i < nNew; i++ {
		apNew[i].Release()
	}
	return rc
}


/*
** This function is called when the root page of a b-tree structure is
** overfull (has one or more overflow pages).
**
** A new child page is allocated and the contents of the current root
** page, including overflow cells, are copied into the child. The root
** page is then overwritten to make it an empty page with the right-child
** pointer pointing to the new page.
**
** Before returning, all pointer-map entries corresponding to pages
** that the new child-page now contains pointers to are updated. The
** entry corresponding to the new right-child pointer of the root
** page is also updated.
**
** If successful, *ppChild is set to contain a reference to the child
** page and SQLITE_OK is returned. In this case the caller is required
** to call Release() on *ppChild exactly once. If an error occurs,
** an error code is returned and *ppChild is set to 0.
*/
static int balance_deeper(MemoryPage *pRoot, MemoryPage **ppChild){
  int rc;                        /* Return value from subprocedures */
  MemoryPage *pChild = 0;           /* Pointer to a new child page */
  PageNumber pgnoChild = 0;            /* Page number of the new child page */
  BtShared *pBt = pRoot.pBt;    /* The BTree */

  assert( pRoot.nOverflow>0 );

	//	Make pRoot, the root page of the b-tree, writable. Allocate a new page that will become the new right-child of pPage. Copy the contents of the node stored on pRoot into the new child page.
	if rc = sqlite3PagerWrite(pRoot.pDbPage); rc == SQLITE_OK {
		rc = allocateBtreePage(pBt,&pChild,&pgnoChild,pRoot.pgno,0)
		copyNodeContent(pRoot, pChild, &rc)
		if pBt.autoVacuum {
			rc = pBt.Put(pgnoChild, NON_ROOT_BTREE_PAGE, pRoot.pgno)
		}
	}
	if rc != SQLITE_OK {
		*ppChild = 0
		pChild.Release()
		return rc
	}
	assert( pChild.nCell == pRoot.nCell )

  /* Copy the overflow cells from pRoot to pChild */
  memcpy(pChild.aiOvfl, pRoot.aiOvfl,
         pRoot.nOverflow*sizeof(pRoot.aiOvfl[0]));
  memcpy(pChild.apOvfl, pRoot.apOvfl,
         pRoot.nOverflow*sizeof(pRoot.apOvfl[0]));
  pChild.nOverflow = pRoot.nOverflow;

  /* Zero the contents of pRoot. Then install pChild as the right-child. */
  zeroPage(pRoot, pChild.aData[0] & ~PTF_LEAF);
  Buffer(pRoot.aData[pRoot.hdrOffset + 8:]).WriteUint32(pgnoChild)

  *ppChild = pChild;
  return SQLITE_OK;
}

/*
** Insert a new record into the BTree.  The key is given by (pKey,nKey)
** and the data is given by (pData,nData).  The cursor is used only to
** define what table the record should be inserted into.  The cursor
** is left pointing at a random location.
**
** For an INTKEY table, only the nKey value of the key is used.  pKey is
** ignored.  For a ZERODATA table, the pData and nData are both ignored.
**
** If the seekResult parameter is non-zero, then a successful call to
** MovetoUnpacked() to seek cursor pCur to (pKey, nKey) has already
** been performed. seekResult is the search result returned (a negative
** number if pCur points at an entry that is smaller than (pKey, nKey), or
** a positive value if pCur points at an etry that is larger than
** (pKey, nKey)).
**
** If the seekResult parameter is non-zero, then the caller guarantees that
** cursor pCur is pointing at the existing copy of a row that is to be
** overwritten.  If the seekResult parameter is 0, then cursor pCur may
** point to any entry or to no entry at all and so this function has to seek
** the cursor before the new key can be inserted.
*/
 int sqlite3BtreeInsert(
  Cursor *pCur,                /* Insert data into the table of this cursor */
  const void *pKey, int64 nKey,    /* The key of the new record */
  const void *pData, int nData,  /* The data of the new record */
  int nZero,                     /* Number of extra 0 bytes to append to data */
  int appendBias,                /* True if this is likely an append */
  int seekResult                 /* Result of prior MovetoUnpacked() call */
){
  int rc;
  int loc = seekResult;          /* -1: before desired location  +1: after */
  int szNew = 0;
  int idx;
  MemoryPage *pPage;
  Btree *p = pCur.pBtree;
  BtShared *pBt = p.pBt;
  unsigned char *oldCell;
  unsigned char *newCell = 0;

  if( pCur.eState==CURSOR_FAULT ){
    assert( pCur.skiNext!=SQLITE_OK );
    return pCur.skiNext;
  }

  assert( pCur.Writable && pBt.inTransaction==TRANS_WRITE && (pBt.Flags & BTS_READ_ONLY)==0 );
  assert( hasSharedCacheTableLock(p, pCur.RootPage, pCur.pKeyInfo!=0, 2) );

  /* Assert that the caller has been consistent. If this cursor was opened
  ** expecting an index b-tree, then the caller should be inserting blob
  ** keys with no associated data. If the cursor was opened expecting an
  ** intkey table, the caller should be inserting integer keys with a
  ** blob of associated data.  */
  assert( (pKey==0)==(pCur.pKeyInfo==0) );

  /* Save the positions of any other cursors open on this table.
  **
  ** In some cases, the call to btreeMoveto() below is a no-op. For
  ** example, when inserting data into a table with auto-generated integer
  ** keys, the VDBE layer invokes sqlite3BtreeLast() to figure out the
  ** integer key to use. It then calls this function to actually insert the
  ** data into the intkey B-Tree. In this case btreeMoveto() recognizes
  ** that the cursor is already where it needs to be and returns without
  ** doing any work. To avoid thwarting these optimizations, it is important
  ** not to clear the cursor here.
  */
  rc = saveAllCursors(pBt, pCur.RootPage, pCur);
  if( rc ) return rc;

	//	If this is an insert into a table b-tree, invalidate any incrblob cursors open on the row being replaced (assuming this is a replace operation - if it is not, the following is a no-op).
	if pCur.pKeyInfo == nil {
		p.InvalidateIncrblobCursors(nKey, 0)
	}

  if( !loc ){
    rc = btreeMoveto(pCur, pKey, nKey, appendBias, &loc);
    if( rc ) return rc;
  }
  assert( pCur.eState==CURSOR_VALID || (pCur.eState==CURSOR_INVALID && loc) );

  pPage = pCur.Pages[pCur.iPage];
  assert( pPage.intKey || nKey>=0 );
  assert( pPage.leaf || !pPage.intKey );

  assert( pPage.isInit );
  allocateTempSpace(pBt);
  if newCell = pBt.pTmpSpace; newCell == nil {
	  return SQLITE_NOMEM
  }
  if rc = fillInCell(pPage, newCell, pKey, nKey, pData, nData, nZero, &szNew); rc != SQLITE_OK {
	  goto end_insert
  }
  assert( szNew == pPage.cellSize(newCell) )
  assert( szNew <= MX_CELL_SIZE(pBt) );
  idx = pCur.aiIdx[pCur.iPage];
  if( loc==0 ){
    uint16 szOld;
    assert( idx<pPage.nCell );
    if rc = sqlite3PagerWrite(pPage.pDbPage); rc != SQLITE_OK {
      goto end_insert;
    }
    oldCell = pPage.FindCell(idx)
    if( !pPage.leaf ){
      memcpy(newCell, oldCell, 4);
    }
    szOld = pPage.cellSize(oldCell)
    rc = clearCell(pPage, oldCell);
    dropCell(pPage, idx, szOld, &rc);
    if rc != SQLITE_OK {
		goto end_insert
	}
  }else if( loc<0 && pPage.nCell>0 ){
    assert( pPage.leaf );
    idx = ++pCur.aiIdx[pCur.iPage];
  }else{
    assert( pPage.leaf );
  }
  rc = pPage.InsertCell(idx, newCell, nil, 0)
  assert( rc != SQLITE_OK || pPage.nCell > 0 || pPage.nOverflow > 0 )

	//	If no error has occured and pPage has an overflow cell, call Balance() to redistribute the cells within the tree. Since Balance() may move the cursor, zero the Cursor.CellInfo.nSize and Cursor.validNKey variables.
	//	Previous versions of SQLite called MoveToRoot() to move the cursor back to the root page as Balance() used to invalidate the contents of Cursor.Pages[] and Cursor.aiIdx[]. Instead of doing that, set the cursor state to "invalid". This makes common insert operations slightly faster.
	//	There is a subtle but important optimization here too. When inserting multiple records into an intkey b-tree using a single cursor (as can happen while processing an "INSERT INTO ... SELECT" statement), it is advantageous to leave the cursor pointing to the last entry in the b-tree if possible. If the cursor is left pointing to the last entry in the table, and the next row inserted has an integer key larger than the largest existing key, it is possible to insert the row without seeking the cursor. This can be a big performance boost.
	pCur.CellInfo.nSize = 0
	pCur.validNKey = 0
	if rc == SQLITE_OK && pPage.nOverflow != 0 {
		rc = pCur.Balance()

		//	Must make sure nOverflow is reset to zero even if the Balance() fails. Internal data structure corruption will result otherwise. Also, set the cursor state to invalid. This stops saveCursorPosition() from trying to save the current position of the cursor.
		pCur.Pages[pCur.iPage].nOverflow = 0
		pCur.eState = CURSOR_INVALID
	}
	assert( pCur.Pages[pCur.iPage].nOverflow == 0 )

end_insert:
	return rc
}

/*
** Create a new BTree table.  Write into *piTable the page
** number for the root page of the new table.
**
** The type of type is determined by the flags parameter.  Only the
** following values of flags are currently in use.  Other values for
** flags might not work:
**
**     BTREE_INTKEY|BTREE_LEAFDATA     Used for SQL tables with rowid keys
**     BTREE_ZERODATA                  Used for SQL indices
*/
static int btreeCreateTable(Btree *p, int *piTable, int createTabFlags){
  BtShared *pBt = p.pBt;
  MemoryPage *pRoot;
  PageNumber RootPage;
  int rc;
  int ptfFlags;          /* Page-type flage for the root page of new table */

  assert( pBt.inTransaction==TRANS_WRITE );
  assert( (pBt.Flags & BTS_READ_ONLY)==0 );

  if( pBt.autoVacuum ){
    PageNumber pgnoMove;      /* Move a page here to make room for the root-page */
    MemoryPage *pPageMove; /* The page to move to. */

    /* Creating a new table may probably require moving an existing database
    ** to make room for the new tables root page. In case this page turns
    ** out to be an overflow page, delete all overflow page-map caches
    ** held by open cursors.
    */
    invalidateAllOverflowCache(pBt);

    /* Read the value of meta[3] from the database to determine where the
    ** root page of the new table should go. meta[3] is the largest root-page
    ** created so far, so the new root-page is (meta[3]+1).
    */
    sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, &RootPage);
    RootPage++;

    /* The new root-page may not be allocated on a pointer-map page, or the
    ** PENDING_BYTE page.
    */
    while( RootPage==pBt.Pageno(RootPage) ||
        RootPage==PAGER_MJ_PGNO(pBt) ){
      RootPage++;
    }
    assert( RootPage>=3 );

    /* Allocate a page. The page that currently resides at RootPage will
    ** be moved to the allocated page (unless the allocated page happens
    ** to reside at RootPage).
    */
    rc = allocateBtreePage(pBt, &pPageMove, &pgnoMove, RootPage, 1);
    if( rc!=SQLITE_OK ){
      return rc;
    }

    if( pgnoMove!=RootPage ){
      /* RootPage is the page that will be used for the root-page of
      ** the new table (assuming an error did not occur). But we were
      ** allocated pgnoMove. If required (i.e. if it was not allocated
      ** by extending the file), the current page at position pgnoMove
      ** is already journaled.
      */
      byte eType = 0;
      PageNumber iPtrPage = 0;

      pPageMove.Release()

      /* Move the page currently at RootPage to pgnoMove. */
      pRoot, rc = pBt.GetPage(RootPage, false); rc != SQLITE_OK {
        return
      }
      eType, iPtrPage, rc = pBt.Get(RootPage)
      if( eType==ROOT_PAGE || eType==FREE_PAGE ){
        rc = SQLITE_CORRUPT_BKPT;
      }
      if( rc!=SQLITE_OK ){
        pRoot.Release()
        return rc;
      }
      assert( eType!=ROOT_PAGE );
      assert( eType!=FREE_PAGE );
      rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0);
      pRoot.Release()

      /* Obtain the page at RootPage */
      if( rc!=SQLITE_OK ){
        return rc;
      }
      if pRoot, rc = pBt.GetPage(RootPage, false); rc != SQLITE_OK {
        return
      }
      rc = sqlite3PagerWrite(pRoot.pDbPage);
      if( rc!=SQLITE_OK ){
        pRoot.Release()
        return rc;
      }
    }else{
      pRoot = pPageMove;
    }

    /* Update the pointer-map and meta-data with the new root-page number. */
	if rc = pBt.Put(RootPage, ROOT_PAGE, 0); rc != SQLITE_OK {
		pRoot.Release()
		return rc
    }

    /* When the new root page was allocated, page 1 was made writable in
    ** order either to increase the database filesize, or to decrement the
    ** freelist count.  Hence, the sqlite3BtreeUpdateMeta() call cannot fail.
    */
    rc = sqlite3BtreeUpdateMeta(p, 4, RootPage);
    if( rc ){
      pRoot.Release()
      return rc;
    }

  }else{
    rc = allocateBtreePage(pBt, &pRoot, &RootPage, 1, 0);
    if( rc ) return rc;
  }
  if( createTabFlags & BTREE_INTKEY ){
    ptfFlags = PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF;
  }else{
    ptfFlags = PTF_ZERODATA | PTF_LEAF;
  }
  zeroPage(pRoot, ptfFlags);
  sqlite3PagerUnref(pRoot.pDbPage);
  assert( (pBt.openFlags & BTREE_SINGLE)==0 || RootPage==2 );
  *piTable = (int)RootPage;
  return SQLITE_OK;
}
 int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){
  int rc;
  p.Lock()
  rc = btreeCreateTable(p, piTable, flags);
  p.Unlock()
  return rc;
}

/*
** Erase the given database page and all its children.  Return
** the page to the freelist.
*/
static int clearDatabasePage(
  BtShared *pBt,           /* The BTree that contains the table */
  PageNumber pgno,               /* Page number to clear */
  int freePageFlag,        /* Deallocate page if true */
  int *pnChange            /* Add number of Cells freed to this counter */
){
  MemoryPage *pPage;
  int rc;
  unsigned char *pCell;
  int i;

  if( pgno>btreePagecount(pBt) ){
    return SQLITE_CORRUPT_BKPT;
  }

  pPage, rc = pBt.GetPageAndInitialize(pgno)
  if( rc ) return rc;
  for(i=0; i<pPage.nCell; i++){
    pCell = pPage.FindCell(i)
    if( !pPage.leaf ){
      rc = clearDatabasePage(pBt, Buffer(pCell).ReadUint32(), 1, pnChange)
      if( rc ) goto cleardatabasepage_out;
    }
    rc = clearCell(pPage, pCell);
    if( rc ) goto cleardatabasepage_out;
  }
  if( !pPage.leaf ){
    rc = clearDatabasePage(pBt, Buffer(pPage.aData[8:]).ReadUint32(), 1, pnChange);
    if( rc ) goto cleardatabasepage_out;
  }else if( pnChange ){
    assert( pPage.intKey );
    *pnChange += pPage.nCell;
  }
  if( freePageFlag ){
    freePage(pPage, &rc);
  }else if( (rc = sqlite3PagerWrite(pPage.pDbPage))==0 ){
    zeroPage(pPage, pPage.aData[0] | PTF_LEAF);
  }

cleardatabasepage_out:
  pPage.Release()
  return rc;
}

/*
** Delete all information from a single table in the database.  iTable is
** the page number of the root of the table.  After this routine returns,
** the root page is empty, but still exists.
**
** This routine will fail with SQLITE_LOCKED if there are any open
** read cursors on the table.  Open write cursors are moved to the
** root of the table.
**
** If pnChange is not NULL, then table iTable must be an intkey table. The
** integer value pointed to by pnChange is incremented by the number of
** entries in the table.
*/
 int sqlite3BtreeClearTable(Btree *p, int iTable, int *pnChange){
  int rc;
  BtShared *pBt = p.pBt;
  p.Lock()
  assert( p.inTrans==TRANS_WRITE );

	if rc = saveAllCursors(pBt, (PageNumber)iTable, 0); SQLITE_OK == rc {
		//	Invalidate all incrblob cursors open on table iTable (assuming iTable is the root of a table b-tree - if it is not, the following call is a no-op).
		p.InvalidateIncrblobCursors(0, true)
		rc = clearDatabasePage(pBt, PageNumber(iTable), 0, pnChange)
	}
	p.Unlock()
	return rc
}

/*
** Erase all information in a table and add the root of the table to
** the freelist.  Except, the root of the principle table (the one on
** page 1) is never added to the freelist.
**
** This routine will fail with SQLITE_LOCKED if there are any open
** cursors on the table.
**
** If AUTOVACUUM is enabled and the page at iTable is not the last
** root page in the database file, then the last root page
** in the database file is moved into the slot formerly occupied by
** iTable and that last slot formerly occupied by the last root page
** is added to the freelist instead of iTable.  In this say, all
** root pages are kept at the beginning of the database file, which
** is necessary for AUTOVACUUM to work right.  *piMoved is set to the
** page number that used to be the last root page in the file before
** the move.  If no page gets moved, *piMoved is set to 0.
** The last root page is recorded in meta[3] and the value of
** meta[3] is updated by this procedure.
*/
static int btreeDropTable(Btree *p, PageNumber iTable, int *piMoved){
  int rc;
  MemoryPage *pPage = 0;
  BtShared *pBt = p.pBt;

  assert( p.inTrans==TRANS_WRITE );

  /* It is illegal to drop a table if any cursors are open on the
  ** database. This is because in auto-vacuum mode the backend may
  ** need to move another root-page to fill a gap left by the deleted
  ** root page. If an open cursor was using this page a problem would
  ** occur.
  **
  ** This error is caught long before control reaches this point.
  */
  if( pBt.pCursor ){
    p.db.ConnectionBlocked(pBt.pCursor.pBtree.db)
    return SQLITE_LOCKED_SHAREDCACHE
  }

  pPage, rc = pBt.GetPage(PageNumber(iTable), false)
  if( rc ) return rc;
  rc = sqlite3BtreeClearTable(p, iTable, 0);
  if( rc ){
    pPage.Release()
    return rc;
  }

  *piMoved = 0;

  if( iTable>1 ){
    if( pBt.autoVacuum ){
      PageNumber maxRootPageNumber;
      sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, &maxRootPageNumber);

      if( iTable==maxRootPageNumber ){
        /* If the table being dropped is the table with the largest root-page
        ** number in the database, put the root page on the free list.
        */
        freePage(pPage, &rc);
        pPage.Release()
        if( rc!=SQLITE_OK ){
          return rc;
        }
      }else{
        /* The table being dropped does not have the largest root-page
        ** number in the database. So move the page that does into the
        ** gap left by the deleted root-page.
        */
        MemoryPage *pMove;
        pPage.Release()
        if pMove, rc = pBt.GetPage(maxRootPageNumber, false); rc != SQLITE_OK {
          return
        }
        rc = relocatePage(pBt, pMove, ROOT_PAGE, 0, iTable, 0);
        pMove.Release()
        if( rc!=SQLITE_OK ){
          return rc;
        }
        pMove, rc = pBt.GetPage(maxRootPageNumber, false)
        freePage(pMove, &rc);
        pMove.Release()
        if( rc!=SQLITE_OK ){
          return rc;
        }
        *piMoved = maxRootPageNumber;
      }

      /* Set the new 'max-root-page' value in the database header. This
      ** is the old value less one, less one more if that happens to
      ** be a root-page number, less one again if that is the
      ** PAGER_MJ_PGNO.
      */
      maxRootPageNumber--;
      while( maxRootPageNumber==PAGER_MJ_PGNO(pBt) || pBt.IsMapPage(maxRootPageNumber) ){
        maxRootPageNumber--;
      }
      assert( maxRootPageNumber!=PAGER_MJ_PGNO(pBt) );

      rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPageNumber);
    }else{
      freePage(pPage, &rc);
      pPage.Release()
    }
  }else{
    /* If sqlite3BtreeDropTable was called on page 1.
    ** This really never should happen except in a corrupt
    ** database.
    */
    zeroPage(pPage, PTF_INTKEY|PTF_LEAF );
    pPage.Release()
  }
  return rc;
}
 int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){
  int rc;
  p.Lock()
  rc = btreeDropTable(p, iTable, piMoved);
  p.Unlock()
  return rc;
}


/*
** This function may only be called if the b-tree connection already
** has a read or write transaction open on the database.
**
** Read the meta-information out of a database file.  Meta[0]
** is the number of free pages currently in the database.  Meta[1]
** through meta[15] are available for use by higher layers.  Meta[0]
** is read-only, the others are read/write.
**
** The schema layer numbers meta values differently.  At the schema
** layer (and the SetCookie and ReadCookie opcodes) the number of
** free pages is not visible.  So Cookie[0] is the same as Meta[1].
*/
 void sqlite3BtreeGetMeta(Btree *p, int idx, uint32 *pMeta){
  BtShared *pBt = p.pBt;

  p.Lock()
  assert( p.inTrans>TRANS_NONE );
  assert( SQLITE_OK == p.querySharedCacheTableLock(MASTER_ROOT, READ_LOCK) )
  assert( pBt.pPage1 );
  assert( idx>=0 && idx<=15 );

  *pMeta = Buffer(pBt.pPage1.aData[36 + (idx * 4):]).ReadUint32()
  p.Unlock()
}

/*
** Write meta-information back into the database.  Meta[0] is
** read-only and may not be written.
*/
 int sqlite3BtreeUpdateMeta(Btree *p, int idx, uint32 iMeta){
  BtShared *pBt = p.pBt;
  unsigned char *pP1;
  int rc;
  assert( idx>=1 && idx<=15 );
  p.Lock()
  assert( p.inTrans==TRANS_WRITE );
  assert( pBt.pPage1!=0 );
  pP1 = pBt.pPage1.aData;
  rc = sqlite3PagerWrite(pBt.pPage1.pDbPage);
  if( rc==SQLITE_OK ){
    Buffer(pP1[36 + (idx * 4):]).WriteUint32(iMeta)
    if( idx==BTREE_INCR_VACUUM ){
      assert( pBt.autoVacuum || iMeta==0 );
      assert( iMeta==0 || iMeta==1 );
      pBt.incrVacuum = (byte)iMeta;
    }
  }
  p.Unlock()
  return rc;
}

/*
** The first argument, pCur, is a cursor opened on some b-tree. Count the
** number of entries in the b-tree and write the result to *pnEntry.
**
** SQLITE_OK is returned if the operation is successfully executed.
** Otherwise, if an error is encountered (i.e. an IO error or database
** corruption) an SQLite error code is returned.
*/
 int sqlite3BtreeCount(Cursor *pCur, int64 *pnEntry){
  int64 nEntry = 0;                      /* Value to return in *pnEntry */
  int rc;                              /* Return code */

  if( pCur.RootPage==0 ){
    *pnEntry = 0;
    return SQLITE_OK;
  }
  rc = pCur.MoveToRoot()

  /* Unless an error occurs, the following loop runs one iteration for each
  ** page in the B-Tree structure (not including overflow pages).
  */
  while( rc==SQLITE_OK ){
    int iIdx;                          /* Index of child node in parent */
    MemoryPage *pPage;                    /* Current page of the b-tree */

    /* If this is a leaf page or the tree is not an int-key tree, then
    ** this page contains countable entries. Increment the entry counter
    ** accordingly.
    */
    pPage = pCur.Pages[pCur.iPage];
    if( pPage.leaf || !pPage.intKey ){
      nEntry += pPage.nCell;
    }

    /* pPage is a leaf node. This loop navigates the cursor so that it
    ** points to the first interior cell that it points to the parent of
    ** the next page in the tree that has not yet been visited. The
    ** pCur.aiIdx[pCur.iPage] value is set to the index of the parent cell
    ** of the page, or to the number of cells in the page if the next page
    ** to visit is the right-child of its parent.
    **
    ** If all pages in the tree have been visited, return SQLITE_OK to the
    ** caller.
    */
    if( pPage.leaf ){
      do {
        if( pCur.iPage==0 ){
          /* All pages of the b-tree have been visited. Return successfully. */
          *pnEntry = nEntry;
          return SQLITE_OK;
        }
        moveToParent(pCur);
      }while ( pCur.aiIdx[pCur.iPage]>=pCur.Pages[pCur.iPage].nCell );

      pCur.aiIdx[pCur.iPage]++;
      pPage = pCur.Pages[pCur.iPage];
    }

    /* Descend to the child node of the cell that the cursor currently
    ** points at. This is the right-child if (iIdx==pPage.nCell).
    */
    iIdx = pCur.aiIdx[pCur.iPage];
    if( iIdx==pPage.nCell ){
      rc = pCur.MoveToChild(Buffer(pPage.aData[pPage.hdrOffset + 8:]).ReadUint32())
    }else{
      rc = pCur.MoveToChild(Buffer(pPage.FindCell(iIdx)).ReadUint32())
    }
  }

  /* An error has occurred. Return an error code. */
  return rc;
}

//	Return the pager associated with a BTree.  This routine is used for testing and debugging only.
func (p *Btree) Pager() *Pager {
	return p.pBt.pPager
}

/*
** Append a message to the error message string.
*/
static void checkAppendMsg(
  IntegrityCheck *pCheck,
  char *zMsg1,
  const char *zFormat,
  ap... string
){
  if( !pCheck.mxErr ) return;
  pCheck.mxErr--;
  pCheck.nErr++;
  if( pCheck.errMsg.nChar ){
    pCheck.errMsg = append(pCheck.errMsg, "\n")
  }
  if( zMsg1 ){
    pCheck.errMsg = append(pCheck.errMsg, zMsg1)
  }
  pCheck.errMsg = fmt.Sprintf(zFormat, ap);
}

/*
** Return non-zero if the bit in the IntegrityCheck.aPgRef[] array that
** corresponds to page iPg is already set.
*/
static int getPageReferenced(IntegrityCheck *pCheck, PageNumber iPg){
  assert( iPg<=pCheck.nPage && sizeof(pCheck.aPgRef[0])==1 );
  return (pCheck.aPgRef[iPg/8] & (1 << (iPg & 0x07)));
}

/*
** Set the bit in the IntegrityCheck.aPgRef[] array that corresponds to page iPg.
*/
static void setPageReferenced(IntegrityCheck *pCheck, PageNumber iPg){
  assert( iPg<=pCheck.nPage && sizeof(pCheck.aPgRef[0])==1 );
  pCheck.aPgRef[iPg/8] |= (1 << (iPg & 0x07));
}


/*
** Add 1 to the reference count for page iPage.  If this is the second
** reference to the page, add an error message to pCheck.zErrMsg.
** Return 1 if there are 2 ore more references to the page and 0 if
** if this is the first reference to the page.
**
** Also check that the page number is in bounds.
*/
static int checkRef(IntegrityCheck *pCheck, PageNumber iPage, char *zContext){
  if( iPage==0 ) return 1;
  if( iPage>pCheck.nPage ){
    checkAppendMsg(pCheck, zContext, "invalid page number %d", iPage);
    return 1;
  }
  if( getPageReferenced(pCheck, iPage) ){
    checkAppendMsg(pCheck, zContext, "2nd reference to page %d", iPage);
    return 1;
  }
  setPageReferenced(pCheck, iPage);
  return 0;
}

/*
** Check that the entry in the pointer-map for page iChild maps to
** page iParent, pointer type ptrType. If not, append an error message
** to pCheck.
*/
static void checkPtrmap(
  IntegrityCheck *pCheck,   /* Integrity check context */
  PageNumber iChild,           /* Child page number */
  byte eType,              /* Expected pointer map type */
  PageNumber iParent,          /* Expected pointer map parent page number */
  char *zContext         /* Context description (used for error msg) */
){
	int rc;
	byte ePtrmapType;
	PageNumber iPtrmapParent;

	if ePtrmapType, iPtrmapParent, rc = pCheck.pBt.Get(iChild); rc != SQLITE_OK {
		checkAppendMsg(pCheck, zContext, "Failed to read ptrmap key=%d", iChild)
		return
	}

	if ePtrmapType != eType || iPtrmapParent != iParent {
		checkAppendMsg(pCheck, zContext, "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)", iChild, eType, iParent, ePtrmapType, iPtrmapParent)
	}
}

/*
** Check the integrity of the freelist or of an overflow page list.
** Verify that the number of pages on the list is N.
*/
static void checkList(
  IntegrityCheck *pCheck,  /* Integrity checking context */
  int isFreeList,       /* True for a freelist.  False for overflow page list */
  int iPage,            /* Page number for first page in the list */
  int N,                /* Expected number of pages in the list */
  char *zContext        /* Context for error messages */
){
  int i;
  int expected = N;
  int iFirst = iPage;
  while( N-- > 0 && pCheck.mxErr ){
    DbPage *pOvflPage;
    unsigned char *pOvflData;
    if( iPage<1 ){
      checkAppendMsg(pCheck, zContext,
         "%d of %d pages missing from overflow list starting at %d",
          N+1, expected, iFirst);
      break;
    }
    if( checkRef(pCheck, iPage, zContext) ) break;
    if rc, pOvflPage = pCheck.pPager.Acquire(PageNumber(iPage), false); rc != SQLITE_OK {
      checkAppendMsg(pCheck, zContext, "failed to get page %d", iPage);
      break;
    }
    pOvflData = pOvflPage.GetData()
    if( isFreeList ){
      int n = Buffer(pOvflData[4:]).ReadUint32()
      if( pCheck.pBt.autoVacuum ){
        checkPtrmap(pCheck, iPage, FREE_PAGE, 0, zContext);
      }
      if( n>(int)pCheck.pBt.usableSize/4-2 ){
        checkAppendMsg(pCheck, zContext,
           "freelist leaf count too big on page %d", iPage);
        N--;
      }else{
        for(i=0; i<n; i++){
          PageNumber iFreePage = Buffer(pOvflData[8 + (i * 4):]).ReadUint32()
          if( pCheck.pBt.autoVacuum ){
            checkPtrmap(pCheck, iFreePage, FREE_PAGE, 0, zContext);
          }
          checkRef(pCheck, iFreePage, zContext);
        }
        N -= n;
      }
    }
    else{
      /* If this database supports auto-vacuum and iPage is not the last
      ** page in this overflow list, check that the pointer-map entry for
      ** the following page matches iPage.
      */
      if( pCheck.pBt.autoVacuum && N>0 ){
        i = Buffer(pOvflData).ReadUint32()
        checkPtrmap(pCheck, i, SECONDARY_OVERFLOW_PAGE, iPage, zContext);
      }
    }
    iPage = Buffer(pOvflData).ReadUint32()
    sqlite3PagerUnref(pOvflPage);
  }
}

/*
** Do various sanity checks on a single page of a tree.  Return
** the tree depth.  Root pages return 0.  Parents of root pages
** return 1, and so forth.
**
** These checks are done:
**
**      1.  Make sure that cells and freeblocks do not overlap
**          but combine to completely cover the page.
**  NO  2.  Make sure cell keys are in order.
**  NO  3.  Make sure no key is less than or equal to zLowerBound.
**  NO  4.  Make sure no key is greater than or equal to zUpperBound.
**      5.  Check the integrity of overflow pages.
**      6.  Recursively call checkTreePage on all children.
**      7.  Verify that the depth of all children is the same.
**      8.  Make sure this page is at least 33% full or else it is
**          the root of the tree.
*/
static int checkTreePage(
  IntegrityCheck *pCheck,  /* Context for the sanity check */
  int iPage,            /* Page number of the page to check */
  char *zParentContext, /* Parent context */
  int64 *pnParentMinKey,
  int64 *pnParentMaxKey
){
  MemoryPage *pPage;
  int i, rc, depth, d2, pgno, cnt;
  int hdr, cellStart;
  int nCell;
  byte *data;
  BtShared *pBt;
  int usableSize;
  char *hit = 0;
  int64 nMinKey = 0;
  int64 nMaxKey = 0;

  zContext := fmt.Sprintf("Page %v: ", iPage);

  //	Check that the page exists
  pBt = pCheck.pBt;
  usableSize = pBt.usableSize;
  if( iPage==0 ) return 0;
  if( checkRef(pCheck, iPage, zParentContext) ) return 0;
  if pPage, rc = pBt.GetPage(PageNumber(iPage), false); rc != 0 {
    checkAppendMsg(pCheck, zContext, "unable to get the page. error code=%d", rc)
    return 0
  }

	//	Clear MemoryPage.isInit to make sure the corruption detection code in MemoryPage::Initialize() is executed.
  pPage.isInit = false
  if( (rc = pPage.Initialize()) != 0 ){
    assert( rc==SQLITE_CORRUPT );  /* The only possible error from InitPage */
    checkAppendMsg(pCheck, zContext, "Initialize() returns error code %d", rc);
    pPage.Release()
    return 0;
  }

  //	Check out all the cells.
  depth = 0;
  for(i=0; i<pPage.nCell && pCheck.mxErr; i++){
    pCell		*byte
    sz			uint32
    info		CellInfo

    //	Check payload overflow pages
	zContext = fmt.Sprintf("On tree page %v cell %v: ", iPage, i);
    pCell = pPage.FindCell(i)
    info.ParsePtr(pPage, pCell)
    sz = info.nData;
    if( !pPage.intKey ) sz += (int)info.nKey;
    //	For intKey pages, check that the keys are in order.
    else if( i==0 ) nMinKey = nMaxKey = info.nKey;
    else{
      if( info.nKey <= nMaxKey ){
        checkAppendMsg(pCheck, zContext, "Rowid %lld out of order (previous was %lld)", info.nKey, nMaxKey);
      }
      nMaxKey = info.nKey;
    }
    assert( sz==info.nPayload );
    if (sz>info.nLocal) && (&pCell[info.iOverflow]<=&pPage.aData[pBt.usableSize]) {
      int nPage = (sz - info.nLocal + usableSize - 5)/(usableSize - 4);
      PageNumber pgnoOvfl = Buffer(pCell[info.iOverflow:]).ReadUint32()
      if( pBt.autoVacuum ){
        checkPtrmap(pCheck, pgnoOvfl, FIRST_OVERFLOW_PAGE, iPage, zContext);
      }
      checkList(pCheck, 0, pgnoOvfl, nPage, zContext);
    }

    //	Check sanity of left child page.
    if( !pPage.leaf ){
      pgno = Buffer(pCell).ReadUint32()
      if( pBt.autoVacuum ){
        checkPtrmap(pCheck, pgno, NON_ROOT_BTREE_PAGE, iPage, zContext);
      }
      d2 = checkTreePage(pCheck, pgno, zContext, &nMinKey, i==0 ? NULL : &nMaxKey);
      if( i>0 && d2!=depth ){
        checkAppendMsg(pCheck, zContext, "Child page depth differs");
      }
      depth = d2;
    }
  }

  if( !pPage.leaf ){
    pgno = Buffer(pPage.aData[pPage.hdrOffset + 8:]).ReadUint32()
    Context = fmt.Sprintf("On page %v at right child: ", iPage);
    if( pBt.autoVacuum ){
      checkPtrmap(pCheck, pgno, NON_ROOT_BTREE_PAGE, iPage, zContext);
    }
    checkTreePage(pCheck, pgno, zContext, NULL, !pPage.nCell ? NULL : &nMaxKey);
  }

  //	For intKey leaf pages, check that the min/max keys are in order with any left/parent/right pages.
  if pPage.leaf && pPage.intKey {		//	if we are a left child page
    if pnParentMinKey {					//	if we are the left most child page
      if !pnParentMaxKey {
        if nMaxKey > *pnParentMinKey {
          checkAppendMsg(pCheck, zContext, "Rowid %lld out of order (max larger than parent min of %lld)", nMaxKey, *pnParentMinKey)
        }
      }else{
        if nMinKey <= *pnParentMinKey {
          checkAppendMsg(pCheck, zContext, "Rowid %lld out of order (min less than parent min of %lld)", nMinKey, *pnParentMinKey)
        }
        if nMaxKey > *pnParentMaxKey {
          checkAppendMsg(pCheck, zContext, "Rowid %lld out of order (max larger than parent max of %lld)", nMaxKey, *pnParentMaxKey)
        }
        *pnParentMinKey = nMaxKey;
      }
    } else if pnParentMaxKey {			//	 else if we're a right child page
      if nMinKey <= *pnParentMaxKey {
        checkAppendMsg(pCheck, zContext, "Rowid %lld out of order (min less than parent max of %lld)", nMinKey, *pnParentMaxKey)
      }
    }
  }

  //	Check for complete coverage of the page
  data := Buffer(pPage.aData)
  hdr = pPage.hdrOffset;
  hit = sqlite3PageMalloc( pBt.pageSize );
    contentOffset := data[hdr + 5].ReadCompressedIntNotZero()
    assert( contentOffset<=usableSize );
    memset(hit+contentOffset, 0, usableSize-contentOffset);
    memset(hit, 1, contentOffset);
    nCell = data[hdr + 3].ReadUint16()
    cellStart = hdr + 12 - 4*pPage.leaf;
    for(i=0; i<nCell; i++){
      pc := int(data[cellStart + (i * 2)].ReadUint16())
      uint32 size = 65536;
      int j;
      if( pc<=usableSize-4 ){
        size = pPage.cellSize(&data[pc])
      }
      if( (int)(pc+size-1)>=usableSize ){
        checkAppendMsg(pCheck, 0, "Corruption detected in cell %d on page %d",i,iPage)
      }else{
        for(j=pc+size-1; j>=pc; j--) hit[j]++;
      }
    }
    i = data[hdr + 1].ReadUint16()
    while( i>0 ){
      int size, j;
      assert( i<=usableSize-4 );
      size = data[i + 2].ReadUint16()
      assert( i+size<=usableSize );
      for(j=i+size-1; j>=i; j--) hit[j]++;
      j = data[i].ReadUint16()
      assert( j==0 || j>i+size );
      assert( j<=usableSize-4 );
      i = j;
    }
    for(i=cnt=0; i<usableSize; i++){
      if( hit[i]==0 ){
        cnt++;
      }else if( hit[i]>1 ){
        checkAppendMsg(pCheck, 0, "Multiple uses for byte %d of page %d", i, iPage);
        break;
      }
    }
    if( cnt!=data[hdr+7] ){
      checkAppendMsg(pCheck, 0, "Fragmentation of %d bytes reported as %d on page %d", cnt, data[hdr+7], iPage);
    }
  sqlite3PageFree(hit);
  pPage.Release()
  return depth+1;
}

/*
** This routine does a complete check of the given BTree file.  aRoot[] is
** an array of pages numbers were each page number is the root page of
** a table.  nRoot is the number of entries in aRoot.
**
** A read-only or read-write transaction must be opened before calling
** this function.
**
** Write the number of error seen in *pnErr.  Except for some memory
** allocation errors,  an error message held in memory obtained from
** malloc is returned if *pnErr is non-zero.  If *pnErr==0 then NULL is
** returned.  If a memory allocation error occurs, NULL is returned.
*/
func sqlite3BtreeIntegrityCheck(p *Btree, aRoot *int,		//	An array of root pages numbers for individual trees
	nRoot	int,	//	Number of entries in aRoot[]
	mxErr	int,	//	Stop reporting errors after this many
	pnErr	*int	//	Write number of errors seen to this variable
) *byte {
	zErr			[100]byte

	btree := p.pBt
	p.Lock()
	assert( p.inTrans>TRANS_NONE && btree.inTransaction>TRANS_NONE )
	nRef := sqlite3PagerRefcount(btree.pPager)
	check := &IntegrityCheck{ Btree: btree, Pager: btree.Pager, PageNumber: btreePagecount(btree), MaxErr: mxErr }
	*pnErr = 0
	if check.Page == 0 {
		p.Unlock()
		return 0
	}

	check.PgRef = sqlite3MallocZero((check.PageNumber / 8) + 1)
	if check.PgRef == nil {
		*pnErr = 1
		p.Unlock()
		return 0
	}

	i := PAGER_MJ_PGNO(btree)
	if i <= check.PageNumber {
		setPageReferenced(check, i)
	}
	check.errMsg = zErr
	check.errMsg.useMalloc = 2;

	//	Check the integrity of the freelist
	checkList(check, 1, Buffer(btree.pPage1.aData[32:]).ReadUint32(), Buffer(btree.pPage1.aData[36:]).ReadUint32(), "Main freelist: ")

	//	Check all the tables.
	for i := 0; i < nRoot && check.maxErr; i++ {
		switch {
		case aRoot[i] == 0:
			continue
		case btree.autoVacuum && aRoot[i] > 1:
			checkPtrmap(check, aRoot[i], ROOT_PAGE, 0, 0)
		}
		checkTreePage(check, aRoot[i], "List of tree roots: ", NULL, NULL)
	}

	//	Make sure every page in the file is referenced
	for i := 1; i <= check.PageNumber && check.maxErr; i++ {
		//	If the database supports auto-vacuum, make sure no tables contain references to pointer-map pages.
		if getPageReferenced(check, i) == 0 && (btree.Pageno(i) != i || !btree.autoVacuum) {
			checkAppendMsg(check, 0, "Page %d is never used", i)
		}
		if getPageReferenced(check, i) != 0 && (btree.Pageno(i) == i && btree.autoVacuum) {
			checkAppendMsg(check, 0, "Pointer map page %d is referenced", i)
		}
	}

	//	Make sure this analysis did not leave any unref() pages. This is an internal consistency check; an integrity check of the integrity check.
	if nRef != sqlite3PagerRefcount(pBt.pPager) {
		checkAppendMsg(check, 0, "Outstanding page count goes from %d to %d during this analysis", nRef, sqlite3PagerRefcount(btree.pPager))
	}

	//	Clean  up and report errors.
	p.Unlock()
	check.aPgRef = nil
	*pnErr = check.Errors
	if check.Errors == 0 {
		check.errMsg = ""
	}
	return check.errMsg
}

/*
** Return the full pathname of the underlying database file.
**
** The pager filename is invariant as long as the pager is
** open so it is safe to access without the BtShared mutex.
*/
 const char *sqlite3BtreeGetFilename(Btree *p){
  assert( p.pBt.pPager!=0 );
  return sqlite3PagerFilename(p.pBt.pPager);
}

/*
** Return the pathname of the journal file for this database. The return
** value of this routine is the same regardless of whether the journal file
** has been created or not.
**
** The pager journal filename is invariant as long as the pager is
** open so it is safe to access without the BtShared mutex.
*/
 const char *sqlite3BtreeGetJournalname(Btree *p){
  assert( p.pBt.pPager!=0 );
  return sqlite3PagerJournalname(p.pBt.pPager);
}

//	Return non-zero if a transaction is active.
func (p *Btree) IsInTrans() bool {
	return p != nil && p.inTrans == TRANS_WRITE
}

//	Run a checkpoint on the Btree passed as the first argument.
//	Return SQLITE_LOCKED if this or any other connection has an open transaction on the shared-cache the argument Btree is connected to.
//	Parameter eMode is one of SQLITE_CHECKPOINT_PASSIVE, FULL or RESTART.
int sqlite3BtreeCheckpoint(Btree *p, int eMode, int *pnLog, int *pnCkpt){
  int rc = SQLITE_OK;
  if( p ){
    BtShared *pBt = p.pBt;
    p.Lock()
    if( pBt.inTransaction!=TRANS_NONE ){
      rc = SQLITE_LOCKED;
    }else{
      rc = sqlite3PagerCheckpoint(pBt.pPager, eMode, pnLog, pnCkpt);
    }
    p.Unlock()
  }
  return rc;
}

/*
** Return non-zero if a read (or write) transaction is active.
*/
 int sqlite3BtreeIsInReadTrans(Btree *p){
  assert( p );
  return p.inTrans!=TRANS_NONE;
}

 int sqlite3BtreeIsInBackup(Btree *p){
  assert( p );
  return p.nBackup!=0;
}

//	This function returns a pointer to a blob of memory associated with a single shared-btree. The memory is used by client code for its own purposes (for example, to store a high-level schema associated with the shared-btree). The btree layer manages reference counting issues.
//	The first time this is called on a shared-btree, nBytes bytes of memory are allocated, zeroed, and returned to the caller. For each subsequent call the nBytes parameter is ignored and a pointer to the same blob of memory returned.
//	If the nBytes parameter is 0 and the blob of memory has not yet been allocated, a null pointer is returned. If the blob has already been allocated, it is returned as normal.
//	Just before the shared-btree is closed, the function passed as the xFree argument when the memory allocation was made is invoked on the blob of allocated memory.

func (p *Btree) Schema(allocate bool, xFree func(interface{}) interface{}) (*Schema) {
	pBt := p.pBt
	p.Lock()
	if pBt.Schema == nil && allocate {
		pBt.Schema = &Schema{}
		pBt.xFreeSchema = xFree
	}
	p.Unlock()
	return pBt.Schema
}

//	Return SQLITE_LOCKED_SHAREDCACHE if another user of the same shared btree as the argument handle holds an exclusive lock on the sqlite_master table. Otherwise SQLITE_OK.
func (p *Btree) SchemaLocked() (rc int) {
	p.Lock()
	rc = p.querySharedCacheTableLock(MASTER_ROOT, READ_LOCK)
	assert( rc == SQLITE_OK || rc == SQLITE_LOCKED_SHAREDCACHE )
	p.Unlock()
	return rc
}

/*
** Obtain a lock on the table whose root page is iTab.  The
** lock is a write lock if isWritelock is true or a read lock
** if it is false.
*/
 int sqlite3BtreeLockTable(Btree *p, int iTab, byte isWriteLock){
  int rc = SQLITE_OK;
  assert( p.inTrans!=TRANS_NONE );
  if( p.sharable ){
    byte lockType = READ_LOCK + isWriteLock;
    assert( READ_LOCK+1==WRITE_LOCK );
    assert( isWriteLock==0 || isWriteLock==1 );

    p.Lock()
    rc = p.querySharedCacheTableLock(iTab, lockType)
    if( rc==SQLITE_OK ){
      rc = setSharedCacheTableLock(p, iTab, lockType);
    }
    p.Unlock()
  }
  return rc;
}

/*
** Argument pCsr must be a cursor opened for writing on an
** INTKEY table currently pointing at a valid table entry.
** This function modifies the data stored as part of that entry.
**
** Only the data content may only be modified, it is not possible to
** change the length of the data stored. If this function is called with
** parameters that attempt to write past the end of the existing data,
** no modifications are made and SQLITE_CORRUPT is returned.
*/
 int sqlite3BtreePutData(Cursor *pCsr, uint32 offset, uint32 amt, void *z){
  int rc;
  assert( pCsr.isIncrblobHandle );

  rc = restoreCursorPosition(pCsr);
  if( rc!=SQLITE_OK ){
    return rc;
  }
  assert( pCsr.eState!=CURSOR_REQUIRESEEK );
  if( pCsr.eState!=CURSOR_VALID ){
    return SQLITE_ABORT;
  }

  /* Check some assumptions:
  **   (a) the cursor is open for writing,
  **   (b) there is a read/write transaction open,
  **   (c) the connection holds a write-lock on the table (if required),
  **   (d) there are no conflicting read-locks, and
  **   (e) the cursor points at a valid row of an intKey table.
  */
  if( !pCsr.Writable ){
    return SQLITE_READONLY;
  }
  assert( (pCsr.pBt.Flags & BTS_READ_ONLY)==0
              && pCsr.pBt.inTransaction==TRANS_WRITE );
  assert( hasSharedCacheTableLock(pCsr.pBtree, pCsr.RootPage, 0, 2) );
  assert( !hasReadConflicts(pCsr.pBtree, pCsr.RootPage) );
  assert( pCsr.Pages[pCsr.iPage].intKey );

  return accessPayload(pCsr, offset, amt, (unsigned char *)z, 1);
}

/*
** Set a flag on this cursor to cache the locations of pages from the
** overflow list for the current row. This is used by cursors opened
** for incremental blob IO only.
**
** This function sets a flag only. The actual page location cache
** (stored in Cursor.OverflowCache[]) is allocated and used by function
** accessPayload() (the worker function for sqlite3BtreeData() and
** sqlite3BtreePutData()).
*/
void sqlite3BtreeCacheOverflow(Cursor *pCur){
	pCur.OverflowCache = nil
	pCur.isIncrblobHandle = 1
}

/*
** Set both the "read version" (single byte at byte offset 18) and
** "write version" (single byte at byte offset 19) fields in the database
** header to iVersion.
*/
 int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){
  BtShared *pBt = pBtree.pBt;
  int rc;                         /* Return code */

	if iVersion != 1 && iVersion != 2 {
		panic(iVersion)
	}

  /* If setting the version fields to 1, do not automatically open the
  ** WAL connection, even if the version fields are currently set to 2.
  */
  pBt.Flags &= ~BTS_NO_WAL;
  if( iVersion==1 ) pBt.Flags |= BTS_NO_WAL;

  rc = sqlite3BtreeBeginTrans(pBtree, 0);
  if( rc==SQLITE_OK ){
    byte *aData = pBt.pPage1.aData;
    if( aData[18]!=(byte)iVersion || aData[19]!=(byte)iVersion ){
      rc = sqlite3BtreeBeginTrans(pBtree, 2);
      if( rc==SQLITE_OK ){
        rc = sqlite3PagerWrite(pBt.pPage1.pDbPage);
        if( rc==SQLITE_OK ){
          aData[18] = (byte)iVersion;
          aData[19] = (byte)iVersion;
        }
      }
    }
  }

  pBt.Flags &= ~BTS_NO_WAL;
  return rc;
}
