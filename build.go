import "crypto/rand"


/* This file contains C code routines that are called by the SQLite parser
** when syntax rules are reduced.  The routines in this file handle the
** following kinds of SQL syntax:
**
**     CREATE TABLE
**     DROP TABLE
**     CREATE INDEX
**     DROP INDEX
**     creating ID lists
**     BEGIN TRANSACTION
**     COMMIT
**     ROLLBACK
*/

/*
** This routine is called when a new SQL statement is beginning to
** be parsed.  Initialize the pParse structure as needed.
*/
 void sqlite3BeginParse(Parse *pParse, int explainFlag){
  pParse.explain = (byte)explainFlag;
  pParse.nVar = 0;
}

/*
** The TableLock structure is only used by the Parse::TableLock() and
** codeTableLocks() functions.
*/
struct TableLock {
  int iDb;             /* The database containing the table to be locked */
  int iTab;            /* The root page of the table to be locked */
  byte isWriteLock;      /* True for write lock.  False for a read lock */
  const char *Name;   /* Name of the table */
};

//	Record the fact that we want to lock a table at run-time.  
//	The table to be locked has root page iTab and is found in database iDb. A read or a write lock can be taken depending on isWritelock.
//	This routine just records the fact that the lock is desired. The code to make the lock occur is generated by a later call to codeTableLocks() which occurs during sqlite3FinishCoding().
func (pParse *Parse) TableLock(iDb, iTab int, table string, isWriteLock bool) {
	p		*TableLock
	assert( iDb >= 0 )

	pToplevel := pParse.Toplevel()
	for i := 0; i < pToplevel.nTableLock; i++ {
		p = &pToplevel.aTableLock[i]
		if p.iDb == iDb && p.iTab == iTab {
			p.isWriteLock = (p.isWriteLock || isWriteLock)
			return
		}
	}

	nBytes := sizeof(TableLock) * (pToplevel.nTableLock + 1)
	if pToplevel.aTableLock = sqlite3DbReallocOrFree(pToplevel.db, pToplevel.aTableLock, nBytes); pToplevel.aTableLock != nil {
		p = &pToplevel.aTableLock[pToplevel.nTableLock++]
		p.iDb = iDb
		p.iTab = iTab
		p.isWriteLock = isWriteLock
		p.Name = name
	} else {
		pToplevel.nTableLock = 0
		pToplevel.db.mallocFailed = true
	}
}

/*
** Code an OP_TableLock instruction for each table locked by the
** statement (configured by calls to Parse::TableLock()).
*/
static void codeTableLocks(Parse *pParse){
  int i;
  Vdbe *pVdbe; 

  pVdbe = pParse.GetVdbe()
  assert( pVdbe!=0 ); /* GetVdbe() cannot fail: VDBE already allocated */

  for(i=0; i<pParse.nTableLock; i++){
    TableLock *p = &pParse.aTableLock[i];
    int p1 = p.iDb;
    sqlite3VdbeAddOp4(pVdbe, OP_TableLock, p1, p.iTab, p.isWriteLock,
                      p.Name, P4_STATIC);
  }
}

/*
** This routine is called after a single SQL statement has been
** parsed and a VDBE program to execute that statement has been
** prepared.  This routine puts the finishing touches on the
** VDBE program and resets the pParse structure for the next
** parse.
**
** Note that if an error occurred, it might be the case that
** no VDBE code was generated.
*/
 void sqlite3FinishCoding(Parse *pParse){
  sqlite3 *db;
  Vdbe *v;

  db = pParse.db;
  if( db.mallocFailed ) return;
  if( pParse.nested ) return;
  if( pParse.nErr ) return;

  /* Begin by generating some termination code at the end of the
  ** vdbe program
  */
  v = pParse.GetVdbe()
  assert( !pParse.isMultiWrite 
       || sqlite3VdbeAssertMayAbort(v, pParse.mayAbort));
  if( v ){
    v.AddOp0(OP_Halt);

    /* The cookie mask contains one bit for each database file open.
    ** (Bit 0 is for main, bit 1 is for temp, and so forth.)  Bits are
    ** set for each database that is used.  Generate code to start a
    ** transaction on each used database and to verify the schema cookie
    ** on each used database.
    */
    if( pParse.cookieGoto>0 ){
      yDbMask mask;
      int iDb;
      v.JumpHere(pParse.cookieGoto - 1)
      for(iDb=0, mask=1; iDb<db.nDb; mask<<=1, iDb++){
        if( (mask & pParse.cookieMask)==0 ) continue;
        sqlite3VdbeUsesBtree(v, iDb);
        v.AddOp2(OP_Transaction, iDb, (mask & pParse.writeMask)!=0);
        if( db.init.busy==0 ){
          v.AddOp3(OP_VerifyCookie, iDb, pParse.cookieValue[iDb], db.Databases[iDb].Schema.iGeneration);
        }
      }
      {
        int i;
        for(i=0; i<pParse.nVtabLock; i++){
          char *vtab = (char *)sqlite3GetVTable(db, pParse.apVtabLock[i]);
          sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB);
        }
        pParse.nVtabLock = 0;
      }

      /* Once all the cookies have been verified and transactions opened, 
      ** obtain the required table-locks. This is a no-op unless the 
      ** shared-cache feature is enabled.
      */
      codeTableLocks(pParse);

      /* Initialize any AUTOINCREMENT data structures required.
      */
      sqlite3AutoincrementBegin(pParse);

      /* Finally, jump back to the beginning of the executable code. */
      v.AddOp2(OP_Goto, 0, pParse.cookieGoto);
    }
  }


  /* Get the VDBE program ready for execution
  */
  if( v && pParse.nErr==0 && !db.mallocFailed ){
    assert( pParse.iCacheLevel==0 );  /* Disables and re-enables match */
    /* A minimum of one cursor is required if autoincrement is used
    *  See ticket [a696379c1f08866] */
    if( pParse.pAinc!=0 && pParse.nTab==0 ) pParse.nTab = 1;
    sqlite3VdbeMakeReady(v, pParse);
    pParse.rc = SQLITE_DONE;
    pParse.colNamesSet = 0;
  }else{
    pParse.rc = SQLITE_ERROR;
  }
  pParse.nTab = 0;
  pParse.nMem = 0;
  pParse.nSet = 0;
  pParse.nVar = 0;
  pParse.cookieMask = 0;
  pParse.cookieGoto = 0;
}

/*
** Run the parser and code generator recursively in order to generate
** code for the SQL statement given onto the end of the pParse context
** currently under construction.  When the parser is run recursively
** this way, the final OP_Halt is not appended and other initialization
** and finalization steps are omitted because those are handling by the
** outermost parser.
**
** Not everything is nestable.  This facility is designed to permit
** INSERT, UPDATE, and DELETE operations against SQLITE_MASTER.  Use
** care if you decide to try to use this routine for some other purposes.
*/
 void sqlite3NestedParse(Parse *pParse, zFormat string, ap... string) {
  zErrMsg = ""
  db := pParse.db
# define SAVE_SZ  (sizeof(Parse) - offsetof(Parse,nVar))
  char saveBuf[SAVE_SZ];

  if pParse.nErr {
	  return
	}
  assert( pParse.nested<10 );  /* Nesting should only be of limited depth */

  zSql := fmt.Sprintf(zFormat, ap)

  if( zSql==0 ){
    return;   /* A malloc must have failed */
  }
  pParse.nested++;
  memcpy(saveBuf, &pParse.nVar, SAVE_SZ);
  memset(&pParse.nVar, 0, SAVE_SZ);
  pParse.Run(zSql, &zErrMsg)
  zErrMsg = nil
  zSql = nil
  memcpy(&pParse.nVar, saveBuf, SAVE_SZ);
  pParse.nested--;
}

//	Locate the in-memory structure that describes a particular database table given the name of that table and (optionally) the name of the database containing the table.  Return NULL if not found.
//	If zDatabase is 0, all databases are searched for the table and the first matching table is returned.  (No checking for duplicate table names is done.)  The search order is TEMP first, then MAIN, then any auxiliary databases added using the ATTACH command.
//	See also LocateTable().
func (fb *sqlite3) FindTable(table, database string) (p *Table) {
	assert( table != "" )
	nName := sqlite3Strlen30(table)
	//	All mutexes are required for schema access.  Make sure we hold them.
	assert( database != "" )
	for i, _ := range db.Databases {
		int j
		//	Search TEMP before MAIN
		if i < 2 {
			j = i^1
		} else {
			j = i
		}
		if database != "" && !CaseInsensitiveMatch(database, db.Databases[j].Name) {
			continue
		}
		if p = &db.Databases[j].Schema.Tables[Name]; p != nil {
			break
		}
	}
	return p
}

//	Locate the in-memory structure that describes a particular database table given the name of that table and (optionally) the name of the database containing the table. Return NULL if not found. Also leave an error message in pParse.zErrMsg.
//	The difference between this routine and FindTable() is that this routine leaves an error message in pParse.zErrMsg where FindTable() does not.
func (pParse *Parse) LocateTable(name, database string, isView bool) (p *Table) {
	if pParse.ReadSchema() == SQLITE_OK {
		if p = pParse.db.FindTable(Name, zDbase); p == nil {
			message		string
			if isView {
				message = "no such view"
			} else {
				message = "no such table"
			}
			if database != "" {
				pParse.SetErrorMsg("%v: %v.%v", zMsg, database, name)
			} else {
				pParse.SetErrorMsg("%v: %v", zMsg, Name)
			}
			pParse.checkSchema = true
		}
	}
	return
}

//	Locate the in-memory structure that describes a particular index given the name of that index and the name of the database that contains the index. Return nil if not found.
//	If zDatabase is 0, all databases are searched for the table and the first matching index is returned.  (No checking for duplicate index names is done.)  The search order is TEMP first, then MAIN, then any auxiliary databases added using the ATTACH command.
func (db *sqlite3) FindIndex(Name, zDb string) (p *Index) {
	 nName := len(Name)
	//	All mutexes are required for schema access. Make sure we hold them.
	assert( zDb != "" )
	for i, _ := range db.Databases {
		if i < 2 {
			//	Search TEMP before MAIN
			j = i ^ 1
		} else {
			j = i
		}
		schema := db.Databases[j].Schema
		assert( schema )
		if zDb != "" && !CaseInsensitiveMatch(zDb, db.Databases[j].Name) {
			continue
		}
		if p = schema.Indices[Name];p != nil {
			break
		}
	}
	return
}

//	For the index called zIdxName which is found in the database iDb, unlink that index from its Table then remove the index from the index hash table and free all memory structures associated with the index.
func (db *sqlite3) UnlinkAndDeleteIndex(iDb int, name string) {
	indices := &db.Databases[iDb].Schema.Indices
	index := indices[name]
	delete(indices, name)
	if index != nil {
		delete(index.pTable.Indices, name)
		db.DeleteIndexSamples(index)
	}
	db.flags |= SQLITE_InternChanges
}

//	Erase all schema information from the in-memory hash tables of a single database. This routine is called to reclaim memory before the database closes. It is also called during a rollback if there were schema changes during the transaction or if a schema-cookie mismatch occurs.
//	If iDb < 0 then reset the internal schema tables for all database files. If iDb >= 0 then reset the internal schema for only the single file indicated.
func (db *sqlite3) ResetInternalSchema(iDb int) {
	assert( iDb < len(db.Databases) )
	if iDb >= 0 {
		//	Case 1:  Reset the single schema identified by iDb
		pDb := &db.Databases[iDb]
		assert( pDb.Schema != 0 )
		ClearSchema(pDb.Schema)

		//	If any database other than TEMP is reset, then also reset TEMP since TEMP might be holding triggers that reference tables in the other database.
		if iDb != 1 {
			pDb = &db.Databases[1]
			assert( pDb.Schema != nil )
			ClearSchema(pDb.Schema)
		}
		return
	}
	//	Case 2 (from here to the end): Reset all schemas for all attached databases.
	assert( iDb < 0 )
	db.LockAll()
	for i, _ := range db.Databases {
		if pDb := &db.Databases[i]; pDb.Schema != nil {
			ClearSchema(pDb.Schema)
		}
	}
	db.flags &= ~SQLITE_InternChanges
	db.VtabUnlockList()
	db.LeaveBtreeAll()

	//	If one or more of the auxiliary database files has been closed, then remove them from the auxiliary database list. We take the opportunity to do this here since we have just deleted all of the schema hash tables and therefore do not have to make any changes to any of those tables.
	j := 2
	for i := j; i < len(db.Databases); i++ {
		if pDb = &db.Databases[i]; pDb.pBt == nil {
			pDb.Name = ""
		} else {
			if j < i {
				db.Databases[j] = db.Databases[i]
			}
			j++
		}
	}

	//	WTF!!!!!!	/////////////////////////////////////////////
	memset(&db.Databases[j], 0, (db.nDb - j) * sizeof(db.Databases[j]))
	db.nDb = j
	/////////////////////////////////////////////////////////////

	if len(db.Databases) <= 2 && db.Databases != db.DatabasesStatic {
		copy(db.DatabasesStatic, db.Databases[:2])
		db.Databases = db.DatabasesStatic
	}
}

//	This routine is called when a commit occurs.
func (db *sqlite3) CommitInternalChanges() {
	db.flags &= ~SQLITE_InternChanges
}

/*
** Delete memory allocated for the column names of a table or view (the
** Table.Columns[] array).
*/
static void sqliteDeleteColumnNames(sqlite3 *db, Table *pTable){
  int i;
  Column *pCol;
  assert( pTable!=0 );
  if( (pCol = pTable.Columns)!=0 ){
    for(i=0; i<pTable.nCol; i++, pCol++){
      pCol.Name = nil
      db.ExprDelete(pCol.pDflt)
      pCol.zDflt = nil
      pCol.zType = nil
      pCol.zColl = nil
    }
    pTable.Columns = nil
  }
}

//	Remove the memory data structures associated with the given Table. No changes are made to disk by this routine.
//	This routine just deletes the data structure. It does not unlink the table data structure from the hash table. But it does destroy memory structures of the indices and foreign keys associated with the table.
//	The db parameter is optional. It is needed if the Table object contains lookaside memory. (Table objects in the schema do not use lookaside memory, but some ephemeral Table objects do.) Or the db parameter can be used with db.pnBytesFreed to measure the memory used by the Table object.
func (db *sqlite3) DeleteTable(table *Table) {
	assert( table != nil || table.nRef > 0 )

	//	Do not delete the table until the reference count reaches zero.
	switch {
	case table == nil:
		return
	case db == nil || db.pnBytesFreed == 0:
		table.nRef--
		if table.nRef > 0 {
			return
		}
	}

	//	Delete all indices associated with this table.
	for name, index := range table.Indices {
		assert( index.Schema == table.Schema )
		if !db || db.pnBytesFreed == 0 {
			delete(index.Schema.Indices, name)
			assert( db == nil )
			assert( pOld == index || pOld == nil )
		}
		db.DeleteIndexSamples(index)
		delete(table.Indices, index)
	}

	//	Delete any foreign keys attached to this table.
	sqlite3FkDelete(db, table)

	//	Delete the Table structure itself.
	sqliteDeleteColumnNames(db, table)
//	table.Name = ""
//	table.zColAff = ""
	sqlite3SelectDelete(db, table.Select)
	db.ExprListDelete(table.pCheck)
	db.VtabClear(table)
	*table = nil
}

//	Unlink the given table from the hash tables and the delete the table structure with all its indices and foreign keys.
func (db *sqlite3) UnlinkAndDeleteTable(iDb int, zTabName string) {
	assert( db != 0 )
	assert( iDb >= 0 && iDb < db.nDb )
	assert( zTabName )
	pDb := &db.Databases[iDb]
	p := pDb.Schema.Tables[zTabName]
	delete(pDb.Schema.Tables, zTabName)
	db.DeleteTable(p)
	db.flags |= SQLITE_InternChanges
}

//	Open the sqlite_master table stored in database number iDb for writing. The table is opened using cursor 0.
func (p *Parse) OpenMasterTable(iDb int) {
	v := p.GetVdbe()
	p.TableLock(iDb, MASTER_ROOT, SCHEMA_TABLE(iDb), true)
	v.AddOp3(OP_OpenWrite, 0, MASTER_ROOT, iDb)
	sqlite3VdbeChangeP4(v, -1, (char *)5, P4_INT32);  /* 5 column table */
	if p.nTab == 0 {
		p.nTab = 1
	}
}

//	Parameter Name points to a nul-terminated buffer containing the name of a database ("main", "temp" or the name of an attached db). This function returns the index of the named database in db.Databases[], or -1 if the named db cannot be found.
func (db *sqlite3) FindDbName(Name string) (iDb int) {
	iDb = -1					//	Database number
	if Name != "" {
		for iDb = len(db.Databases) - 1; iDb > -1; iDb-- {
			if iDb != 1 && CaseInsensitiveMatch(db.Databases[iDb].Name, Name) {
				break
			}
		}
	}
	return
}

//	The token *pName contains the name of a database (either "main" or "temp" or the name of an attached db). This routine returns the index of the named database in db.Databases[], or -1 if the named db does not exist.
func (db *sqlite3) FindDb(pName Token) int {
	return db.FindDbName(Dequote(pName))
}

//	The table or view or trigger name is passed to this routine via tokens pName1 and pName2. If the table name was fully qualified, for example:
//			CREATE TABLE xxx.yyy (...);
//	Then pName1 is set to "xxx" and pName2 "yyy". On the other hand if the table name is not fully qualified, i.e.:
//			CREATE TABLE yyy(...);
//	Then pName1 is set to "yyy" and pName2 is "".
//	This routine sets the *ppUnqual pointer to point at the token (pName1 or pName2) that stores the unqualified table name. The index of the database "xxx" is returned.
func (pParse *Parse) TwoPartName(pName1, pName2 Token) (pUnqual Token, iDb int) {
	db := pParse.db
	if pName2 != "" {
		if db.init.busy  {
			pParse.SetErrorMsg("corrupt database")
			pParse.nErr++
			return -1
		}
		pUnqual = pName2
		if iDb = db.FindDb(pName1); iDb < 0 {
			pParse.SetErrorMsg("unknown database %v", pName1)
			pParse.nErr++
			return -1
		}
	} else {
		assert( db.init.iDb == 0 || db.init.busy )
		iDb = db.init.iDb
		pUnqual = pName1
	}
	return
}

/*
** This routine is used to check if the UTF-8 string Name is a legal
** unqualified name for a new schema object (table, index, view or
** trigger). All names are legal except those that begin with the string
** "sqlite_" (in upper, lower or mixed case). This portion of the namespace
** is reserved for internal use.
*/
 int sqlite3CheckObjectName(Parse *pParse, const char *Name){
  if !pParse.db.init.busy && pParse.nested==0 && (pParse.db.flags & SQLITE_WriteSchema) == 0 && CaseInsensitiveMatchN(Name, "sqlite_", 7) {
    pParse.SetErrorMsg("object name reserved for internal use: %v", Name);
    return SQLITE_ERROR;
  }
  return SQLITE_OK;
}

/*
** Begin constructing a new table representation in memory.  This is
** the first of several action routines that get called in response
** to a CREATE TABLE statement.  In particular, this routine is called
** after seeing tokens "CREATE" and "TABLE" and the table name. The isTemp
** flag is true if the table should be stored in the auxiliary database
** file instead of in the main database file.  This is normally the case
** when the "TEMP" or "TEMPORARY" keyword occurs in between
** CREATE and TABLE.
**
** The new table record is initialized and put in pParse.pNewTable.
** As more of the CREATE TABLE statement is parsed, additional action
** routines will be called to add more information to this record.
** At the end of the CREATE TABLE statement, the sqlite3EndTable() routine
** is called to complete the construction of the new table record.
*/
 void sqlite3StartTable(
  Parse *pParse,   /* Parser context */
  Token *pName1,   /* First part of the name of the table or view */
  Token *pName2,   /* Second part of the name of the table or view */
  int isTemp,      /* True if this is a TEMP table */
  int isView,      /* True if this is a VIEW */
  int isVirtual,   /* True if this is a VIRTUAL table */
  int noErr        /* Do nothing if table already exists */
){
  Table *pTable;
  char *Name = 0; /* The name of the new table */
  sqlite3 *db = pParse.db;
  Vdbe *v;
  int iDb;         /* Database number to create the table in */
  Token *pName;    /* Unqualified name of the table to create */

  /* The table or view name to create is passed to this routine via tokens
  ** pName1 and pName2. If the table name was fully qualified, for example:
  **
  ** CREATE TABLE xxx.yyy (...);
  ** 
  ** Then pName1 is set to "xxx" and pName2 "yyy". On the other hand if
  ** the table name is not fully qualified, i.e.:
  **
  ** CREATE TABLE yyy(...);
  **
  ** Then pName1 is set to "yyy" and pName2 is "".
  **
  ** The call below sets the pName pointer to point at the token (pName1 or
  ** pName2) that stores the unqualified table name. The variable iDb is
  ** set to the index of the database that the table or view is to be
  ** created in.
  */
  pName, iDb = pParse.TwoPartName(pName1, pName2)
  if( iDb<0 ) return;
  if isTemp && pName2.n > 0 && iDb != 1 {
    /* If creating a temp table, the name may not be qualified. Unless 
    ** the database name is "temp" anyway.  */
    pParse.SetErrorMsg("temporary table name must be unqualified");
    return;
  }
  if isTemp {
	  iDb = 1
	}

  pParse.sNameToken = *pName;
  Name = Dequote(pName)
  if( Name==0 ) return;
  if( SQLITE_OK!=sqlite3CheckObjectName(pParse, Name) ){
    goto begin_table_error;
  }
  if( db.init.iDb==1 ) isTemp = 1;
  assert( (isTemp & 1)==isTemp );
  {
    int code;
    char *zDb = db.Databases[iDb].Name;
    if pParse.AuthCheck(SQLITE_INSERT, SCHEMA_TABLE(isTemp), 0, zDb) != nil {
      goto begin_table_error;
    }
    if( isView ){
      if isTemp {
        code = SQLITE_CREATE_TEMP_VIEW;
      }else{
        code = SQLITE_CREATE_VIEW;
      }
    }else{
      if isTemp {
        code = SQLITE_CREATE_TEMP_TABLE;
      }else{
        code = SQLITE_CREATE_TABLE;
      }
    }
    if !isVirtual && pParse.AuthCheck(code, Name, 0, zDb) != SQLITE_OK {
      goto begin_table_error;
    }
  }

  /* Make sure the new table name does not collide with an existing
  ** index or table name in the same database.  Issue an error message if
  ** it does. The exception is if the statement being parsed was passed
  ** to an sqlite3_declare_vtab() call. In that case only the column names
  ** and types will be used, so there is no need to test for namespace
  ** collisions.
  */
  if( !IN_DECLARE_VTAB ){
    char *zDb = db.Databases[iDb].Name;
	if pParse.ReadSchema() != SQLITE_OK {
		goto begin_table_error
    }
    pTable = db.FindTable(Name, zDb)
    if( pTable ){
      if( !noErr ){
        pParse.SetErrorMsg("table %v already exists", pName);
      }else{
        assert( !db.init.busy );
        pParse.CodeVerifySchema(iDb)
      }
      goto begin_table_error;
    }
    if db.FindIndex(Name, zDb) != nil {
      pParse.SetErrorMsg("there is already an index named %v", Name);
      goto begin_table_error;
    }
  }

	pTable = &Table{
		Name:		Name,
		iPKey:		-1.
		Schema:		db.Databases[iDb].Schema,
		nRef:		1,
		nRowEst:	1000000,
	}
  assert( pParse.pNewTable==0 );
  pParse.pNewTable = pTable;

  /* If this is the magic sqlite_sequence table used by autoincrement,
  ** then record a pointer to this table in the main database structure
  ** so that INSERT can find the table easily.
  */
#ifndef SQLITE_OMIT_AUTOINCREMENT
  if( !pParse.nested && strcmp(Name, "sqlite_sequence")==0 ){
    pTable.Schema.pSeqTab = pTable;
  }
#endif

  /* Begin generating the code that will insert the table record into
  ** the SQLITE_MASTER table.  Note in particular that we must go ahead
  ** and allocate the record number for the table entry now.  Before any
  ** PRIMARY KEY or UNIQUE keywords are parsed.  Those keywords will cause
  ** indices to be created and the table record must come before the 
  ** indices.  Hence, the record number for the table must be allocated
  ** now.
  */
  if( !db.init.busy && (v = pParse.GetVdbe())!=0 ){
    int j1;
    int fileFormat;
    int reg1, reg2, reg3;
    pParse.BeginWriteOperation(0, iDb)

    if( isVirtual ){
      v.AddOp0(OP_VBegin);
    }

    /* If the file format and encoding in the database have not been set, 
    ** set them now.
    */
    reg1 = pParse.regRowid = ++pParse.nMem;
    reg2 = pParse.regRoot = ++pParse.nMem;
    reg3 = ++pParse.nMem;
    v.AddOp3(OP_ReadCookie, iDb, reg3, BTREE_FILE_FORMAT);
    sqlite3VdbeUsesBtree(v, iDb);
    j1 = v.AddOp1(OP_If, reg3);
    fileFormat = (db.flags & SQLITE_LegacyFileFmt)!=0 ?
                  1 : SQLITE_MAX_FILE_FORMAT;
    v.AddOp2(OP_Integer, fileFormat, reg3);
    v.AddOp3(OP_SetCookie, iDb, BTREE_FILE_FORMAT, reg3);
    v.AddOp2(OP_Integer, db.Encoding(), reg3);
    v.AddOp3(OP_SetCookie, iDb, BTREE_TEXT_ENCODING, reg3);
    v.JumpHere(j1)

    /* This just creates a place-holder record in the sqlite_master table.
    ** The record created does not contain anything yet.  It will be replaced
    ** by the real entry in code generated at sqlite3EndTable().
    **
    ** The rowid for the new entry is left in register pParse.regRowid.
    ** The root page number of the new table is left in reg pParse.regRoot.
    ** The rowid and root page number values are needed by the code that
    ** sqlite3EndTable will generate.
    */
    if( isView || isVirtual ){
      v.AddOp2(OP_Integer, 0, reg2);
    }else
    {
      v.AddOp2(OP_CreateTable, iDb, reg2);
    }
    pParse.OpenMasterTable(iDb)
    v.AddOp2(OP_NewRowid, 0, reg1);
    v.AddOp2(OP_Null, 0, reg3);
    v.AddOp3(OP_Insert, 0, reg3, reg1);
    v.ChangeP5(OPFLAG_APPEND)
    v.AddOp0(OP_Close);
  }

  /* Normal (non-error) return. */
  return;

  /* If an error occurs, we jump here */
begin_table_error:
  Name = nil
  return;
}


/*
** Add a new column to the table currently being constructed.
**
** The parser calls this routine once for each column declaration
** in a CREATE TABLE statement.  sqlite3StartTable() gets called
** first to get things going.  Then this routine is called for each
** column.
*/
 void sqlite3AddColumn(Parse *pParse, Token *pName){
  Table *p;
  int i;
  char *z;
  Column *pCol;
  sqlite3 *db = pParse.db;
  if( (p = pParse.pNewTable)==0 ) return;
  z = Dequote(pName)
  if( z==0 ) return;
  for(i=0; i<p.nCol; i++){
    if CaseInsensitiveMatch(z, p.Columns[i].Name) {
      pParse.SetErrorMsg("duplicate column name: %v", z);
      z = nil
      return;
    }
  }
  if( (p.nCol & 0x7)==0 ){
    Column *aNew;
    aNew = sqlite3DbRealloc(db,p.Columns,(p.nCol+8)*sizeof(p.Columns[0]));
    if( aNew==0 ){
      z = nil
      return;
    }
    p.Columns = aNew;
  }
  pCol = &p.Columns[p.nCol];
  memset(pCol, 0, sizeof(p.Columns[0]));
  pCol.Name = z;
 
  /* If there is no type specified, columns have the default affinity
  ** 'NONE'. If there is a type specified, then sqlite3AddColumnType() will
  ** be called next to set pCol.affinity correctly.
  */
  pCol.affinity = SQLITE_AFF_NONE;
  p.nCol++;
}

/*
** This routine is called by the parser while in the middle of
** parsing a CREATE TABLE statement.  A "NOT NULL" constraint has
** been seen on a column.  This routine sets the notNull flag on
** the column currently under construction.
*/
 void sqlite3AddNotNull(Parse *pParse, int onError){
  Table *p;
  p = pParse.pNewTable;
  if( p==0 || p.nCol<1 ) return;
  p.Columns[p.nCol-1].notNull = (byte)onError;
}

/*
** Scan the column type name zType (length nType) and return the
** associated affinity type.
**
** This routine does a case-independent search of zType for the 
** substrings in the following table. If one of the substrings is
** found, the corresponding affinity is returned. If zType contains
** more than one of the substrings, entries toward the top of 
** the table take priority. For example, if zType is 'BLOBINT', 
** SQLITE_AFF_INTEGER is returned.
**
** Substring     | Affinity
** --------------------------------
** 'INT'         | SQLITE_AFF_INTEGER
** 'CHAR'        | SQLITE_AFF_TEXT
** 'CLOB'        | SQLITE_AFF_TEXT
** 'TEXT'        | SQLITE_AFF_TEXT
** 'BLOB'        | SQLITE_AFF_NONE
** 'REAL'        | SQLITE_AFF_REAL
** 'FLOA'        | SQLITE_AFF_REAL
** 'DOUB'        | SQLITE_AFF_REAL
**
** If none of the substrings in the above table are found,
** SQLITE_AFF_NUMERIC is returned.
*/
 char sqlite3AffinityType(const char *zIn){
  uint32 h = 0;
  char aff = SQLITE_AFF_NUMERIC;

  if( zIn ) while( zIn[0] ){
    h = (h<<8) + sqlite3UpperToLower[(*zIn)&0xff];
    zIn++;
    if( h==(('c'<<24)+('h'<<16)+('a'<<8)+'r') ){             /* CHAR */
      aff = SQLITE_AFF_TEXT; 
    }else if( h==(('c'<<24)+('l'<<16)+('o'<<8)+'b') ){       /* CLOB */
      aff = SQLITE_AFF_TEXT;
    }else if( h==(('t'<<24)+('e'<<16)+('x'<<8)+'t') ){       /* TEXT */
      aff = SQLITE_AFF_TEXT;
    }else if( h==(('b'<<24)+('l'<<16)+('o'<<8)+'b')          /* BLOB */
        && (aff==SQLITE_AFF_NUMERIC || aff==SQLITE_AFF_REAL) ){
      aff = SQLITE_AFF_NONE;
    }else if( h==(('r'<<24)+('e'<<16)+('a'<<8)+'l')          /* REAL */
        && aff==SQLITE_AFF_NUMERIC ){
      aff = SQLITE_AFF_REAL;
    }else if( h==(('f'<<24)+('l'<<16)+('o'<<8)+'a')          /* FLOA */
        && aff==SQLITE_AFF_NUMERIC ){
      aff = SQLITE_AFF_REAL;
    }else if( h==(('d'<<24)+('o'<<16)+('u'<<8)+'b')          /* DOUB */
        && aff==SQLITE_AFF_NUMERIC ){
      aff = SQLITE_AFF_REAL;
    }else if( (h&0x00FFFFFF)==(('i'<<16)+('n'<<8)+'t') ){    /* INT */
      aff = SQLITE_AFF_INTEGER;
      break;
    }
  }

  return aff;
}

/*
** This routine is called by the parser while in the middle of
** parsing a CREATE TABLE statement.  The pFirst token is the first
** token in the sequence of tokens that describe the type of the
** column currently under construction.   pLast is the last token
** in the sequence.  Use this information to construct a string
** that contains the typename of the column and store that string
** in zType.
*/ 
 void sqlite3AddColumnType(Parse *pParse, Token *pType){
  Table *p;
  Column *pCol;

  p = pParse.pNewTable;
  if( p==0 || p.nCol<1 ) return;
  pCol = &p.Columns[p.nCol-1];
  assert( pCol.zType==0 );
  pCol.zType = Dequote(pType)
  pCol.affinity = sqlite3AffinityType(pCol.zType);
}

/*
** The expression is the default value for the most recently added column
** of the table currently under construction.
**
** Default value expressions must be constant.  Raise an exception if this
** is not the case.
**
** This routine is called by the parser while in the middle of
** parsing a CREATE TABLE statement.
*/
 void sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan){
  Table *p;
  Column *pCol;
  sqlite3 *db = pParse.db;
  p = pParse.pNewTable;
  if( p!=0 ){
    pCol = &(p.Columns[p.nCol-1]);
    if( !sqlite3ExprIsConstantOrFunction(pSpan.Expr) ){
      pParse.SetErrorMsg("default value of column [%v] is not constant", pCol.Name);
    }else{
      /* A copy of pExpr is used instead of the original, as pExpr contains
      ** tokens that point to volatile memory. The 'span' of the expression
      ** is required by pragma table_info.
      */
      db.ExprDelete(pCol.pDflt)
      pCol.pDflt = pSpan.Expr.Dup();
      pCol.zDflt = sqlite3DbStrNDup(db, (char*)pSpan.zStart,
                                     (int)(pSpan.zEnd - pSpan.zStart));
    }
  }
  db.ExprDelete(pSpan.Expr)
}

/*
** Designate the PRIMARY KEY for the table.  pList is a list of names 
** of columns that form the primary key.  If pList is NULL, then the
** most recently added column of the table is the primary key.
**
** A table can have at most one primary key.  If the table already has
** a primary key (and this is the second primary key) then create an
** error.
**
** If the PRIMARY KEY is on a single column whose datatype is INTEGER,
** then we will try to use that column as the rowid.  Set the Table.iPKey
** field of the table under construction to be the index of the
** INTEGER PRIMARY KEY column.  Table.iPKey is set to -1 if there is
** no INTEGER PRIMARY KEY.
**
** If the key is not an INTEGER PRIMARY KEY, then create a unique
** index for the key.  No index is created for INTEGER PRIMARY KEYs.
*/
 void sqlite3AddPrimaryKey(
  Parse *pParse,    /* Parsing context */
  ExprList *pList,  /* List of field names to be indexed */
  int onError,      /* What to do with a uniqueness conflict */
  int autoInc,      /* True if the AUTOINCREMENT keyword is present */
  int sortOrder     /* SQLITE_SO_ASC or SQLITE_SO_DESC */
){
  Table *pTab = pParse.pNewTable;
  char *zType = 0;
  int iCol = -1, i;
  if( pTab==0 || IN_DECLARE_VTAB ) goto primary_key_exit;
  if( pTab.tabFlags & TF_HasPrimaryKey ){
    pParse.SetErrorMsg("table \"%v\" has more than one primary key", pTab.Name);
    goto primary_key_exit;
  }
  pTab.tabFlags |= TF_HasPrimaryKey;
  if pList == nil {
    iCol = pTab.nCol - 1
    pTab.Columns[iCol].isPrimKey = 1;
  }else{
	for _, item := range pList.Items {
		for i, column := range pTab.Columns {
			if CaseInsensitiveMatch(item.Name, column.Name) {
				if i < len(pTab.Columns) {
					column.isPrimKey = true
				}
				break
			}
		}
    }
    if len(pList.Items) > 1 {
		iCol = -1
	}
  }
  if iCol >= 0 && iCol < len(pTab.Columns) {
    zType = pTab.Columns[iCol].zType
  }
  if zType != "" && CaseInsensitiveMatch(zType, "INTEGER") && sortOrder==SQLITE_SO_ASC {
    pTab.iPKey = iCol;
    pTab.keyConf = (byte)onError;
    assert( autoInc==0 || autoInc==1 );
    pTab.tabFlags |= autoInc*TF_Autoincrement;
  }else if( autoInc ){
#ifndef SQLITE_OMIT_AUTOINCREMENT
    pParse.SetErrorMsg("AUTOINCREMENT is only allowed on an INTEGER PRIMARY KEY");
#endif
  }else{
    Index *p;
    p = sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0, 0, sortOrder, 0);
    if( p ){
      p.autoIndex = 2;
    }
    pList = 0;
  }

primary_key_exit:
  pParse.db.ExprListDelete(pList);
  return;
}

/*
** Add a new CHECK constraint to the table currently under construction.
*/
 void sqlite3AddCheckConstraint(
  Parse *pParse,    /* Parsing context */
  Expr *pCheckExpr  /* The check expression */
){
  Table *pTab = pParse.pNewTable;
  if( pTab && !IN_DECLARE_VTAB ){
    pTab.pCheck = append(pTab.pCheck, pCheckExpr)
    if( pParse.constraintName.n ){
      pTab.pCheck.SetName(&pParse.constraintName, true)
    }
  }else
  {
    pParse.db.ExprDelete(pCheckExpr)
  }
}

//	Set the collation function of the most recently parsed table column to the CollSeq given.
func (pParse *Parse) AddCollateType(name Token) {
	if table := pParse.pNewTable; p != nil {
		i := p.nCol - 1
		db := pParse.db
		if collation := Dequote(name); collation != nil {
			if pParse.LocateCollSeq(collation) {
				table.Columns[i].zColl = collation
				//	If the column is declared as "<name> PRIMARY KEY COLLATE <type>", then an index may have been created on this column before the collation type was added. Correct this if it is the case.
				for _, index := range table.Indices {
					assert( len(index.Columns) == 1 )
					if index.Columns[0] == i {
						index.azColl[0] = table.Columns[i].zColl
					}
				}
			}
		}
	}
}

//	This function returns the collation sequence for database native text encoding identified by the string Name, length nName.
//	If the requested collation sequence is not available, or not available in the database native encoding, the collation factory is invoked to request it. If the collation factory does not supply such a sequence, and the sequence is available in another text encoding, then that is returned instead.
//	If no versions of the requested collations sequence are available, or another error occurs, nil is returned and an error message written into pParse.
//	This routine is a wrapper around sqlite3FindCollSeq(). This routine invokes the collation factory if the named collation cannot be found and generates an error message.
//	See also: sqlite3FindCollSeq(), sqlite3GetCollSeq()
func (pParse *Parse) LocateCollSeq(name string) (c *CollSeq) {
	db := pParse.db
	enc := db.Encoding()
	initbusy := db.init.busy

	c = sqlite3FindCollSeq(db, enc, Name, initbusy)
	if !initbusy && (c == nil || c.xCmp == nil) {
		c = sqlite3GetCollSeq(db, enc, pColl, Name)
		if c == nil {
			pParse.SetErrorMsg("no such collation sequence: %v", Name)
		}
	}
	return
}


/*
** Generate code that will increment the schema cookie.
**
** The schema cookie is used to determine when the schema for the
** database changes.  After each schema change, the cookie value
** changes.  When a process first reads the schema it records the
** cookie.  Thereafter, whenever it goes to access the database,
** it checks the cookie to make sure the schema has not changed
** since it was last read.
**
** This plan is not completely bullet-proof.  It is possible for
** the schema to change multiple times and for the cookie to be
** set back to prior value.  But schema changes are infrequent
** and the probability of hitting the same cookie value is only
** 1 chance in 2^32.  So we're safe enough.
*/
 void sqlite3ChangeCookie(Parse *pParse, int iDb){
  int r1 = pParse.GetTempReg()
  sqlite3 *db = pParse.db;
  Vdbe *v = pParse.pVdbe;
  v.AddOp2(OP_Integer, db.Databases[iDb].Schema.schema_cookie+1, r1);
  v.AddOp3(OP_SetCookie, iDb, BTREE_SCHEMA_VERSION, r1);
  pParse.ReleaseTempReg(r1)
}

/*
** Measure the number of characters needed to output the given
** identifier.  The number returned includes any quotes used
** but does not include the null terminator.
**
** The estimate is conservative.  It might be larger that what is
** really needed.
*/
static int identLength(const char *z){
  int n;
  for(n=0; *z; n++, z++){
    if( *z=='"' ){ n++; }
  }
  return n + 2;
}

/*
** The first parameter is a pointer to an output buffer. The second 
** parameter is a pointer to an integer that contains the offset at
** which to write into the output buffer. This function copies the
** nul-terminated string pointed to by the third parameter, zSignedIdent,
** to the specified offset in the buffer and updates *pIdx to refer
** to the first byte after the last byte written before returning.
** 
** If the string zSignedIdent consists entirely of alpha-numeric
** characters, does not begin with a digit and is not an SQL keyword,
** then it is copied to the output buffer exactly as it is. Otherwise,
** it is quoted using double-quotes.
*/
static void identPut(char *z, int *pIdx, char *zSignedIdent){
  unsigned char *zIdent = (unsigned char*)zSignedIdent;
  int i, j, needQuote;
  i = *pIdx;

  for(j=0; zIdent[j]; j++){
    if( !sqlite3Isalnum(zIdent[j]) && zIdent[j]!='_' ) break;
  }
  needQuote = sqlite3Isdigit(zIdent[0]) || sqlite3KeywordCode(zIdent, j)!=TK_ID;
  if( !needQuote ){
    needQuote = zIdent[j];
  }

  if( needQuote ) z[i++] = '"';
  for(j=0; zIdent[j]; j++){
    z[i++] = zIdent[j];
    if( zIdent[j]=='"' ) z[i++] = '"';
  }
  if( needQuote ) z[i++] = '"';
  z[i] = 0;
  *pIdx = i;
}

/*
** Generate a CREATE TABLE statement appropriate for the given
** table.  Memory to hold the text of the statement is obtained
** from sqliteMalloc() and must be freed by the calling function.
*/
static char *createTableStmt(sqlite3 *db, Table *p){
  int i, k, n;
  char *zStmt;
  char *zSep, *zSep2, *zEnd;
  Column *pCol;
  n = 0;
  for(pCol = p.Columns, i=0; i<p.nCol; i++, pCol++){
    n += identLength(pCol.Name) + 5;
  }
  n += identLength(p.Name);
  if( n<50 ){ 
    zSep = "";
    zSep2 = ",";
    zEnd = ")";
  }else{
    zSep = "\n  ";
    zSep2 = ",\n  ";
    zEnd = "\n)";
  }
  n += 35 + 6*p.nCol;
  zStmt = sqlite3DbMallocRaw(0, n);
  if( zStmt==0 ){
    db.mallocFailed = true
    return 0;
  }
  zStmt = "CREATE TABLE "
  k = sqlite3Strlen30(zStmt);
  identPut(zStmt, &k, p.Name);
  zStmt[k++] = '(';
  for(pCol=p.Columns, i=0; i<p.nCol; i++, pCol++){
    static const char * const azType[] = {
        /* SQLITE_AFF_TEXT    */ " TEXT",
        /* SQLITE_AFF_NONE    */ "",
        /* SQLITE_AFF_NUMERIC */ " NUM",
        /* SQLITE_AFF_INTEGER */ " INT",
        /* SQLITE_AFF_REAL    */ " REAL"
    };
    int len;
    const char *zType;

    zStmt[k] = zSep
    k += sqlite3Strlen30(&zStmt[k]);
    zSep = zSep2;
    identPut(zStmt, &k, pCol.Name);
    assert( pCol.affinity-SQLITE_AFF_TEXT >= 0 );
    assert( pCol.affinity-SQLITE_AFF_TEXT < ArraySize(azType) );
    
    zType = azType[pCol.affinity - SQLITE_AFF_TEXT];
    len = sqlite3Strlen30(zType);
    assert( pCol.affinity==SQLITE_AFF_NONE 
            || pCol.affinity==sqlite3AffinityType(zType) );
    memcpy(&zStmt[k], zType, len);
    k += len;
    assert( k<=n );
  }
  zStmt[k] = fmt.Sprintf("%s", zEnd);
  return zStmt;
}

/*
** This routine is called to report the final ")" that terminates
** a CREATE TABLE statement.
**
** The table structure that other action routines have been building
** is added to the internal hash tables, assuming no errors have
** occurred.
**
** An entry for the table is made in the master table on disk, unless
** this is a temporary table or db.init.busy==1.  When db.init.busy==1
** it means we are reading the sqlite_master table because we just
** connected to the database or because the sqlite_master table has
** recently changed, so the entry for this table already exists in
** the sqlite_master table.  We do not want to create it again.
**
** If the pSelect argument is not NULL, it means that this routine
** was called to create a table generated from a 
** "CREATE TABLE ... AS SELECT ..." statement.  The column names of
** the new table will match the result set of the SELECT.
*/
 void sqlite3EndTable(
  Parse *pParse,          /* Parse context */
  Token *pCons,           /* The ',' token after the last column defn. */
  Token *pEnd,            /* The final ')' token in the CREATE TABLE */
  Select *pSelect         /* Select from a "CREATE ... AS SELECT" */
){
  Table *p;
  sqlite3 *db = pParse.db;
  int iDb;

  if( (pEnd==0 && pSelect==0) || db.mallocFailed ){
    return;
  }
  p = pParse.pNewTable;
  if( p==0 ) return;

  assert( !db.init.busy || !pSelect );

  iDb = db.SchemaToIndex(p.Schema)

  /* Resolve names in all CHECK constraint expressions.
  */
  if( p.pCheck ){
    SrcList sSrc;                   /* Fake SrcList for pParse.pNewTable */
    NameContext sNC;                /* Name context for pParse.pNewTable */
    ExprList *pList;                /* List of all CHECK constraints */
    int i;                          /* Loop counter */

    memset(&sNC, 0, sizeof(sNC));
    memset(&sSrc, 0, sizeof(sSrc));
    sSrc.nSrc = 1;
    sSrc.a[0].Name = p.Name;
    sSrc.a[0].pTab = p;
    sSrc.a[0].iCursor = -1;
    sNC.Parse = pParse;
    sNC.SrcList = &sSrc;
    sNC.Flags = NC_IsCheck;
    pList = p.pCheck;
	for _, item := range pList.Items {
		if sqlite3ResolveExprNames(&sNC, item.Expr) {
			return
		}
	}
  }

  /* If the db.init.busy is 1 it means we are reading the SQL off the
  ** "sqlite_master" or "sqlite_temp_master" table on the disk.
  ** So do not write to the disk again.  Extract the root page number
  ** for the table from the db.init.newTnum field.  (The page number
  ** should have been put there by the sqliteOpenCb routine.)
  */
  if( db.init.busy ){
    p.tnum = db.init.newTnum;
  }

  /* If not initializing, then create a record for the new table
  ** in the SQLITE_MASTER table of the database.
  **
  ** If this is a TEMPORARY table, write the entry into the auxiliary
  ** file instead of into the main database file.
  */
  if( !db.init.busy ){
    int n;
    Vdbe *v;
    char *zType;    /* "view" or "table" */
    char *zType2;   /* "VIEW" or "TABLE" */
    char *zStmt;    /* Text of the CREATE TABLE or CREATE VIEW statement */

    v = pParse.GetVdbe()
    if( v==0 ) return;

    v.AddOp1(OP_Close, 0);

    /* 
    ** Initialize zType for the new view or table.
    */
    if( p.Select==0 ){
      /* A regular table */
      zType = "table";
      zType2 = "TABLE";
    }else{
      /* A view */
      zType = "view";
      zType2 = "VIEW";
    }

    /* If this is a CREATE TABLE xx AS SELECT ..., execute the SELECT
    ** statement to populate the new table. The root-page number for the
    ** new table is in register pParse.regRoot.
    **
    ** Once the SELECT has been coded by sqlite3Select(), it is in a
    ** suitable state to query for the column names and types to be used
    ** by the new table.
    **
    ** A shared-cache write-lock is not required to write to the new table,
    ** as a schema-lock must have already been obtained to create it. Since
    ** a schema-lock excludes all other database users, the write-lock would
    ** be redundant.
    */
    if( pSelect ){
      SelectDest dest;
      Table *pSelTab;

      assert(pParse.nTab==1);
      v.AddOp3(OP_OpenWrite, 1, pParse.regRoot, iDb);
      v.ChangeP5(1)
      pParse.nTab = 2;
      sqlite3SelectDestInit(&dest, SRT_Table, 1);
      sqlite3Select(pParse, pSelect, &dest);
      v.AddOp1(OP_Close, 1);
      if( pParse.nErr==0 ){
        pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect);
        if( pSelTab==0 ) return;
        assert( p.Columns==0 );
        p.nCol = pSelTab.nCol;
        p.Columns = pSelTab.Columns;
        pSelTab.nCol = 0;
        pSelTab.Columns = 0;
        db.DeleteTable(pSelTab)
      }
    }

    /* Compute the complete text of the CREATE statement */
    if( pSelect ){
      zStmt = createTableStmt(db, p);
    }else{
      n = (int)(pEnd.z - pParse.sNameToken.z) + 1;
      zStmt = fmt.Sprintf("CREATE %v %v.*%v", zType2, n, pParse.sNameToken.z);
    }

    /* A slot for the record has already been allocated in the 
    ** SQLITE_MASTER table.  We just need to update that slot with all
    ** the information we've collected.
    */
    sqlite3NestedParse(pParse,
      "UPDATE %Q.%s "
         "SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q "
       "WHERE rowid=#%d",
      db.Databases[iDb].Name, SCHEMA_TABLE(iDb),
      zType,
      p.Name,
      p.Name,
      pParse.regRoot,
      zStmt,
      pParse.regRowid
    );
    zStmt = nil
    sqlite3ChangeCookie(pParse, iDb);

#ifndef SQLITE_OMIT_AUTOINCREMENT
    /* Check to see if we need to create an sqlite_sequence table for
    ** keeping track of autoincrement keys.
    */
    if( p.tabFlags & TF_Autoincrement ){
      Db *pDb = &db.Databases[iDb];
      if( pDb.Schema.pSeqTab==0 ){
        sqlite3NestedParse(pParse,
          "CREATE TABLE %Q.sqlite_sequence(name,seq)",
          pDb.Name
        );
      }
    }
#endif

    /* Reparse everything to update our internal data structures */
    v.AddParseSchemaOp(iDb, fmt.Sprintf("tbl_name='%v'", p.Name))
  }


	//	Add the table to the in-memory representation of the database.
	if db.init.busy {
		p.schema.Tables[p.Name] = p
		pParse.pNewTable = nil
		db.flags |= SQLITE_InternChanges

#ifndef SQLITE_OMIT_ALTERTABLE
		if p.Select == nil {
			Name := string(pParse.sNameToken.z)
			assert( !pSelect && pCons && pEnd )
			if( pCons.z==0 ){
				pCons = pEnd
			}
			nName := int((const char *)pCons.z - Name)
			p.addColOffset = 13 + sqlite3Utf8CharLen(Name, nName);
		}
#endif
	}
}

//	The parser calls this routine in order to create a new VIEW
 void sqlite3CreateView(
  Parse *pParse,     /* The parsing context */
  Token *pBegin,     /* The CREATE token that begins the statement */
  Token *pName1,     /* The token that holds the name of the view */
  Token *pName2,     /* The token that holds the name of the view */
  Select *pSelect,   /* A SELECT statement that will become the new view */
  int isTemp,        /* TRUE for a TEMPORARY view */
  int noErr          /* Suppress error messages if VIEW already exists */
){
  Table *p;
  int n;
  const char *z;
  Token sEnd;
  Token *pName = 0;
  int iDb;
  sqlite3 *db = pParse.db;

  if( pParse.nVar>0 ){
    pParse.SetErrorMsg("parameters are not allowed in views");
    sqlite3SelectDelete(db, pSelect);
    return;
  }
  sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);
  p = pParse.pNewTable;
  if( p==0 || pParse.nErr ){
    sqlite3SelectDelete(db, pSelect);
    return;
  }
  pName, _ = pParse.TwoPartName(pName1, pName2)
  iDb = db.SchemaToIndex(p.Schema)
  if sFix := pParse.NewDbFixer(iDb, "view", pName); sFix != nil && sFix.FixSelect(pSelect) != SQLITE_OK {
    sqlite3SelectDelete(db, pSelect);
    return;
  }

  /* Make a copy of the entire SELECT statement that defines the view.
  ** This will force all the Expr.token.z values to be dynamically
  ** allocated rather than point to the input string - which means that
  ** they will persist after the current sqlite3_exec() call returns.
  */
  p.Select = pSelect.Dup();
  sqlite3SelectDelete(db, pSelect);
  if( db.mallocFailed ){
    return;
  }
  if( !db.init.busy ){
    sqlite3ViewGetColumnNames(pParse, p);
  }

  /* Locate the end of the CREATE VIEW statement.  Make sEnd point to
  ** the end.
  */
  sEnd = pParse.sLastToken;
  if( sEnd.z[0]!=0 && sEnd.z[0]!=';' ){
    sEnd.z += sEnd.n;
  }
  sEnd.n = 0;
  n = (int)(sEnd.z - pBegin.z);
  z = pBegin.z;
  while( n>0 && sqlite3Isspace(z[n-1]) ){ n--; }
  sEnd.z = &z[n-1];
  sEnd.n = 1;

  /* Use sqlite3EndTable() to add the view to the SQLITE_MASTER table */
  sqlite3EndTable(pParse, 0, &sEnd, 0);
  return;
}

/*
** The Table structure pTable is really a VIEW.  Fill in the names of
** the columns of the view in the pTable structure.  Return the number
** of errors.  If an error is seen leave an error message in pParse.zErrMsg.
*/
 int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){
  Table *pSelTab;   /* A fake table from which we get the result set */
  Select *pSel;     /* Copy of the SELECT that implements the view */
  int nErr = 0;     /* Number of errors encountered */
  int n;            /* Temporarily holds the number of cursors assigned */
  sqlite3 *db = pParse.db;  /* Database connection for malloc errors */
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);

  assert( pTable );

  if( sqlite3VtabCallConnect(pParse, pTable) ){
    return SQLITE_ERROR;
  }
  if( pTable.IsVirtual() ) return 0;

  /* A positive nCol means the columns names for this view are
  ** already known.
  */
  if( pTable.nCol>0 ) return 0;

  /* A negative nCol is a special marker meaning that we are currently
  ** trying to compute the column names.  If we enter this routine with
  ** a negative nCol, it means two or more views form a loop, like this:
  **
  **     CREATE VIEW one AS SELECT * FROM two;
  **     CREATE VIEW two AS SELECT * FROM one;
  **
  ** Actually, the error above is now caught prior to reaching this point.
  ** But the following test is still important as it does come up
  ** in the following:
  ** 
  **     CREATE TABLE main.ex1(a);
  **     CREATE TEMP VIEW ex1 AS SELECT a FROM ex1;
  **     SELECT * FROM temp.ex1;
  */
  if( pTable.nCol<0 ){
    pParse.SetErrorMsg("view %v is circularly defined", pTable.Name);
    return 1;
  }
  assert( pTable.nCol>=0 );

  /* If we get this far, it means we need to compute the table names.
  ** Note that the call to sqlite3ResultSetOfSelect() will expand any
  ** "*" elements in the results set of the view and will assign cursors
  ** to the elements of the FROM clause.  But we do not want these changes
  ** to be permanent.  So the computation is done on a copy of the SELECT
  ** statement that defines the view.
  */
  assert( pTable.Select );
  pSel = pTable.Select.Dup(0);
  if( pSel ){
    byte enableLookaside = db.lookaside.bEnabled;
    n = pParse.nTab;
    sqlite3SrcListAssignCursors(pParse, pSel.pSrc);
    pTable.nCol = -1;
    db.lookaside.bEnabled = 0;
    xAuth = db.xAuth;
    db.xAuth = 0;
    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);
    db.xAuth = xAuth;
    db.lookaside.bEnabled = enableLookaside;
    pParse.nTab = n;
    if( pSelTab ){
      assert( pTable.Columns==0 );
      pTable.nCol = pSelTab.nCol;
      pTable.Columns = pSelTab.Columns;
      pSelTab.nCol = 0;
      pSelTab.Columns = 0;
      db.DeleteTable(pSelTab)
      pTable.Schema.flags |= DB_UnresetViews;
    }else{
      pTable.nCol = 0;
      nErr++;
    }
    sqlite3SelectDelete(db, pSel);
  } else {
    nErr++;
  }
  return nErr;
}

//	Clear the column names from every VIEW in database idx.
func (db *sqlite3) ViewResetAll(index int) {
	if db.HasProperty(idx, DB_UnresetViews) {
		for _, table := range db.Databases[index].Schema.Tables {
			if table.Select != nil {
				sqliteDeleteColumnNames(db, table)
				table.Columns = table.Columns[:0]
			}
		}
		db.ClearProperty(idx, DB_UnresetViews)
	}
}

//	This function is called by the VDBE to adjust the internal schema used by SQLite when the btree layer moves a table root page. The root-page of a table or index in database iDb has changed from iFrom to iTo.
//	Ticket #1728: The symbol table might still contain information on tables and/or indices that are the process of being deleted. If you are unlucky, one of those deleted indices or tables might have the same rootpage number as the real table or index that is being moved. So we cannot stop searching after the first match because the first match might be for one of the deleted indices or tables and not the table/index that is actually being moved. We must continue looping until all tables and indices with rootpage == iFrom have been converted to have a rootpage of iTo in order to be certain that we got the right one.
func (db *sqlite3) RootPageMoved(DATABASE, FROM, TO int) {
	database := &db.Databases[DATABASE]
	for _, table := range database.Schema.Tables {
		if table.tnum == FROM {
			table.tnum = TO
		}
	}
	for _, index := range database.Schema.Indices {
		if index.tnum == FROM {
			index.tnum = TO
		}
	}
}

//	Write code to erase the table with root-page iTable from database iDb. Also write code to modify the sqlite_master table and internal schema if a root-page of another table is moved by the btree-layer whilst erasing iTable (this can happen with an auto-vacuum database).
func (pParse *Parse) destroyRootPage(table, database int) {
	v := pParse.GetVdbe()
	r1 := pParse.GetTempReg()
	v.AddOp3(OP_Destroy, table, r1, database)
	sqlite3MayAbort(pParse)
	//	OP_Destroy stores an in integer r1. If this integer is non-zero, then it is the root page number of a table moved to location iTable. The following code modifies the sqlite_master table to reflect this.
	//	The "#NNN" in the SQL is a special constant that means whatever value is in register NNN. See grammar rules associated with the TK_REGISTER token for additional information.
	sqlite3NestedParse(pParse, "UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d", pParse.db.Databases[database].Name, SCHEMA_TABLE(database), table, r1, r1)
	pParse.ReleaseTempReg(r1)
}

//	Write VDBE code to erase table pTab and all associated indices on disk. Code to update the sqlite_master tables and internal schema definitions in case a root-page belonging to another table is moved by the btree layer is also added (this can happen with an auto-vacuum database).
func (pParse *Parse) destroyTable(table *Table) {
	//	If the database may be auto-vacuum capable, then it is important to call OP_Destroy on the table and index root-pages in order, starting with the numerically largest root-page number. This guarantees that none of the root-pages to be destroyed is relocated by an earlier OP_Destroy. i.e. if the following were coded:
	//			OP_Destroy 4 0
	//			...
	//			OP_Destroy 5 0
	//	and root page 5 happened to be the largest root-page number in the database, then root page 5 would be moved to page 4 by the "OP_Destroy 4 0" opcode. The subsequent "OP_Destroy 5 0" would hit a free-list page.
	iTab := table.tnum
	iDestroyed := 0

	for {
		iLargest := 0
		if iDestroyed == 0 || iTab < iDestroyed {
			iLargest = iTab
		}
		for _, index := range table.Indices {
			iIdx := index.tnum
			assert( index.Schema == table.Schema )
			if (iDestroyed == 0 || (iIdx < iDestroyed)) && iIdx > iLargest {
				iLargest = iIdx
			}
		}
		if iLargest == 0 {
			return
		}
		iDb := pParse.db.SchemaToIndex(table.Schema)
		pParse.destroyRootPage(iLargest, iDb)
		iDestroyed = iLargest
		}
	}
}

/*
** Remove entries from the sqlite_statN tables (for N in (1,2,3))
** after a DROP INDEX or DROP TABLE command.
*/
static void sqlite3ClearStatTables(
  Parse *pParse,         /* The parsing context */
  int iDb,               /* The database number */
  const char *zType,     /* "idx" or "tbl" */
  const char *Name      /* Name of index or table */
){
  int i;
  const char *zDbName = pParse.db.Databases[iDb].Name;
  for(i=1; i<=3; i++){
    char zTab[24];
    zTab = fmt.Sprintf("sqlite_stat%d",i);
    if pParse.db.FindTable(zTab, zDbName) {
      sqlite3NestedParse(pParse,
        "DELETE FROM %Q.%s WHERE %s=%Q",
        zDbName, zTab, zType, Name
      );
    }
  }
}

//	Generate code to drop a table.
void sqlite3CodeDropTable(Parse *pParse, Table *pTab, int iDb, int isView){
  Vdbe *v;
  sqlite3 *db = pParse.db;
  Trigger *pTrigger;
  Db *pDb = &db.Databases[iDb];

  v = pParse.GetVdbe()
  assert( v!=0 );
  pParse.BeginWriteOperation(1, iDb)

  if( pTab.IsVirtual() ){
    v.AddOp0(OP_VBegin);
  }

  /* Drop all triggers associated with the table being dropped. Code
  ** is generated to remove entries from sqlite_master and/or
  ** sqlite_temp_master if required.
  */
  pTrigger = pParse.TriggerList(pTab)
  while( pTrigger ){
    assert( pTrigger.Schema==pTab.Schema || 
        pTrigger.Schema==db.Databases[1].Schema );
    sqlite3DropTriggerPtr(pParse, pTrigger);
    pTrigger = pTrigger.Next;
  }

#ifndef SQLITE_OMIT_AUTOINCREMENT
  /* Remove any entries of the sqlite_sequence table associated with
  ** the table being dropped. This is done before the table is dropped
  ** at the btree level, in case the sqlite_sequence table needs to
  ** move as a result of the drop (can happen in auto-vacuum mode).
  */
  if( pTab.tabFlags & TF_Autoincrement ){
    sqlite3NestedParse(pParse,
      "DELETE FROM %Q.sqlite_sequence WHERE name=%Q",
      pDb.Name, pTab.Name
    );
  }
#endif

  /* Drop all SQLITE_MASTER table and index entries that refer to the
  ** table. The program name loops through the master table and deletes
  ** every row that refers to a table of the same name as the one being
  ** dropped. Triggers are handled seperately because a trigger can be
  ** created in the temp database that refers to a table in another
  ** database.
  */
  sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'", pDb.Name, SCHEMA_TABLE(iDb), pTab.Name)
  if( !isView && !pTab.IsVirtual() ){
    pParse.destroyTable(pTab)
  }

  /* Remove the table entry from SQLite's internal schema and modify
  ** the schema cookie.
  */
  if( pTab.IsVirtual() ){
    sqlite3VdbeAddOp4(v, OP_VDestroy, iDb, 0, 0, pTab.Name, 0);
  }
  sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab.Name, 0);
  sqlite3ChangeCookie(pParse, iDb);
  db.ViewResetAll(iDb)
}

/*
** This routine is called to do the work of a DROP TABLE statement.
** pName is the name of the table to be dropped.
*/
 void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){
  Table *pTab;
  Vdbe *v;
  sqlite3 *db = pParse.db;
  int iDb;

  if( db.mallocFailed ){
    goto exit_drop_table;
  }
  assert( pParse.nErr==0 );
  assert( pName.nSrc==1 );
  if( noErr ) db.suppressErr++;
  pTab = pParse.LocateTable(pName.a[0].Name, pName.a[0].zDatabase, isView)
  if( noErr ) db.suppressErr--;

  if( pTab==0 ){
    if( noErr ) sqlite3CodeVerifyNamedSchema(pParse, pName.a[0].zDatabase);
    goto exit_drop_table;
  }
  iDb = db.SchemaToIndex(pTab.Schema)
  assert( iDb>=0 && iDb<db.nDb );

  /* If pTab is a virtual table, call ViewGetColumnNames() to ensure
  ** it is initialized.
  */
  if( pTab.IsVirtual() && sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto exit_drop_table;
  }
  {
    int code;
    const char *zTab = SCHEMA_TABLE(iDb);
    const char *zDb = db.Databases[iDb].Name;
    const char *zArg2 = 0;
    if pParse.AuthCheck(SQLITE_DELETE, zTab, 0, zDb) != SQLITE_OK {
      goto exit_drop_table;
    }
    if( isView ){
      if iDb == 1 {
        code = SQLITE_DROP_TEMP_VIEW;
      }else{
        code = SQLITE_DROP_VIEW;
      }
    }else if( pTab.IsVirtual() ){
      code = SQLITE_DROP_VTABLE;
      zArg2 = sqlite3GetVTable(db, pTab).Module.Name;
    }else{
      if iDb == 1 {
        code = SQLITE_DROP_TEMP_TABLE;
      }else{
        code = SQLITE_DROP_TABLE;
      }
    }
    if pParse.AuthCheck(code, pTab.Name, zArg2, zDb) != SQLITE_OK {
      goto exit_drop_table;
    }
    if pParse.AuthCheck(SQLITE_DELETE, pTab.Name, 0, zDb) != SQLITE_OK {
      goto exit_drop_table;
    }
  }
  if CaseInsensitiveMatchN(pTab.Name, "sqlite_", 7) && !CaseInsensitiveMatchN(pTab.Name, "sqlite_stat", 11) {
    pParse.SetErrorMsg("table %v may not be dropped", pTab.Name);
    goto exit_drop_table;
  }

  /* Ensure DROP TABLE is not used on a view, and DROP VIEW is not used
  ** on a table.
  */
  if( isView && pTab.Select==0 ){
    pParse.SetErrorMsg("use DROP TABLE to delete table %v", pTab.Name);
    goto exit_drop_table;
  }
  if( !isView && pTab.Select ){
    pParse.SetErrorMsg("use DROP VIEW to delete view %v", pTab.Name);
    goto exit_drop_table;
  }

  /* Generate code to remove the table from the master table
  ** on disk.
  */
  v = pParse.GetVdbe()
  if( v ){
    pParse.BeginWriteOperation(1, iDb)
    sqlite3ClearStatTables(pParse, iDb, "tbl", pTab.Name);
    sqlite3FkDropTable(pParse, pName, pTab);
    sqlite3CodeDropTable(pParse, pTab, iDb, isView);
  }

exit_drop_table:
  sqlite3SrcListDelete(db, pName);
}

/*
** This routine is called to create a new foreign key on the table
** currently under construction.  pFromCol determines which columns
** in the current table point to the foreign key.  If pFromCol==0 then
** connect the key to the last column inserted.  pTo is the name of
** the table referred to.  pToCol is a list of tables in the other
** pTo table that the foreign key points to.  flags contains all
** information about the conflict resolution algorithms specified
** in the ON DELETE, ON UPDATE and ON INSERT clauses.
**
** An ForeignKey structure is created and added to the table currently
** under construction in the pParse.pNewTable field.
**
** The foreign key is set for IMMEDIATE processing.  A subsequent call
** to sqlite3DeferForeignKey() might change this to DEFERRED.
*/
 void sqlite3CreateForeignKey(
  Parse *pParse,       /* Parsing context */
  ExprList *pFromCol,  /* Columns in this table that point to other table */
  Token *pTo,          /* Name of the other table */
  ExprList *pToCol,    /* Columns in the other table */
  int flags            /* Conflict resolution algorithms. */
){
	db := pParse.db
	table := pParse.pNewTable

  int i;
  int nCol;
  char *z;

	assert( pTo != nil )
	if table != nil && !IN_DECLARE_VTAB {
		switch {
		case pFromCol == nil:
			iCol := len(table.Columns) - 1
			if iCol < 0	{
				goto fk_end
			}

			if pToCol != nil && len(pToCol.Items) != 1 {
				pParse.SetErrorMsg("foreign key on %v should reference only one column of table %v", table.Columns[iCol].Name, pTo)
				goto fk_end
			}
			nCol = 1
		case pToCol != nil && len(pToCol.Items) != len(pFromCol.Items):
			pParse.SetErrorMsg("number of columns in foreign key does not match the number of columns in the referenced table")
			goto fk_end
		default:
			nCol = len(pFromCol.Items)
		}
		nByte := sizeof(*ForeignKey) + (nCol-1)*sizeof(ForeignKey.Columns[0]) + pTo.n + 1
		if pToCol != nil {
			for _, item := range pToCol.Items {
				nByte += sqlite3Strlen30(item.Name) + 1
			}
		}

	  	Key := &ForeignKey{
	  		pFrom:			table,
	  		NextFrom:		p.ForeignKey,
	  		zTo:			Dequote(pTo.z),
	  		Key.aAction:	[]byte{
	  							flags & 0xff,			//	ON DELETE action
	  							(flags >> 8 ) & 0xff,   //	ON UPDATE action
	  						}
	  	}

	    Key.Columns = make([]int, nCol)
	    if pFromCol == nil {
			Key.Columns[0].iFrom = len(table.Columns) - 1
	    } else {
			for i, source_column := range pFromCol.a {
				for j, target_column := range table.Columns {					///	}=0; j<table.nCol; j++){
					if CaseInsensitiveMatch(target_column.Name, source_column.Name) {
						Key.Columns[i].iFrom = j
						break
					}
				}
				if j >= len(table.Columns) {
					pParse.SetErrorMsg("unknown column \"%v\" in foreign key definition", source_column.Name)
					goto fk_end;
				}
			}
		}
	    for i, column := range pToCol {
	  	  column.Name = Key.Columns[i].zCol
	    }

	  	schema := table.Schema.ForeignKeys
	  	NextTo := schema[Key.zTo]
	  	schema[Key.zTo] = Key
	  	if NextTo != nil {
	  		assert( NextTo.pPrevTo == nil )
	  		Key.NextTo = NextTo
	  		NextTo.pPrevTo = Key
	  	}

	  	//	Link the foreign key to the table as the last step.
	  	table.Key = Key
	}
fk_end:
	db.ExprListDelete(pFromCol)
	db.ExprListDelete(pToCol)
}

/*
** This routine is called when an INITIALLY IMMEDIATE or INITIALLY DEFERRED
** clause is seen as part of a foreign key definition.  The isDeferred
** parameter is 1 for INITIALLY DEFERRED and 0 for INITIALLY IMMEDIATE.
** The behavior of the most recently created foreign key is adjusted
** accordingly.
*/
 void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){
  Table *pTab;
  ForeignKey *ForeignKey;
  if( (pTab = pParse.pNewTable)==0 || (ForeignKey = pTab.ForeignKey)==0 ) return;
  assert( isDeferred==0 || isDeferred==1 ); /* EV: R-30323-21917 */
  ForeignKey.isDeferred = (byte)isDeferred;
}

/*
** Generate code that will erase and refill index *pIdx.  This is
** used to initialize a newly created index or to recompute the
** content of an index in response to a REINDEX command.
**
** if memRootPage is not negative, it means that the index is newly
** created.  The register specified by memRootPage contains the
** root page number of the index.  If memRootPage is negative, then
** the index already exists and must be cleared before being refilled and
** the root page number of the index is taken from pIndex.tnum.
*/
static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){
  Table *pTab = pIndex.pTable;  /* The table that is indexed */
  int iTab = pParse.nTab++;     /* Btree cursor used for pTab */
  int iIdx = pParse.nTab++;     /* Btree cursor used for pIndex */
  int iSorter;                   /* Cursor opened by OpenSorter (if in use) */
  int addr1;                     /* Address of top of loop */
  int addr2;                     /* Address to jump to for next iteration */
  int tnum;                      /* Root page of index */
  Vdbe *v;                       /* Generate code into this virtual machine */
  KeyInfo *pKey;                 /* KeyInfo for index */
  int regRecord;                 /* Register holding assemblied index record */
  sqlite3 *db = pParse.db;      /* The database connection */
  int iDb = db.SchemaToIndex(pIndex.Schema)

  if pParse.AuthCheck(SQLITE_REINDEX, pIndex.Name, 0, db.Databases[iDb].Name) != SQLITE_OK {
    return
  }

  /* Require a write-lock on the table to perform this operation */
  pParse.TableLock(iDb, pTab.tnum, pTab.Name, true)

  v = pParse.GetVdbe()
  if( v==0 ) return;
  if( memRootPage>=0 ){
    tnum = memRootPage;
  }else{
    tnum = pIndex.tnum;
    v.AddOp2(OP_Clear, tnum, iDb);
  }
  pKey = pParse.IndexKeyinfo(pIndex)
  sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, tnum, iDb, 
                    (char *)pKey, P4_KEYINFO_HANDOFF);
  if( memRootPage>=0 ){
    v.ChangeP5(1)
  }

  //	Open the sorter cursor if we are to use one.
  iSorter = pParse.nTab++;
  sqlite3VdbeAddOp4(v, OP_SorterOpen, iSorter, 0, 0, (char*)pKey, P4_KEYINFO);

  //	Open the table. Loop through all rows of the table, inserting index records into the sorter.
  pParse.OpenTable(pTab, iTab, iDb, OP_OpenRead)
  addr1 = v.AddOp2(OP_Rewind, iTab, 0);
  regRecord = pParse.GetTempReg()

  sqlite3GenerateIndexKey(pParse, pIndex, iTab, regRecord, 1);
  v.AddOp2(OP_SorterInsert, iSorter, regRecord);
  v.AddOp2(OP_Next, iTab, addr1+1);
  v.JumpHere(addr1)
  addr1 = v.AddOp2(OP_SorterSort, iSorter, 0);
  if( pIndex.onError!=OE_None ){
    int j2 = v.CurrentAddr() + 3
    v.AddOp2(OP_Goto, 0, j2);
    addr2 = v.CurrentAddr()
    v.AddOp3(OP_SorterCompare, iSorter, j2, regRecord);
    sqlite3HaltConstraint(
        pParse, OE_Abort, "indexed columns are not unique", P4_STATIC
    );
  }else{
    addr2 = v.CurrentAddr()
  }
  v.AddOp2(OP_SorterData, iSorter, regRecord);
  v.AddOp3(OP_IdxInsert, iIdx, regRecord, 1);
  v.ChangeP5(OPFLAG_USESEEKRESULT)
  pParse.ReleaseTempReg(regRecord)
  v.AddOp2(OP_SorterNext, iSorter, addr2);
  v.JumpHere(addr1)

  v.AddOp1(OP_Close, iTab);
  v.AddOp1(OP_Close, iIdx);
  v.AddOp1(OP_Close, iSorter);
}

/*
** Create a new index for an SQL table.  pName1.pName2 is the name of the index 
** and pTblList is the name of the table that is to be indexed.  Both will 
** be NULL for a primary key or an index that is created to satisfy a
** UNIQUE constraint.  If pTable and pIndex are NULL, use pParse.pNewTable
** as the table to be indexed.  pParse.pNewTable is a table that is
** currently being constructed by a CREATE TABLE statement.
**
** pList is a list of columns to be indexed.  pList will be NULL if this
** is a primary key or unique-constraint on the most recent column added
** to the table currently under construction.  
**
** If the index is created successfully, return a pointer to the new Index
** structure. This is used by sqlite3AddPrimaryKey() to mark the index
** as the tables primary key (Index.autoIndex==2).
*/
func (pParse *Parse) CreateIndex(pName1, pName2 Token, pTblName *SrcList, pList *ExprList, onError int, pStart, pEnd Token, sortOrder int, ifNotExist bool) (pRet *Index) {
 Index *sqlite3CreateIndex(
  Parse *pParse,     /* All information about this parse */
  Token *pName1,     /* First part of index name. May be NULL */
  Token *pName2,     /* Second part of index name. May be NULL */
  SrcList *pTblName, /* Table to index. Use pParse.pNewTable if nil */
  ExprList *pList,   /* A list of columns to be indexed */
  int onError,       /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */
  Token *pStart,     /* The CREATE token that begins this statement */
  Token *pEnd,       /* The ")" that closes the CREATE INDEX statement */
  int sortOrder,     /* Sort order of primary key when pList==NULL */
  int ifNotExist     /* Omit error if index already exists */
){
	Index *pRet = 0;     /* Pointer to return */
	Table *pTab = 0;     /* Table to be indexed */
	char *Name = 0;     /* Name of the index */
	int nName;           /* Number of characters in Name */
	Token nullId;        /* Fake token for an empty ID list */
	int sortOrderMask;   /* 1 to honor DESC in index.  0 to ignore. */
	Db *pDb;             /* The specific table containing the indexed database */
	int iDb;             /* Index of the database that is being written */
	Token *pName = 0;    /* Unqualified name of the index to create */
	struct ExprList_item *pListItem; /* For looping over pList */
	int nCol;
	int nExtra = 0;
	char *zExtra;


	db = pParse.db
	pIndex := new(Index)
	defer func() {
	    //	Clean up before exiting
		db.ExprListDelete(pList)
		sqlite3SrcListDelete(db, pTblName)
	}()

	assert( pStart == nil || pEnd != nil )				//	pEnd must be non-NULL if pStart is
	assert( pParse.nErr == 0 )							//	Never called with prior errors
	if db.mallocFailed || IN_DECLARE_VTAB || pParse.ReadSchema() != SQLITE_OK {
		return
	}

	//	Find the table that is to be indexed. Return early if not found.
	if pTblName != nil {
		//	Use the two-part index name to determine the database to search for the table. 'Fix' the table name to this db before looking up the table.
		assert( pName1 != "" && pName2 != "" )
		pName, iDb = pParse.TwoPartName(pName1, pName2)
		if iDb < 0 {
			return
		}
		assert( pName != "" )

		//	If the index name was unqualified, check if the the table is a temp table. If so, set the database to 1. Do not do this if initialising a database schema.
		if !db.init.busy {
			pTab = pParse.SrcListLookup(pTblName)
			if len(pName2) == 0 && pTab != nil && pTab.Schema == db.Databases[1].Schema {
				iDb = 1
			}
		}

		if sFix := pParse.NewDbFixer(iDb, "index", pName); sFix != nil {
			sFix.FixSrcList(pTblName)				//	Because the parser constructs pTblName from a single identifier, FixSrcList can never fail.
		}
		pTab = pParse.LocateTable(pTblName.a[0].Name, pTblName.a[0].zDatabase, false)
		if pTab == nil || db.mallocFailed {
			return
		}
		assert( db.Databases[iDb].Schema == pTab.Schema )
	} else {
		assert( pName == "" )
		assert( pStart == nil )
		pTab = pParse.pNewTable
		if pTab == nil {
			return
		}
		iDb = db.SchemaToIndex(pTab.Schema)
	}
	pDb = &db.Databases[iDb]

	assert( pTab != nil )
	assert( pParse.nErr == 0 )
	switch {
	case CaseInsensitiveMatchN(pTab.Name, "sqlite_", 7) && memcmp(&pTab.Name[7],"altertab_",9) != 0:
		pParse.SetErrorMsg("table %v may not be indexed", pTab.Name)
		return
	case pTab.Select != nil:
		pParse.SetErrorMsg("views may not be indexed")
		return
	case pTab.IsVirtual(): {
		pParse.SetErrorMsg("virtual tables may not be indexed")
		return
	}

	//	Find the name of the index. Make sure there is not already another index or table with the same name.  
	//	Exception: If we are reading the names of permanent indices from the sqlite_master table (because some other process changed the schema) and one of the index names collides with the name of a temporary table or index, then we will continue to process this index.
	//	If pName == "" it means that we are dealing with a primary key or UNIQUE constraint. We have to invent our own name.
	if pName != "" {
		Name = Dequote(pName)
		switch {
		case Name == "":
			return
		case sqlite3CheckObjectName(pParse, Name) != SQLITE_OK:
			return
		case !db.init.busy && db.FindTable(Name, 0) != nil:
			pParse.SetErrorMsg("there is already a table named %v", Name);
			return
		case db.FindIndex(Name, pDb.Name) != nil:
			if !ifNotExist {
				pParse.SetErrorMsg("index %v already exists", Name)
			} else {
				assert( !db.init.busy )
				pParse.CodeVerifySchema(iDb)
			}
			return
		}
	} else {
		var n	int
		for n, pLoop := range pTab.Indices {}
		if Name = fmt.Sprintf("sqlite_autoindex_%v_%v", pTab.Name, n); Name == "" {
			return
		}
	}

	//	Check for authorization to create an index.
	zDb := pDb.Name
	if pParse.AuthCheck(SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) != SQLITE_OK {
		return
	}
	if iDb == 1 {
		i = SQLITE_CREATE_TEMP_INDEX
	} else {
		i = SQLITE_CREATE_INDEX
	}
	if pParse.AuthCheck(i, Name, pTab.Name, zDb) != SQLITE_OK {
		return
	}

	//	If pList == nil, it means this routine was called to make a primary key out of the last column added to the table under construction. So create a fake list to simulate this.
	if pList == nil {
		nullId := pTab.Columns[pTab.nCol-1].Name
		if pList = NewExprList(); pList == nil {
			return
		}
		pList.SetName(&nullId, false)
		pList.a[0].sortOrder = byte(sortOrder)
	}

	//	Figure out how many bytes of space are required to store explicitly specified collation sequence names.
	for _, item := range pList.Items {
		if pExpr := item.Expr; pExpr != nil {
			if pColl := pExpr.pColl; pColl != nil {
			//	Either pColl!=0 or there was an OOM failure. But if an OOM failure we have quit before reaching this point.
				nExtra += (1 + len(pColl.Name))
			}
		}
	}

	//	Allocate the index structure.
	nName = sqlite3Strlen30(Name)
	nCol = len(pList.Items)
	pIndex = sqlite3DbMallocZero(db, 
		ROUND(sizeof(Index), 8) +              /* Index structure  */
		ROUND(sizeof(tRowcnt)*(nCol+1), 8) +   /* Index.aiRowEst   */
		sizeof(char *)*nCol +                /* Index.azColl     */
		sizeof(int)*nCol +                   /* Index.Columns   */
		sizeof(byte)*nCol +                    /* Index.aSortOrder */
		nName + 1 +                          /* Index.Name      */
		nExtra                               /* Collation sequence names */
	)
	if db.mallocFailed {
		return
	}
	zExtra = (char*)pIndex
	pIndex.aiRowEst = (tRowcnt*)&zExtra[ROUND(sizeof(Index), 8)]
	pIndex.azColl = (char**) ((char*)pIndex.aiRowEst + ROUND(sizeof(tRowcnt)*nCol+1, 8))
	assert( EIGHT_BYTE_ALIGNMENT(pIndex.aiRowEst) )
	assert( EIGHT_BYTE_ALIGNMENT(pIndex.azColl) )
	pIndex.Columns = (int *)(&pIndex.azColl[nCol])
	pIndex.aSortOrder = (byte *)(&pIndex.Columns[nCol])
	pIndex.Name = (char *)(&pIndex.aSortOrder[nCol])
	zExtra = (char *)(&pIndex.Name[nName + 1])
	memcpy(pIndex.Name, Name, nName + 1)
	pIndex.pTable = pTab
//  len(pIndex.Columns) = len(pList.Items)
	pIndex.onError = (byte)onError
	pIndex.autoIndex = (byte)(pName == 0)
	pIndex.Schema = db.Databases[iDb].Schema

	//	Check to see if we should honor DESC requests on index columns
	if pDb.Schema.file_format >= 4 {
		sortOrderMask = -1			//	Honor DESC
	} else {
		sortOrderMask = 0			//	Ignore DESC
	}

	//	Scan the names of the columns of the table to be indexed and load the column indices into the Index structure. Report an error if any column is not found.
	//	TODO: Add a test to make sure that the same column is not named more than once within the same index. Only the first instance of the column will ever be used by the optimizer. Note that using the same column more than once cannot be an error because that would break backwards compatibility - it needs to be a warning.
	for i, pListItem := range pList.Items {
		zColName := pListItem.Name
		column				Column
		j					int
		requestedSortOrder	int
		zColl				string			//	Collation sequence name

		for j, column = range pTab.Columns {
			if CaseInsensitiveMatch(zColName, column.Name) {
				break
			}
		}
    	if j >= len(pTab.Columns) {
			pParse.SetErrorMsg("table %v has no column named %v", pTab.Name, zColName)
			pParse.checkSchema = 1
			return
		}
		pIndex.Columns[i] = j
		//	Justification of the pListItem.Expr.pColl: Because of the way the "idxlist" non-terminal is constructed by the parser, if pListItem.Expr is not null then either pListItem.Expr.pColl must exist or else there must have been an OOM error. But if there was an OOM error, we would never reach this point.
		if pListItem.Expr != nil && pListItem.Expr.pColl != nil {
			int nColl;
			zColl = pListItem.Expr.pColl.Name;
			nColl = sqlite3Strlen30(zColl) + 1;
			assert( nExtra >= nColl )
			memcpy(zExtra, zColl, nColl)
			zColl = zExtra
			zExtra += nColl
			nExtra -= nColl
		} else {
			if zColl = pTab.Columns[j].zColl; zColl == nil {
				zColl = db.pDfltColl.Name
			}
		}
		if !db.init.busy && !pParse.LocateCollSeq(zColl) {
			return
		}
		pIndex.azColl[i] = zColl
		requestedSortOrder = pListItem.sortOrder & sortOrderMask
		pIndex.aSortOrder[i] = byte(requestedSortOrder)
	}
	sqlite3DefaultRowEst(pIndex)

	if pTab == pParse.pNewTable {
		//	This routine has been called to create an automatic index as a result of a PRIMARY KEY or UNIQUE clause on a column definition, or a PRIMARY KEY or UNIQUE clause following the column definitions. i.e. one of:
		//			CREATE TABLE t(x PRIMARY KEY, y);
		//			CREATE TABLE t(x, y, UNIQUE(x, y));
		//	Either way, check to see if the table already has such an index. If so, don't bother creating this one. This only applies to automatically created indices. Users can do as they wish with explicit indices.
		//	Two UNIQUE or PRIMARY KEY constraints are considered equivalent (and thus suppressing the second one) even if they have different sort orders.
		//	If there are different collating sequences or if the columns of the constraint occur in different orders, then the constraints are considered distinct and both result in separate indices.
		for _, index := range pTab.Indices {
			assert( index.onError != OE_None )
			assert( index.autoIndex )
			assert( pIndex.onError != OE_None )

			if len(index.Columns) == len(pIndex.Columns) {
				var k, column	int
				for k, column := range index.Columns {
					if column != pIndex.Columns[k] || !CaseInsensitiveMatch(index.azColl[k], pIndex.azColl[k]) {
						break
					}
				}
				if k == len(index.Columns) {
					if index.onError != pIndex.onError {
						//	This constraint creates the same index as a previous constraint specified somewhere in the CREATE TABLE statement. However the ON CONFLICT clauses are different. If both this constraint and the previous equivalent constraint have explicit ON CONFLICT clauses this is an error. Otherwise, use the explicitly specified behaviour for the index.
						if !(index.onError == OE_Default || pIndex.onError == OE_Default) {
							pParse.SetErrorMsg("conflicting ON CONFLICT clauses specified")
						}
						if index.onError == OE_Default {
							index.onError = pIndex.onError
						}
					}
					return
				}
			}
		}
	}

	//	Link the new Index structure to its table and to the other in-memory database structures. 
	if db.init.busy {
		pIndex.Schema.Indices[pIndex.Name] = pIndex
		db.flags |= SQLITE_InternChanges
		if pTblName != "" {
			pIndex.tnum = db.init.newTnum
		}
	} else{
		//	If the db.init.busy is 0 then create the index on disk. This involves writing the index into the master table and filling in the index with the current table contents.
		//	The db.init.busy is 0 when the user first enters a CREATE INDEX command. db.init.busy is 1 when a database is opened and CREATE INDEX statements are read out of the master table. In the latter case the index already exists on disk, which is why we don't want to recreate it.
		//	If pTblName == "" it means this index is generated as a primary key or UNIQUE constraint of a CREATE TABLE statement. Since the table has just been created, it contains no data and the index initialization step can be skipped.
		pParse.nMem++
		iMem := pParse.nMem
		v := pParse.GetVdbe()
		if v == nil {
			return
		}

		//	Create the rootpage for the index
		pParse.BeginWriteOperation(1, iDb)
		v.AddOp2(OP_CreateIndex, iDb, iMem)

		//	Gather the complete text of the CREATE INDEX statement into the zStmt variable
		statement := ""
		if pStart != nil {
			assert( pEnd != nil )
			//	A named index with an explicit CREATE INDEX statement
				statement = fmt.Sprintf("CREATE%v INDEX %.v%v", onError == OE_None ? "" : " UNIQUE", int(pEnd.z - pName.z) + 1, pName.z);
		}

		//	Add an entry in sqlite_master for this index
		sqlite3NestedParse(pParse, 
			"INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);",
			db.Databases[iDb].Name, SCHEMA_TABLE(iDb),
			pIndex.Name,
			pTab.Name,
			iMem,
			statement
		)

		//	Fill the index with data and reparse the schema. Code an OP_Expire to invalidate all pre-compiled statements.
		if pTblName == "" {
			sqlite3RefillIndex(pParse, pIndex, iMem)
			sqlite3ChangeCookie(pParse, iDb)
			v.AddParseSchemaOp(iDb, fmt.Sprintf("name='%v' AND type='index'", pIndex.Name))
			v.AddOp1(OP_Expire, 0)
		}
	}

	//	When adding an index to the list of indices for a table, make sure all indices labeled OE_Replace come after all those labeled OE_Ignore. This is necessary for the correct constraint check processing (in sqlite3GenerateConstraintChecks()) as part of UPDATE and INSERT statements.  
	if db.init.busy || pTblName == "" {
		pTab.Indices = append(pTab.Indices, nil)
		offset := 0
		if onError == OE_Replace {
			var index	*Index
			for offset, index = range pTab.Indices {
				if index.onError == OE_Replace {
					break
				}
			}
		}
		copy(pTab.Indices[offset + 1:], pTab.Indices[offset:])
		pTab.Indices[offset] = pIndex
		pRet = pIndex
	}
}

/*
** Fill the Index.aiRowEst[] array with default information - information
** to be used when we have not run the ANALYZE command.
**
** aiRowEst[0] is suppose to contain the number of elements in the index.
** Since we do not know, guess 1 million.  aiRowEst[1] is an estimate of the
** number of rows in the table that match any particular value of the
** first column of the index.  aiRowEst[2] is an estimate of the number
** of rows that match any particular combiniation of the first 2 columns
** of the index.  And so forth.  It must always be the case that
*
**           aiRowEst[N]<=aiRowEst[N-1]
**           aiRowEst[N]>=1
**
** Apart from that, we have little to go on besides intuition as to
** how aiRowEst[] should be initialized.  The numbers generated here
** are based on typical values found in actual indices.
*/
 void sqlite3DefaultRowEst(Index *pIdx){
  tRowcnt *a = pIdx.aiRowEst;
  int i;
  tRowcnt n;
  assert( a!=0 );
  a[0] = pIdx.pTable.nRowEst;
  if( a[0]<10 ) a[0] = 10;
  n = 10;
  for(i=1; i<=len(pIdx.Columns); i++){
    a[i] = n;
    if( n>5 ) n--;
  }
  if( pIdx.onError!=OE_None ){
    a[len(pIdx.Columns)] = 1;
  }
}

/*
** This routine will drop an existing named index.  This routine
** implements the DROP INDEX statement.
*/
 void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){
  Index *pIndex;
  Vdbe *v;
  sqlite3 *db = pParse.db;
  int iDb;

  assert( pParse.nErr==0 );   /* Never called with prior errors */
  if( db.mallocFailed ){
    goto exit_drop_index;
  }
  assert( pName.nSrc==1 );
if pParse.ReadSchema() != SQLITE_OK {
	goto exit_drop_index
  }
  pIndex = db.FindIndex(pName.a[0].Name, pName.a[0].zDatabase)
  if( pIndex==0 ){
    if( !ifExists ){
      pParse.SetErrorMsg("no such index: %v", pName);
    }else{
      sqlite3CodeVerifyNamedSchema(pParse, pName.a[0].zDatabase);
    }
    pParse.checkSchema = 1;
    goto exit_drop_index;
  }
  if( pIndex.autoIndex ){
    pParse.SetErrorMsg("index associated with UNIQUE or PRIMARY KEY constraint cannot be dropped");
    goto exit_drop_index;
  }
  iDb = db.SchemaToIndex(pIndex.Schema)
  {
    int code = SQLITE_DROP_INDEX;
    Table *pTab = pIndex.pTable;
    const char *zDb = db.Databases[iDb].Name;
    const char *zTab = SCHEMA_TABLE(iDb);
    if pParse.AuthCheck(SQLITE_DELETE, zTab, 0, zDb) != SQLITE_OK {
      goto exit_drop_index
    }
    if iDb != 0 {
		code = SQLITE_DROP_TEMP_INDEX
	}
    if pParse.AuthCheck(code, pIndex.Name, pTab.Name, zDb) != SQLITE_OK {
      goto exit_drop_index
    }
  }

  /* Generate code to remove the index and from the master table */
  v = pParse.GetVdbe()
  if( v ){
    pParse.BeginWriteOperation(1, iDb)
    sqlite3NestedParse(pParse,
       "DELETE FROM %Q.%s WHERE name=%Q AND type='index'",
       db.Databases[iDb].Name, SCHEMA_TABLE(iDb), pIndex.Name
    );
    sqlite3ClearStatTables(pParse, iDb, "idx", pIndex.Name);
    sqlite3ChangeCookie(pParse, iDb);
    pParse.destroyRootPage(pIndex.tnum, iDb);
    sqlite3VdbeAddOp4(v, OP_DropIndex, iDb, 0, 0, pIndex.Name, 0);
  }

exit_drop_index:
  sqlite3SrcListDelete(db, pName);
}

/*
** pArray is a pointer to an array of objects. Each object in the
** array is szEntry bytes in size. This routine uses sqlite3DbRealloc()
** to extend the array so that there is space for a new object at the end.
**
** When this function is called, *pnEntry contains the current size of
** the array (in entries - so the allocation is ((*pnEntry) * szEntry) bytes
** in total).
**
** If the realloc() is successful (i.e. if no OOM condition occurs), the
** space allocated for the new object is zeroed, *pnEntry updated to
** reflect the new size of the array and a pointer to the new allocation
** returned. *pIdx is set to the index of the new array entry in this case.
**
** Otherwise, if the realloc() fails, *pIdx is set to -1, *pnEntry remains
** unchanged and a copy of pArray returned.
*/
 void *sqlite3ArrayAllocate(
  sqlite3 *db,      /* Connection to notify of malloc failures */
  void *pArray,     /* Array of objects.  Might be reallocated */
  int szEntry,      /* Size of each object in the array */
  int *pnEntry,     /* Number of objects currently in use */
  int *pIdx         /* Write the index of a new slot here */
){
  char *z;
  int n = *pnEntry;
  if( (n & (n-1))==0 ){
    int sz = (n==0) ? 1 : 2*n;
    void *pNew = sqlite3DbRealloc(db, pArray, sz*szEntry);
    if( pNew==0 ){
      *pIdx = -1;
      return pArray;
    }
    pArray = pNew;
  }
  z = (char*)pArray;
  memset(&z[n * szEntry], 0, szEntry);
  *pIdx = n;
  ++*pnEntry;
  return pArray;
}

/*
** Append a new element to the given IdList.  Create a new IdList if
** need be.
**
** A new IdList is returned, or NULL if malloc() fails.
*/
 IdList *sqlite3IdListAppend(sqlite3 *db, IdList *pList, Token *pToken){
  int i;
  if( pList==0 ){
    pList = sqlite3DbMallocZero(db, sizeof(IdList) );
    if( pList==0 ) return 0;
  }
  pList.a = sqlite3ArrayAllocate(
      db,
      pList.a,
      sizeof(pList.a[0]),
      &pList.nId,
      &i
  );
  if( i<0 ){
    sqlite3IdListDelete(db, pList);
    return 0;
  }
  pList.a[i].Name = Dequote(pToken)
  return pList;
}

/*
** Delete an IdList.
*/
 void sqlite3IdListDelete(sqlite3 *db, IdList *pList){
  int i;
  if( pList==0 ) return;
  for(i=0; i<pList.nId; i++){
    pList.a[i].Name = nil
  }
  pList.a = nil
  pList = nil
}

/*
** Return the index in pList of the identifier named zId.  Return -1
** if not found.
*/
 int sqlite3IdListIndex(IdList *pList, const char *Name){
  int i;
  if( pList==0 ) return -1;
  for(i=0; i<pList.nId; i++){
    if CaseInsensitiveMatch(pList.a[i].Name, Name) {
		return i
	}
  }
  return -1;
}

/*
** Expand the space allocated for the given SrcList object by
** creating nExtra new slots beginning at iStart.  iStart is zero based.
** New slots are zeroed.
**
** For example, suppose a SrcList initially contains two entries: A,B.
** To append 3 new entries onto the end, do this:
**
**    sqlite3SrcListEnlarge(db, pSrclist, 3, 2);
**
** After the call above it would contain:  A, B, nil, nil, nil.
** If the iStart argument had been 1 instead of 2, then the result
** would have been:  A, nil, nil, nil, B.  To prepend the new slots,
** the iStart value would be 0.  The result then would
** be: nil, nil, nil, A, B.
**
** If a memory allocation fails the SrcList is unchanged.  The
** db.mallocFailed flag will be set to true.
*/
 SrcList *sqlite3SrcListEnlarge(
  sqlite3 *db,       /* Database connection to notify of OOM errors */
  SrcList *pSrc,     /* The SrcList to be enlarged */
  int nExtra,        /* Number of new slots to add to pSrc.a[] */
  int iStart         /* Index in pSrc.a[] of first new slot */
){
	int i;

	//	Sanity checking on calling parameters
	assert( iStart >= 0 )
	assert( nExtra >= 1 )
	assert( pSrc != 0 )
	assert( iStart <= len(pSrc) )

	if( len(pSrc) + nExtra > cap(pSrc) ) {
		pNew := make(SrcList, len(pSrc) + nExtra)
		copy(pNew, pSrc[:iStart])
		copy(pNew[iStart + nExtra:], pSrc[iStart:])
		*pSrc = pNew
	} else {
		copy(pSrc[iStart + nExtra:], pSrc[iStart:])
		for i := iStart + nExtra; i > iStart; i-- {
			pSrc[i] = nil
		}
	}
	return pSrc
}


//	Append a new table name to the given SrcList. Create a new SrcList if need be. A new entry is created in the SrcList even if pTable is NULL.
//	A SrcList is returned, or NULL if there is an OOM error. The returned SrcList might be the same as the SrcList that was input or it might be a new one. If an OOM error does occurs, then the prior value of pList that is input to this routine is automatically freed.
//	If pDatabase is not null, it means that the table has an optional database name prefix. Like this:  "database.table". The pDatabase points to the table name and the pTable points to the database name. The SrcList.a[].Name field is filled with the table name which might come from pTable (if pDatabase is NULL) or from pDatabase. SrcList.a[].zDatabase is filled with the database name from pTable, or with NULL if no database is specified.
//	In other words, if call like this:
//			D.SrcListAppend(A, B, 0)
//	Then B is a table name and the database name is unspecified. If called like this:
//			D.SrcListAppend(A, B, C)
//	Then C is the table name and B is the database name. If C is defined then so is B. In other words, we never have a case where:
//			D.SrcListAppend(A, 0, C)
//	Both pTable and pDatabase are assumed to be quoted. They are dequoted before being added to the SrcList.
func (db *sqlite3) SrcListAppend(pList SrcList, table, database string) *SrcList {
	pItem	*struct SrcList_item
	assert( pDatabase==0 || pTable!=0 );  /* Cannot have C without B */
		if pList == nil {
			pList = sqlite3DbMallocZero(db, sizeof(SrcList)
		}
		if pList == nil {
			return 0
		}
		pList.nAlloc = 1
	}
	pList = sqlite3SrcListEnlarge(db, pList, 1, pList.nSrc)
	if db.mallocFailed {
		sqlite3SrcListDelete(db, pList)
		return nil
	}
	pItem = &pList.a[pList.nSrc - 1]
	if database != "" {
		database, table = table, database
	}
	pItem.Name = Dequote(pTable)
	pItem.zDatabase = Dequote(pDatabase)
	return pList
}

/*
** Assign VdbeCursor index numbers to all tables in a SrcList
*/
 void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){
  int i;
  struct SrcList_item *pItem;
  assert(pList || pParse.db.mallocFailed );
  if( pList ){
    for(i=0, pItem=pList.a; i<pList.nSrc; i++, pItem++){
      if( pItem.iCursor>=0 ) break;
      pItem.iCursor = pParse.nTab++;
      if( pItem.Select ){
        sqlite3SrcListAssignCursors(pParse, pItem.Select.pSrc);
      }
    }
  }
}

/*
** Delete an entire SrcList including all its substructure.
*/
 void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){
  int i;
  struct SrcList_item *pItem;
  if( pList==0 ) return;
  for(pItem=pList.a, i=0; i<pList.nSrc; i++, pItem++){
    pItem.zDatabase = nil
    pItem.Name = nil
    pItem.zAlias = nil
    pItem.zIndex = nil
    db.DeleteTable(pItem.pTab)
    sqlite3SelectDelete(db, pItem.Select);
    db.ExprDelete(pItem.pOn)
    sqlite3IdListDelete(db, pItem.pUsing);
  }
  pList = nil
}

/*
** This routine is called by the parser to add a new term to the
** end of a growing FROM clause.  The "p" parameter is the part of
** the FROM clause that has already been constructed.  "p" is NULL
** if this is the first term of the FROM clause.  pTable and pDatabase
** are the name of the table and database named in the FROM clause term.
** pDatabase is NULL if the database name qualifier is missing - the
** usual case.  If the term has a alias, then pAlias points to the
** alias token.  If the term is a subquery, then pSubquery is the
** SELECT statement that the subquery encodes.  The pTable and
** pDatabase parameters are NULL for subqueries.  The pOn and pUsing
** parameters are the content of the ON and USING clauses.
**
** Return a new SrcList which encodes is the FROM with the new
** term added.
*/
 SrcList *sqlite3SrcListAppendFromTerm(
  Parse *pParse,          /* Parsing context */
  SrcList *p,             /* The left part of the FROM clause already seen */
  Token *pTable,          /* Name of the table to add to the FROM clause */
  Token *pDatabase,       /* Name of the database containing pTable */
  Token *pAlias,          /* The right-hand side of the AS subexpression */
  Select *pSubquery,      /* A subquery used in place of a table name */
  Expr *pOn,              /* The ON clause of a join */
  IdList *pUsing          /* The USING clause of a join */
){
  struct SrcList_item *pItem;
  sqlite3 *db = pParse.db;
  if( !p && (pOn || pUsing) ){
	if pOn != nil {
		pParse.SetErrorMsg("a JOIN clause is required before ON");
	} else {
		pParse.SetErrorMsg("a JOIN clause is required before USING");
	}
    goto append_from_error;
  }
  p = db.SrcListAppend(p, pTable, pDatabase)
  if( p==0 || p.nSrc==0 ){
    goto append_from_error;
  }
  pItem = &p.a[p.nSrc-1];
  assert( pAlias!=0 );
  if( pAlias.n ){
    pItem.zAlias = Dequote(pAlias)
  }
  pItem.Select = pSubquery;
  pItem.pOn = pOn;
  pItem.pUsing = pUsing;
  return p;

 append_from_error:
  assert( p==0 );
  db.ExprDelete(pOn)
  sqlite3IdListDelete(db, pUsing);
  sqlite3SelectDelete(db, pSubquery);
  return 0;
}

//	Add an INDEXED BY or NOT INDEXED clause to the most recently added element of the source-list passed as the second argument.
func (pParse *Parse) ListIndexedBy(p *SrcList, pIndexedBy *Token) {
	assert( pIndexedBy != nil )
	if p != nil && len(p) > 0 {
		pItem := &p[len(p) - 1]
		assert( !pItem.notIndexed && pItem.zIndex == 0 )
		if pIndexedBy.n == 1 && !pIndexedBy.z {
			//	A "NOT INDEXED" clause was supplied. See parse.y construct "indexed_opt" for details.
			pItem.notIndexed = true
		} else {
			pItem.zIndex = Dequote(pIndexedBy)
		}
	}
}

/*
** When building up a FROM clause in the parser, the join operator
** is initially attached to the left operand.  But the code generator
** expects the join operator to be on the right operand.  This routine
** Shifts all join operators from left to right for an entire FROM
** clause.
**
** Example: Suppose the join is like this:
**
**           A natural cross join B
**
** The operator is "natural cross join".  The A and B operands are stored
** in p.a[0] and p.a[1], respectively.  The parser initially stores the
** operator with A.  This routine shifts that operator over to B.
*/
 void sqlite3SrcListShiftJoinType(SrcList *p){
  if( p ){
    int i;
    assert( p.a || p.nSrc==0 );
    for(i=p.nSrc-1; i>0; i--){
      p.a[i].jointype = p.a[i-1].jointype;
    }
    p.a[0].jointype = 0;
  }
}

//	Begin a transaction
func (pParse *Parse) BeginTransaction(t int) {
	assert( pParse != nil )
	db := pParse.db
	assert( db != nil )
	//	if db.Databases[0].pBt == nil { return }
	if pParse.AuthCheck(SQLITE_TRANSACTION, "BEGIN", 0, 0) == SQLITE_OK {
		if v := pParse.GetVdbe(); v != nil {
			if t != TK_DEFERRED {
				for i, _ := range db.Databases {
					if t == TK_EXCLUSIVE {
						v.AddOp2(OP_Transaction, i, 2)
					} else {
						v.AddOp2(OP_Transaction, i, 1)
					}
					sqlite3VdbeUsesBtree(v, i)
				}
			}
			v.AddOp2(OP_AutoCommit, 0, 0)
		}
	}
}

//	Commit a transaction
func (pParse *Parse) CommitTransaction() {
	assert( pParse != nil )
	assert( pParse.db != nil )
	if pParse.AuthCheck(SQLITE_TRANSACTION, "COMMIT", 0, 0) == SQLITE_OK {
		if v := pParse.GetVdbe(); v != nil {
			v.AddOp2(OP_AutoCommit, 1, 0)
		}
	}
}

//	Rollback a transaction
func (pParse *Parse) RollbackTransaction() {
	assert( pParse != nil )
	assert( pParse.db != nil )
	if pParse.AuthCheck(SQLITE_TRANSACTION, "ROLLBACK", 0, 0) == SQLITE_OK {
		if v := pParse.GetVdbe(); v {
			v.AddOp2(OP_AutoCommit, 1, 1)
		}
	}
}

//	This function is called by the parser when it parses a command to create, release or rollback an SQL savepoint.
func (pParse *Parse) Savepoint(op int, pName Token) {
	if Name := Dequote(pName); Name != "" {
		if v := pParse.GetVdbe(); v != nil {
			az := []string{ "BEGIN", "RELEASE", "ROLLBACK" }
			assert( SAVEPOINT_BEGIN == 0 && SAVEPOINT_RELEASE == 1 && SAVEPOINT_ROLLBACK == 2 )
			if pParse.AuthCheck(SQLITE_SAVEPOINT, az[op], Name, 0) == SQLITE_OK {
				sqlite3VdbeAddOp4(v, OP_Savepoint, op, 0, 0, Name, P4_DYNAMIC)
			}
		}
	}
}

/*
** Make sure the TEMP database is open and available for use.  Return
** the number of errors.  Leave any error messages in the pParse structure.
*/
 int sqlite3OpenTempDatabase(Parse *pParse){
  sqlite3 *db = pParse.db;
  if( db.Databases[1].pBt==0 && !pParse.explain ){
    int rc;
    Btree *pBt;
    static const int flags = 
          SQLITE_OPEN_READWRITE |
          SQLITE_OPEN_CREATE |
          SQLITE_OPEN_EXCLUSIVE |
          SQLITE_OPEN_DELETEONCLOSE |
          SQLITE_OPEN_TEMP_DB;

    rc = sqlite3BtreeOpen(db.pVfs, 0, db, &pBt, 0, flags);
    if( rc!=SQLITE_OK ){
      pParse.SetErrorMsg("unable to open a temporary database file for storing temporary tables");
      pParse.rc = rc;
      return 1;
    }
    db.Databases[1].pBt = pBt;
    assert( db.Databases[1].Schema );
    if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db.nextPagesize, -1, 0) ){
      db.mallocFailed = true
      return 1;
    }
  }
  return 0;
}

//	Generate VDBE code that will verify the schema cookie and start a read-transaction for all named database files.
//	It is important that all schema cookies be verified and all read transactions be started before anything else happens in the VDBE program. But this routine can be called after much other code has been generated. So here is what we do:
//	The first time this routine is called, we code an OP_Goto that will jump to a subroutine at the end of the program. Then we record every database that needs its schema verified in the pParse.cookieMask field. Later, after all other code has been generated, the subroutine that does the cookie verifications and starts the transactions will be coded and the OP_Goto P2 value will be made to point to that subroutine. The generation of the cookie verification subroutine code happens in sqlite3FinishCoding().
//	If iDb < 0 then code the OP_Goto only - don't set flag to verify the schema on any databases. This can be used to position the OP_Goto early in the code, before we know if any database tables will be used.
func (pParse *Parse) CodeVerifySchema(iDb int) {
	pToplevel := pParse.Toplevel()
	if pToplevel.cookieGoto == 0 {
		v := pToplevel.GetVdbe()
		if v == nil {
			return					//	This only happens if there was a prior error
		}
		pToplevel.cookieGoto = v.AddOp2(OP_Goto, 0, 0) + 1
	}
	if iDb >= 0 {
		db := pToplevel.db
		yDbMask mask

		assert( iDb < db.nDb )
		assert( db.Databases[iDb].pBt != 0 || iDb == 1 )
		assert( iDb < SQLITE_MAX_ATTACHED + 2 )
		mask := yDbMask(1) << iDb
		if (pToplevel.cookieMask & mask) == 0 {
			pToplevel.cookieMask |= mask
			pToplevel.cookieValue[iDb] = db.Databases[iDb].Schema.schema_cookie
			if iDb == 1 {
				sqlite3OpenTempDatabase(pToplevel)
			}
		}
	}
}

//	If argument zDb is NULL, then call CodeVerifySchema() for each attached database. Otherwise, invoke it for the database named zDb only.
void sqlite3CodeVerifyNamedSchema(Parse *pParse, const char *zDb){
  sqlite3 *db = pParse.db;
  int i;
  for(i=0; i<db.nDb; i++){
    Db *pDb = &db.Databases[i];
    if( pDb.pBt && (zDb != "" || CaseInsensitiveMatch(zDb, pDb.Name)) {
      pParse.CodeVerifySchema(i)
    }
  }
}

//	Generate VDBE code that prepares for doing an operation that might change the database.
//	This routine starts a new transaction if we are not already within a transaction. If we are already within a transaction, then a checkpoint is set if the setStatement parameter is true. A checkpoint should be set for operations that might fail (due to a constraint) part of the way through and which will need to undo some writes without having to rollback the whole transaction. For operations where all constraints can be checked before any changes are made to the database, it is never necessary to undo a write and the checkpoint should not be set.
func (pParse *Parse) BeginWriteOperation(setStatement, iDb int) {
	pToplevel := pParse.Toplevel()
	pParse.CodeVerifySchema(iDb)
	pToplevel.writeMask |= yDbMask(1) << iDb
	pToplevel.isMultiWrite |= setStatement
}

/*
** Indicate that the statement currently under construction might write
** more than one entry (example: deleting one row then inserting another,
** inserting multiple rows in a table, or inserting a row and index entries.)
** If an abort occurs after some of these writes have completed, then it will
** be necessary to undo the completed writes.
*/
 void sqlite3MultiWrite(Parse *pParse){
  pToplevel := pParse.Toplevel()
  pToplevel.isMultiWrite = 1;
}

/* 
** The code generator calls this routine if is discovers that it is
** possible to abort a statement prior to completion.  In order to 
** perform this abort without corrupting the database, we need to make
** sure that the statement is protected by a statement transaction.
**
** Technically, we only need to set the mayAbort flag if the
** isMultiWrite flag was previously set.  There is a time dependency
** such that the abort must occur after the multiwrite.  This makes
** some statements involving the REPLACE conflict resolution algorithm
** go a little faster.  But taking advantage of this time dependency
** makes it more difficult to prove that the code is correct (in 
** particular, it prevents us from writing an effective
** implementation of sqlite3AssertMayAbort()) and so we have chosen
** to take the safe route and skip the optimization.
*/
 void sqlite3MayAbort(Parse *pParse){
  pToplevel := pParse.Toplevel()
  pToplevel.mayAbort = 1;
}

//	Code an OP_Halt that causes the vdbe to return an SQLITE_CONSTRAINT error. The onError parameter determines which (if any) of the statement and/or current transaction is rolled back.
void sqlite3HaltConstraint(Parse *pParse, int onError, char *p4, int p4type){
  Vdbe *v = pParse.GetVdbe()
  if( onError==OE_Abort ){
    sqlite3MayAbort(pParse);
  }
  sqlite3VdbeAddOp4(v, OP_Halt, SQLITE_CONSTRAINT, onError, 0, p4, p4type);
}

//	Check to see if pIndex uses the collating sequence pColl. Return true if it does and false if it does not.
func (index *Index) collationMatch(collation string) bool {
	for i, _ := range index.Columns {
		if CaseInsensitiveMatch(index.azColl[i], collation) {
			return true
		}
	}
	return false
}

//	Recompute all indices of pTab that use the collating sequence pColl. If pColl == nil then recompute all indices of pTab.
func (pParse *Parse) reindexTable(table *Table, collation string) {
	for _, index := range table.Indices {
		if collation == "" || collationMatch(collation, index) {
			iDb := pParse.db.SchemaToIndex(table.Schema)
			pParse.BeginWriteOperation(0, iDb)
			sqlite3RefillIndex(pParse, index, -1)
		}
	}
}

//	Recompute all indices of all tables in all databases where the indices use the collating sequence pColl. If pColl == 0 then recompute all indices everywhere.
func (pParse *Parse) reindexDatabases(collation string) {
	db := pParse.db
	for iDb, _ := range db.Databases {
		for _, table := range db.Databases[iDb].Schema.Tables {
			pParse.reindexTable(table, collation)
		}
	}
}

/*
** Generate code for the REINDEX command.
**
**        REINDEX                            -- 1
**        REINDEX  <collation>               -- 2
**        REINDEX  ?<database>.?<tablename>  -- 3
**        REINDEX  ?<database>.?<indexname>  -- 4
**
** Form 1 causes all indices in all attached databases to be rebuilt.
** Form 2 rebuilds all indices in all databases that use the named
** collating function.  Forms 3 and 4 rebuild the named index or all
** indices associated with the named table.
*/
void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){
  CollSeq *pColl;             /* Collating sequence to be reindexed, or NULL */
  char *z;                    /* Name of a table or index */
  const char *zDb;            /* Name of the database */
  Table *pTab;                /* A table in the database */
  Index *pIndex;              /* An index associated with pTab */
  int iDb;                    /* The database index number */
  sqlite3 *db = pParse.db;   /* The database connection */
  Token *pObjName;            /* Name of the table or index to be reindexed */

  /* Read the database schema. If an error occurs, leave an error message
  ** and code in pParse and return NULL. */
		if pParse.ReadSchema() != SQLITE_OK {
			return
		}

  if( pName1==0 ){
    pParse.reindexDatabases("")
    return;
  }else if( pName2==0 || pName2.z==0 ){
    char *zColl;
    assert( pName1.z );
    zColl = Dequote(pName1)
    if( !zColl ) return;
    pColl = sqlite3FindCollSeq(db, db.Encoding(), zColl, 0);
    if( pColl ){
      pParse.reindexDatabases(zColl)
      zColl = nil
      return;
    }
    zColl = nil
  }
  pObjName, iDb = pParse.TwoPartName(pName1, pName2)
  if( iDb<0 ) return;
  z = Dequote(pObjName)
  if( z==0 ) return;
  zDb = db.Databases[iDb].Name;
  pTab = db.FindTable(z, zDb)
  if( pTab ){
    pParse.reindexTable(pTab, "")
    z = nil
    return;
  }
  pIndex = db.FindIndex(z, zDb)
  z = nil
  if( pIndex ){
    pParse.BeginWriteOperation(0, iDb)
    sqlite3RefillIndex(pParse, pIndex, -1);
    return;
  }
  pParse.SetErrorMsg("unable to identify the object to be reindexed");
}

//	Return a dynamicly allocated KeyInfo structure that can be used with OP_OpenRead or OP_OpenWrite to access database index pIdx.
//	If successful, a pointer to the new structure is returned. If an error occurs (out of memory or missing collation sequence), NULL is returned and the state of pParse updated to reflect the error.
func (pParse *Parse) IndexKeyinfo(pIdx *Index) (pKey *KeyInfo) {
	nCol := len(pIdx.Columns)
	nBytes := sizeof(KeyInfo) + (nCol-1)*sizeof(CollSeq*) + nCol
	db := pParse.db
	if pKey = (KeyInfo *)sqlite3DbMallocZero(db, nBytes); pKey != nil {
		pKey.db = pParse.db
		pKey.aSortOrder = (byte *)&(pKey.Collations[nCol])
		assert( &pKey.aSortOrder[nCol] == &(((byte *)pKey)[nBytes]) )
		for i := 0; i < nCol; i++ {
			zColl := pIdx.azColl[i]
			assert( zColl != "" )
			pKey.Collations[i] = pParse.LocateCollSeq(zColl)
			pKey.aSortOrder[i] = pIdx.aSortOrder[i]
		}
		pKey.nField = uint16(nCol)
		if pParse.nErr > 0 {
			pKey = nil
		}
	}
	return pKey
}